# Integer Overflow Vulnerabilities

Integer overflow vulnerabilities occur when arithmetic operations produce results that exceed the maximum value that can be stored in the integer type. These can lead to unexpected behavior, memory corruption, and security bypasses.

## Understanding Integer Overflows

### Integer Types and Ranges

```c
Integer Type Ranges (typical 64-bit system):
┌─────────────────────┬─────────────────────┬─────────────────────┐
│ Type                │ Minimum Value       │ Maximum Value       │
├─────────────────────┼─────────────────────┼─────────────────────┤
│ char                │ -128                │ 127                 │
│ unsigned char       │ 0                   │ 255                 │
│ short               │ -32,768             │ 32,767              │
│ unsigned short      │ 0                   │ 65,535              │
│ int                 │ -2,147,483,648      │ 2,147,483,647       │
│ unsigned int        │ 0                   │ 4,294,967,295       │
│ long long           │ -9,223,372,036,854,775,808 │ 9,223,372,036,854,775,807 │
│ size_t              │ 0                   │ 18,446,744,073,709,551,615 │
└─────────────────────┴─────────────────────┴─────────────────────┘
```

### Types of Integer Overflows

1. **Arithmetic overflow** - Addition, multiplication exceeding limits
2. **Wraparound** - Values wrapping from max to min or vice versa
3. **Underflow** - Unsigned values wrapping to maximum
4. **Sign extension issues** - Mixing signed and unsigned types
5. **Truncation** - Casting larger types to smaller types

## Vulnerable Code Examples

### Basic Integer Overflow

```c
// vuln_overflow.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void vulnerable_malloc(unsigned int size) {
    printf("Allocating buffer of size: %u\n", size);
    
    // VULNERABLE: size can overflow in arithmetic
    char *buffer = malloc(size + 1);  // +1 for null terminator
    
    if (!buffer) {
        printf("Allocation failed\n");
        return;
    }
    
    printf("Buffer allocated at: %p\n", buffer);
    
    // Fill buffer with 'A's
    memset(buffer, 'A', size);
    buffer[size] = '\0';
    
    printf("Buffer filled\n");
    free(buffer);
}

int main(int argc, char *argv[]) {
    if (argc != 2) {
        printf("Usage: %s <size>\n", argv[0]);
        return 1;
    }
    
    unsigned int size = (unsigned int)atoi(argv[1]);
    vulnerable_malloc(size);
    
    return 0;
}
```

**Test:**
```bash
gcc -o vuln_overflow vuln_overflow.c
./vuln_overflow 100        # Normal case
./vuln_overflow 4294967295 # UINT_MAX - causes overflow in size + 1
```

### Array Allocation Overflow

```c
// vuln_array_alloc.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
    int *data;
    size_t count;
} int_array;

int_array* create_array(size_t count) {
    printf("Creating array with %zu elements\n", count);
    
    int_array *arr = malloc(sizeof(int_array));
    if (!arr) return NULL;
    
    // VULNERABLE: count * sizeof(int) can overflow
    arr->data = malloc(count * sizeof(int));
    
    if (!arr->data) {
        free(arr);
        return NULL;
    }
    
    arr->count = count;
    return arr;
}

void fill_array(int_array *arr, int value) {
    printf("Filling array with value %d\n", value);
    
    // This loop might access beyond allocated memory
    for (size_t i = 0; i < arr->count; i++) {
        arr->data[i] = value;
    }
}

int main(int argc, char *argv[]) {
    if (argc != 3) {
        printf("Usage: %s <count> <value>\n", argv[0]);
        return 1;
    }
    
    size_t count = (size_t)atoll(argv[1]);
    int value = atoi(argv[2]);
    
    int_array *arr = create_array(count);
    if (arr) {
        fill_array(arr, value);
        printf("Array operations completed\n");
        free(arr->data);
        free(arr);
    }
    
    return 0;
}
```

### Length Validation Bypass

```c
// vuln_length.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_SIZE 1024

void process_data(char *data, unsigned int length) {
    // Length validation
    if (length > MAX_SIZE) {
        printf("Data too long: %u > %u\n", length, MAX_SIZE);
        return;
    }
    
    printf("Processing data of length: %u\n", length);
    
    // VULNERABLE: length - 1 can underflow
    char *buffer = malloc(length - 1);
    
    if (!buffer) {
        printf("Allocation failed\n");
        return;
    }
    
    // Copy data (potential heap overflow)
    memcpy(buffer, data, length);
    
    printf("Data processed\n");
    free(buffer);
}

int main(int argc, char *argv[]) {
    if (argc != 2) {
        printf("Usage: %s <data>\n", argv[0]);
        return 1;
    }
    
    char *data = argv[1];
    unsigned int length = strlen(data);
    
    process_data(data, length);
    
    return 0;
}
```

### Sign Extension Vulnerability

```c
// vuln_sign.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void copy_data(char *src, int src_len) {
    // Check for reasonable length
    if (src_len < 0 || src_len > 1000) {
        printf("Invalid length: %d\n", src_len);
        return;
    }
    
    printf("Copying %d bytes\n", src_len);
    
    // VULNERABLE: sign extension when casting to size_t
    char *dest = malloc(src_len);
    if (!dest) {
        printf("Allocation failed\n");
        return;
    }
    
    // memcpy expects size_t (unsigned), but src_len is signed
    memcpy(dest, src, src_len);
    
    printf("Copy completed\n");
    free(dest);
}

int main(int argc, char *argv[]) {
    if (argc != 3) {
        printf("Usage: %s <data> <length>\n", argv[0]);
        return 1;
    }
    
    char *data = argv[1];
    int length = atoi(argv[2]);
    
    copy_data(data, length);
    
    return 0;
}
```

## Exploitation Techniques

### Heap Overflow via Integer Overflow

```python
#!/usr/bin/env python3
from pwn import *

def exploit_malloc_overflow():
    """Exploit malloc size calculation overflow"""
    
    # When size + 1 overflows, malloc allocates small buffer
    # but memset writes large amount
    
    # UINT_MAX = 4294967295
    # UINT_MAX + 1 = 0 (overflow)
    # malloc(0) might return small buffer or NULL
    
    overflow_size = 0xffffffff  # UINT_MAX
    
    p = process(['./vuln_overflow', str(overflow_size)])
    
    output = p.recvall()
    print("Overflow attempt output:")
    print(output.decode())
    
    # Check if program crashed
    if p.returncode != 0:
        print("Program crashed - potential overflow exploitation")
    
    p.close()

def exploit_array_allocation():
    """Exploit array allocation overflow"""
    
    # Find count where count * sizeof(int) overflows
    # sizeof(int) = 4 on most systems
    # We want count * 4 to overflow back to small value
    
    # 2^64 / 4 = 2^62
    # Values around this will cause overflow
    
    overflow_count = 0x4000000000000000  # Large value that overflows
    
    p = process(['./vuln_array_alloc', str(overflow_count), '42'])
    
    output = p.recvall(timeout=5)
    print("Array allocation overflow:")
    print(output.decode())
    
    p.close()

def exploit_length_underflow():
    """Exploit length - 1 underflow"""
    
    # When length = 0, length - 1 underflows to UINT_MAX
    # malloc(UINT_MAX) likely fails, but if it succeeds,
    # memcpy will copy 0 bytes but think buffer is huge
    
    # Send empty string (length = 0)
    p = process(['./vuln_length', ''])
    
    output = p.recvall()
    print("Length underflow attempt:")
    print(output.decode())
    
    p.close()

def exploit_sign_extension():
    """Exploit sign extension vulnerability"""
    
    # Use large positive value that becomes negative when cast to int
    # 0x80000000 = 2147483648 as unsigned = -2147483648 as signed
    
    large_value = 0x80000000
    
    # This might pass the check (large_value as int is negative)
    # but memcpy sees it as large positive value
    
    data = b'A' * 100
    
    p = process(['./vuln_sign', data.decode(), str(large_value)])
    
    output = p.recvall()
    print("Sign extension exploit:")
    print(output.decode())
    
    p.close()

exploit_malloc_overflow()
```

### Bypassing Size Checks

```python
#!/usr/bin/env python3
from pwn import *

def bypass_size_validation():
    """Bypass size validation using integer overflow"""
    
    size_check_c = '''
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_BUFFER_SIZE 1024

void process_input(unsigned int size1, unsigned int size2) {
    // Validation: individual sizes are reasonable
    if (size1 > MAX_BUFFER_SIZE || size2 > MAX_BUFFER_SIZE) {
        printf("Size too large\\n");
        return;
    }
    
    // VULNERABLE: size1 + size2 can overflow
    unsigned int total_size = size1 + size2;
    
    printf("Allocating buffer of size: %u\\n", total_size);
    
    char *buffer = malloc(total_size);
    if (!buffer) {
        printf("Allocation failed\\n");
        return;
    }
    
    // Fill first part
    memset(buffer, 'A', size1);
    
    // Fill second part  
    memset(buffer + size1, 'B', size2);
    
    printf("Buffer filled\\n");
    free(buffer);
}

int main(int argc, char *argv[]) {
    if (argc != 3) return 1;
    
    unsigned int size1 = atoi(argv[1]);
    unsigned int size2 = atoi(argv[2]);
    
    process_input(size1, size2);
    return 0;
}
'''
    
    print("Size validation bypass concept:")
    print("size1 = 1000, size2 = 1000 -> total = 2000 (normal)")
    print("size1 = 0xffffffff, size2 = 2 -> total = 1 (overflow)")
    
    # Both individual sizes pass validation
    # But their sum overflows to small value
    size1 = 0xffffffff  # UINT_MAX
    size2 = 2
    
    print(f"size1: {size1}")
    print(f"size2: {size2}")
    print(f"sum (with overflow): {(size1 + size2) & 0xffffffff}")

def width_overflow_attack():
    """Exploit width calculation overflow"""
    
    width_calc_c = '''
#include <stdio.h>
#include <stdlib.h>

typedef struct {
    unsigned int width;
    unsigned int height;
    unsigned char *pixels;
} image;

image* create_image(unsigned int width, unsigned int height) {
    // Check individual dimensions
    if (width > 10000 || height > 10000) {
        printf("Dimensions too large\\n");
        return NULL;
    }
    
    // VULNERABLE: width * height can overflow
    unsigned int pixel_count = width * height;
    
    printf("Creating %ux%u image (%u pixels)\\n", width, height, pixel_count);
    
    image *img = malloc(sizeof(image));
    if (!img) return NULL;
    
    // VULNERABLE: Small allocation due to overflow
    img->pixels = malloc(pixel_count);
    if (!img->pixels) {
        free(img);
        return NULL;
    }
    
    img->width = width;
    img->height = height;
    
    return img;
}

void fill_image(image *img, unsigned char color) {
    // This loop uses the original dimensions
    // But buffer was allocated with overflowed size
    for (unsigned int y = 0; y < img->height; y++) {
        for (unsigned int x = 0; x < img->width; x++) {
            img->pixels[y * img->width + x] = color;
        }
    }
}
'''
    
    print("Width overflow attack concept:")
    print("width = 65536, height = 65536")
    print("width * height = 4294967296 = 0 (overflow)")
    print("malloc(0) allocates small buffer")
    print("But fill_image writes 65536 * 65536 pixels")

bypass_size_validation()
```

### Memory Corruption Attacks

```python
#!/usr/bin/env python3
from pwn import *

def heap_corruption_via_overflow():
    """Corrupt heap metadata using integer overflow"""
    
    heap_exploit_c = '''
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
    unsigned int size;
    char *data;
} buffer_struct;

buffer_struct* create_buffer(unsigned int count, unsigned int item_size) {
    // Individual checks pass
    if (count > 1000000 || item_size > 1000) {
        printf("Parameters too large\\n");
        return NULL;
    }
    
    // VULNERABLE: count * item_size overflows
    unsigned int total_size = count * item_size;
    
    printf("Creating buffer: %u * %u = %u bytes\\n", count, item_size, total_size);
    
    buffer_struct *buf = malloc(sizeof(buffer_struct));
    if (!buf) return NULL;
    
    buf->data = malloc(total_size);
    if (!buf->data) {
        free(buf);
        return NULL;
    }
    
    buf->size = count * item_size;  // Store original calculation
    
    return buf;
}

void write_pattern(buffer_struct *buf, unsigned char pattern) {
    // Write pattern to entire "buffer"
    // But actual allocated size might be much smaller
    memset(buf->data, pattern, buf->size);
}
'''
    
    print("Heap corruption concept:")
    print("1. Allocate buffer with overflowed size calculation")
    print("2. Write data based on original size values")
    print("3. Overwrite adjacent heap chunks")
    print("4. Corrupt heap metadata")

def stack_corruption_via_alloca():
    """Corrupt stack using alloca with overflowed size"""
    
    alloca_exploit_c = '''
#include <stdio.h>
#include <stdlib.h>
#include <alloca.h>
#include <string.h>

void vulnerable_function(unsigned int count, unsigned int size) {
    // Check individual parameters
    if (count > 1000 || size > 1000) {
        printf("Parameters too large\\n");
        return;
    }
    
    // VULNERABLE: count * size overflows
    unsigned int total_size = count * size;
    
    printf("Allocating %u bytes on stack\\n", total_size);
    
    // alloca on stack with overflowed size
    char *stack_buffer = alloca(total_size);
    
    // Write based on original calculation
    for (unsigned int i = 0; i < count; i++) {
        memset(stack_buffer + i * size, 'A' + (i % 26), size);
    }
    
    printf("Stack buffer filled\\n");
}
'''
    
    print("Stack corruption concept:")
    print("1. alloca allocates small buffer due to overflow")
    print("2. Writing loop uses original values")
    print("3. Overwrites return address and other stack data")

def format_string_with_overflow():
    """Combine integer overflow with format string"""
    
    format_overflow_c = '''
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void log_message(char *format, unsigned int repeat_count) {
    // Simple validation
    if (repeat_count > 100) {
        printf("Repeat count too high\\n");
        return;
    }
    
    // VULNERABLE: repeat_count * strlen(format) can overflow
    unsigned int total_length = repeat_count * strlen(format);
    
    char *log_buffer = malloc(total_length + 1);
    if (!log_buffer) return;
    
    // Build repeated message
    log_buffer[0] = '\\0';
    for (unsigned int i = 0; i < repeat_count; i++) {
        strcat(log_buffer, format);  // VULNERABLE: format string
    }
    
    // VULNERABLE: User-controlled format string
    printf(log_buffer);
    
    free(log_buffer);
}
'''
    
    print("Combined integer overflow + format string:")
    print("1. Overflow in length calculation")
    print("2. Small buffer allocated")
    print("3. strcat writes beyond buffer")
    print("4. Format string vulnerability in printf")

heap_corruption_via_overflow()
```

## Advanced Integer Overflow Techniques

### Race Conditions with TOCTOU

```python
#!/usr/bin/env python3
import threading
import time

def toctou_integer_overflow():
    """Time-of-check to time-of-use with integer overflow"""
    
    toctou_c = '''
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

// Global variable that can be modified by another thread
volatile unsigned int global_size = 100;

void process_data() {
    // Time of Check: validate size
    if (global_size > 1000) {
        printf("Size too large: %u\\n", global_size);
        return;
    }
    
    printf("Size validated: %u\\n", global_size);
    
    // Simulate delay (another thread can modify global_size here)
    usleep(1000);
    
    // Time of Use: use the size for allocation
    char *buffer = malloc(global_size);
    if (!buffer) {
        printf("Allocation failed\\n");
        return;
    }
    
    // Use size again (might be different now)
    memset(buffer, 'A', global_size);
    
    printf("Buffer filled with size: %u\\n", global_size);
    free(buffer);
}

void attacker_thread() {
    // Wait for victim to pass validation
    usleep(500);
    
    // Change size to cause overflow
    global_size = 0xffffffff;  // Very large value
    
    printf("Attacker changed size to: %u\\n", global_size);
}
'''
    
    print("TOCTOU integer overflow concept:")
    print("1. Thread 1 validates global_size (passes check)")
    print("2. Thread 2 modifies global_size to large value")
    print("3. Thread 1 uses modified value in allocation/operations")

def atomic_operation_bypass():
    """Bypass using non-atomic operations"""
    
    atomic_c = '''
#include <stdio.h>
#include <stdlib.h>
#include <stdatomic.h>

atomic_uint shared_counter = 0;

void increment_and_allocate() {
    // Non-atomic read-modify-write
    unsigned int current = atomic_load(&shared_counter);
    
    // Validation based on current value
    if (current > 1000) {
        printf("Counter too high: %u\\n", current);
        return;
    }
    
    // Another thread can increment counter here
    
    // Increment (non-atomic with validation)
    current++;
    atomic_store(&shared_counter, current);
    
    // Use incremented value for allocation
    char *buffer = malloc(current * 1000);  // Can overflow
    if (buffer) {
        printf("Allocated buffer based on counter: %u\\n", current);
        free(buffer);
    }
}
'''
    
    print("Atomic operation bypass concept:")
    print("1. Read counter value atomically")
    print("2. Validate read value")
    print("3. Non-atomic increment creates race window")
    print("4. Other threads can modify counter between read and use")

toctou_integer_overflow()
```

### Cryptographic Integer Overflows

```python
#!/usr/bin/env python3

def crypto_length_overflow():
    """Integer overflow in cryptographic operations"""
    
    crypto_c = '''
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <openssl/aes.h>

void encrypt_data(unsigned char *plaintext, unsigned int plaintext_len) {
    // Validate input length
    if (plaintext_len > 1000000) {
        printf("Plaintext too long\\n");
        return;
    }
    
    // VULNERABLE: padding calculation can overflow
    unsigned int padded_len = plaintext_len + 16;  // Add AES block size
    
    if (padded_len < plaintext_len) {
        printf("Overflow detected\\n");
        return;
    }
    
    // Allocate buffer for padded plaintext
    unsigned char *padded = malloc(padded_len);
    if (!padded) return;
    
    // Copy plaintext
    memcpy(padded, plaintext, plaintext_len);
    
    // Add padding
    unsigned int padding_len = 16 - (plaintext_len % 16);
    memset(padded + plaintext_len, padding_len, padding_len);
    
    // Encrypt (simplified)
    printf("Encrypting %u bytes\\n", padded_len);
    
    free(padded);
}
'''
    
    print("Cryptographic integer overflow:")
    print("1. plaintext_len = 0xfffffff0")
    print("2. padded_len = plaintext_len + 16 = 0 (overflow)")
    print("3. malloc(0) allocates small buffer")
    print("4. memcpy writes large amount to small buffer")

def hash_length_extension():
    """Hash length extension with integer overflow"""
    
    hash_c = '''
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void hash_with_secret(unsigned char *message, unsigned int msg_len, 
                     unsigned char *secret, unsigned int secret_len) {
    
    // VULNERABLE: total_len can overflow
    unsigned int total_len = msg_len + secret_len;
    
    if (total_len < msg_len || total_len < secret_len) {
        printf("Length overflow detected\\n");
        return;
    }
    
    // Allocate combined buffer
    unsigned char *combined = malloc(total_len);
    if (!combined) return;
    
    // Combine message and secret
    memcpy(combined, message, msg_len);
    memcpy(combined + msg_len, secret, secret_len);
    
    // Hash the combined data
    printf("Hashing %u bytes\\n", total_len);
    
    free(combined);
}
'''
    
    print("Hash length extension overflow:")
    print("1. Attacker controls message length")
    print("2. msg_len + secret_len overflows")
    print("3. Small buffer allocated")
    print("4. Secret copied beyond buffer bounds")

crypto_length_overflow()
```

## Detection and Analysis

### Static Analysis for Integer Overflows

```python
#!/usr/bin/env python3
import re

def analyze_integer_overflows(code):
    """Static analysis for potential integer overflow vulnerabilities"""
    
    issues = []
    lines = code.split('\n')
    
    for i, line in enumerate(lines, 1):
        # Look for arithmetic operations with user input
        if re.search(r'(\w+)\s*(\+|\*)\s*(\w+)', line):
            # Check if result is used in memory operations
            if any(func in line for func in ['malloc', 'calloc', 'realloc', 'alloca']):
                issues.append(f"Line {i}: Potential overflow in memory allocation: {line.strip()}")
            
            if any(func in line for func in ['memcpy', 'memset', 'memmove']):
                issues.append(f"Line {i}: Potential overflow in memory operation: {line.strip()}")
        
        # Look for size calculations
        if re.search(r'size\s*=.*\*', line) or re.search(r'count\s*\*\s*sizeof', line):
            issues.append(f"Line {i}: Size calculation may overflow: {line.strip()}")
        
        # Look for array indexing with calculations
        if re.search(r'\[.*\+.*\]', line):
            issues.append(f"Line {i}: Array index calculation may overflow: {line.strip()}")
        
        # Look for loops with user-controlled bounds
        if re.search(r'for.*<.*atoi', line) or re.search(r'while.*<.*user', line):
            issues.append(f"Line {i}: Loop bound from user input: {line.strip()}")
    
    return issues

def check_type_mixing(code):
    """Check for dangerous type mixing that can lead to overflows"""
    
    issues = []
    lines = code.split('\n')
    
    for i, line in enumerate(lines, 1):
        # Look for signed/unsigned mixing
        if re.search(r'unsigned.*=.*atoi', line):
            issues.append(f"Line {i}: Signed to unsigned conversion: {line.strip()}")
        
        if re.search(r'size_t.*=.*int', line) and 'unsigned' not in line:
            issues.append(f"Line {i}: Signed int to size_t conversion: {line.strip()}")
        
        # Look for casting without validation
        if re.search(r'\(.*int\)', line) and any(func in line for func in ['malloc', 'sizeof']):
            issues.append(f"Line {i}: Unchecked type cast: {line.strip()}")
    
    return issues

# Example usage
vulnerable_code = '''
void process_data(int count, int size) {
    unsigned int total = count * size;  // Overflow risk
    char *buffer = malloc(total);       // Small allocation if overflow
    
    for (int i = 0; i < count; i++) {   // Loop uses original values
        memset(buffer + i * size, 'A', size);  // Buffer overflow
    }
}

void copy_string(char *src) {
    int len = strlen(src);
    char *dest = malloc(len + 1);       // len + 1 can overflow
    strcpy(dest, src);
}
'''

overflow_issues = analyze_integer_overflows(vulnerable_code)
type_issues = check_type_mixing(vulnerable_code)

print("Integer overflow issues:")
for issue in overflow_issues:
    print(f"  {issue}")

print("\nType mixing issues:")
for issue in type_issues:
    print(f"  {issue}")
```

### Dynamic Detection with Sanitizers

```bash
# Compile with integer overflow detection
gcc -fsanitize=signed-integer-overflow -fsanitize=unsigned-integer-overflow \
    -g -o overflow_test program.c

# Run with overflow detection
./overflow_test

# Enable additional checks
export UBSAN_OPTIONS="print_stacktrace=1:halt_on_error=1"
./overflow_test
```

### Runtime Testing

```python
#!/usr/bin/env python3
from pwn import *
import struct

def test_integer_boundaries(binary_path):
    """Test various integer boundary conditions"""
    
    test_cases = [
        # Unsigned integer boundaries
        ("0", "Zero"),
        ("1", "One"),
        ("4294967295", "UINT_MAX (32-bit)"),
        ("4294967296", "UINT_MAX + 1"),
        ("18446744073709551615", "ULLONG_MAX (64-bit)"),
        
        # Signed integer boundaries
        ("2147483647", "INT_MAX (32-bit)"),
        ("2147483648", "INT_MAX + 1"),
        ("-2147483648", "INT_MIN (32-bit)"),
        ("-2147483649", "INT_MIN - 1"),
        
        # Overflow-inducing pairs
        ("4294967295", "UINT_MAX for size calculations"),
        ("65536", "Large value for width/height"),
        ("0xffffffff", "Hex UINT_MAX"),
    ]
    
    results = []
    
    for test_input, description in test_cases:
        try:
            p = process([binary_path, test_input])
            output = p.recvall(timeout=2)
            
            result = {
                'input': test_input,
                'description': description,
                'output': output,
                'crashed': p.returncode != 0,
                'returncode': p.returncode
            }
            
            results.append(result)
            p.close()
            
        except Exception as e:
            results.append({
                'input': test_input,
                'description': description,
                'error': str(e),
                'crashed': True
            })
    
    return results

def fuzz_arithmetic_operations():
    """Fuzz arithmetic operations for overflows"""
    
    import random
    
    # Generate test values around boundaries
    test_values = [
        # Near 32-bit boundaries
        0xfffffffe, 0xffffffff, 0x80000000, 0x7fffffff,
        # Near 16-bit boundaries  
        0xfffe, 0xffff, 0x8000, 0x7fff,
        # Powers of 2
        2**8, 2**16, 2**24, 2**32,
        # Random large values
        random.randint(0xf0000000, 0xffffffff) for _ in range(10)
    ]
    
    overflow_cases = []
    
    for val1 in test_values[:10]:  # Limit combinations
        for val2 in test_values[:10]:
            # Test addition overflow
            add_result = (val1 + val2) & 0xffffffff
            if add_result < val1 or add_result < val2:
                overflow_cases.append(('add', val1, val2, add_result))
            
            # Test multiplication overflow
            mul_result = (val1 * val2) & 0xffffffff
            if val2 != 0 and mul_result // val2 != val1:
                overflow_cases.append(('mul', val1, val2, mul_result))
    
    print(f"Found {len(overflow_cases)} overflow cases")
    for op, val1, val2, result in overflow_cases[:5]:
        print(f"{op}: 0x{val1:x} {op} 0x{val2:x} = 0x{result:x}")
    
    return overflow_cases

# Example usage
# results = test_integer_boundaries('./vuln_overflow')
# overflow_cases = fuzz_arithmetic_operations()
```

## Mitigation and Prevention

### Safe Integer Arithmetic

```c
// safe_arithmetic.c - Safe integer operations

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <limits.h>

// Safe addition
bool safe_add_uint(unsigned int a, unsigned int b, unsigned int *result) {
    if (a > UINT_MAX - b) {
        return false;  // Overflow would occur
    }
    
    *result = a + b;
    return true;
}

bool safe_add_int(int a, int b, int *result) {
    if (b > 0 && a > INT_MAX - b) {
        return false;  // Positive overflow
    }
    
    if (b < 0 && a < INT_MIN - b) {
        return false;  // Negative overflow
    }
    
    *result = a + b;
    return true;
}

// Safe multiplication
bool safe_mul_uint(unsigned int a, unsigned int b, unsigned int *result) {
    if (a != 0 && b > UINT_MAX / a) {
        return false;  // Overflow would occur
    }
    
    *result = a * b;
    return true;
}

bool safe_mul_size_t(size_t a, size_t b, size_t *result) {
    if (a != 0 && b > SIZE_MAX / a) {
        return false;  // Overflow would occur
    }
    
    *result = a * b;
    return true;
}

// Safe array allocation
void* safe_array_alloc(size_t count, size_t element_size) {
    size_t total_size;
    
    if (!safe_mul_size_t(count, element_size, &total_size)) {
        printf("Array allocation would overflow\n");
        return NULL;
    }
    
    return malloc(total_size);
}

// Safe buffer operations
bool safe_buffer_copy(void *dest, size_t dest_size, 
                     const void *src, size_t src_size) {
    if (src_size > dest_size) {
        printf("Source too large for destination\n");
        return false;
    }
    
    memcpy(dest, src, src_size);
    return true;
}

// Example usage
int main() {
    unsigned int a = 0xffffffff;
    unsigned int b = 2;
    unsigned int result;
    
    if (safe_add_uint(a, b, &result)) {
        printf("Addition result: %u\n", result);
    } else {
        printf("Addition would overflow\n");
    }
    
    // Safe array allocation
    size_t count = 1000000;
    size_t element_size = sizeof(int);
    
    int *array = safe_array_alloc(count, element_size);
    if (array) {
        printf("Array allocated successfully\n");
        free(array);
    } else {
        printf("Array allocation failed or would overflow\n");
    }
    
    return 0;
}
```

### Compiler-Based Protections

```bash
# Enable integer overflow detection
gcc -fsanitize=signed-integer-overflow \
    -fsanitize=unsigned-integer-overflow \
    -ftrapv \
    -o protected_program program.c

# Enable all warnings
gcc -Wall -Wextra -Wconversion -Wsign-conversion \
    -Woverflow -o warned_program program.c

# Use safe alternatives
# Consider using languages with built-in overflow protection
```

### Language-Level Solutions

```rust
// Rust example with built-in overflow protection
fn safe_arithmetic_rust() {
    let a: u32 = u32::MAX;
    let b: u32 = 1;
    
    // This will panic in debug mode, wrap in release mode
    // let result = a + b;
    
    // Safe operations
    match a.checked_add(b) {
        Some(result) => println!("Result: {}", result),
        None => println!("Overflow detected"),
    }
    
    // Saturating arithmetic
    let saturated = a.saturating_add(b);
    println!("Saturated result: {}", saturated);
    
    // Wrapping arithmetic (explicit)
    let wrapped = a.wrapping_add(b);
    println!("Wrapped result: {}", wrapped);
}
```

## Key Takeaways

!!! important "Integer Overflow Fundamentals"
    - **Arithmetic can exceed type limits** - Addition and multiplication are common sources
    - **Wraparound behavior varies** - Signed vs unsigned have different overflow behavior  
    - **Memory operations are vulnerable** - malloc, memcpy, array indexing affected
    - **Validation can be bypassed** - Overflow can make large values appear small
    - **Combined with other bugs** - Often enables exploitation of other vulnerabilities

!!! warning "Common Mistakes"
    - Not checking for overflow in size calculations
    - Mixing signed and unsigned types without validation
    - Assuming larger types prevent overflow
    - Only checking upper bounds in validation
    - Using user input directly in arithmetic operations

!!! tip "Prevention Strategies"
    - Use safe arithmetic functions that check for overflow
    - Validate inputs before arithmetic operations
    - Use appropriate data types for the expected value range
    - Enable compiler warnings and sanitizers during development
    - Consider using languages with built-in overflow protection

---

*Next: [Understanding Mitigations](../protection/01-mitigations.md)*
