# Understanding Mitigations

Modern operating systems and compilers implement various security mitigations to make exploitation more difficult. Understanding these protections is crucial for both defensive and offensive security. This chapter covers the most common mitigations and their fundamental principles.

## Overview of Security Mitigations

### The Evolution of Protections

```
Timeline of Security Mitigations:
┌─────────────────────┐
│ 1990s: Basic Stack  │ ← Early stack protection attempts
│ Protection          │
├─────────────────────┤
│ 2000s: NX/DEP       │ ← Non-executable memory
├─────────────────────┤
│ 2001: Stack Canaries│ ← GCC stack protection
├─────────────────────┤
│ 2005: ASLR          │ ← Address Space Layout Randomization
├─────────────────────┤
│ 2010s: Enhanced     │ ← SMEP, SMAP, CET
│ Hardware Features   │
├─────────────────────┤
│ 2020s: Modern       │ ← CET, PAC, BTI
│ Hardware Mitigations│
└─────────────────────┘
```

### Categories of Mitigations

1. **Preventive** - Stop exploitation attempts
2. **Detective** - Detect exploitation attempts
3. **Mitigative** - Reduce impact of successful exploitation

## Stack Protection Mechanisms

### Stack Canaries (Stack Guards)

Stack canaries are values placed between local variables and the return address to detect buffer overflows.

```c
// How stack canaries work
void function_with_canary() {
    // Compiler inserts canary value
    unsigned long canary = get_random_canary();
    
    char buffer[100];  // Local variables
    
    // User code here...
    
    // Before return, compiler checks canary
    if (canary != get_original_canary()) {
        abort();  // Stack smashing detected
    }
    
    return;  // Safe to return
}
```

#### Types of Stack Canaries

```c
// 1. Terminator canaries (null, newline, EOF, -1)
unsigned int terminator_canary = 0x000aff0d;

// 2. Random canaries  
unsigned long random_canary = random_value();

// 3. Random XOR canaries
unsigned long xor_canary = random_value() ^ return_address;
```

#### Stack Layout with Canaries

```
Stack Layout:
High Address
┌─────────────────────┐
│   Function Args     │
├─────────────────────┤
│   Return Address    │ ← Protected by canary
├─────────────────────┤
│   Saved Frame Ptr   │
├─────────────────────┤
│   Stack Canary      │ ← Detection mechanism
├─────────────────────┤
│   Local Variables   │
│   (buffer)          │
└─────────────────────┘
Low Address
```

### Analyzing Stack Canaries

```python
#!/usr/bin/env python3
from pwn import *

def analyze_canary_protection():
    """Analyze how stack canaries work"""
    
    # Compile test program with different canary settings
    test_c = '''
#include <stdio.h>
#include <string.h>

void vulnerable_function() {
    char buffer[64];
    printf("Enter input: ");
    gets(buffer);
    printf("Input: %s\\n", buffer);
}

int main() {
    vulnerable_function();
    return 0;
}
'''
    
    print("Stack canary analysis:")
    print("1. Compile without canaries: gcc -fno-stack-protector")
    print("2. Compile with canaries: gcc -fstack-protector-all")
    print("3. Try buffer overflow and observe behavior")

def detect_canary_implementation():
    """Detect canary implementation details"""
    
    canary_test_c = '''
#include <stdio.h>
#include <unistd.h>

void show_canary_location() {
    char buffer[64];
    unsigned long canary;
    
    // This is implementation-specific
    // Canary is typically at %fs:0x28 on x86_64
    asm("mov %%fs:0x28, %0" : "=r" (canary));
    
    printf("Buffer address: %p\\n", buffer);
    printf("Canary value: 0x%016lx\\n", canary);
    printf("Canary location: %%fs:0x28\\n");
}

int main() {
    show_canary_location();
    return 0;
}
'''
    
    print("Canary implementation details:")
    print("- x86_64: Stored at %fs:0x28")
    print("- ARM64: Stored in special register")
    print("- Initialized at process startup")

analyze_canary_protection()
```

## Address Space Layout Randomization (ASLR)

### ASLR Concepts

ASLR randomizes the memory layout of processes to make exploitation unpredictable.

```
Memory Layout with ASLR:
┌─────────────────────┐
│ Stack               │ ← Randomized base address
│ 0x7fff????0000     │
├─────────────────────┤
│ Libraries (libc)    │ ← Randomized load addresses
│ 0x7f??????0000     │
├─────────────────────┤
│ Heap                │ ← Randomized heap base
│ 0x????00000000     │
├─────────────────────┤
│ Program Binary      │ ← May be randomized (PIE)
│ 0x400000 or random  │
└─────────────────────┘
```

### ASLR Levels

```bash
# Check ASLR status on Linux
cat /proc/sys/kernel/randomize_va_space
# 0 = Disabled
# 1 = Conservative (stack, libraries, heap)
# 2 = Full (includes program binary with PIE)

# Disable ASLR for testing
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space

# Enable full ASLR
echo 2 | sudo tee /proc/sys/kernel/randomize_va_space
```

### Testing ASLR Effectiveness

```python
#!/usr/bin/env python3
from pwn import *
import subprocess

def test_aslr_randomization():
    """Test ASLR randomization effectiveness"""
    
    test_program = '''
#include <stdio.h>
#include <stdlib.h>

int main() {
    char stack_var;
    char *heap_var = malloc(10);
    
    printf("Stack: %p\\n", &stack_var);
    printf("Heap: %p\\n", heap_var);
    printf("Main: %p\\n", main);
    printf("Libc: %p\\n", printf);
    
    free(heap_var);
    return 0;
}
'''
    
    print("ASLR randomization test:")
    print("Run the same program multiple times and observe address changes")
    
    # Collect addresses from multiple runs
    addresses = {'stack': [], 'heap': [], 'main': [], 'libc': []}
    
    for i in range(5):
        try:
            result = subprocess.run(['./aslr_test'], 
                                  capture_output=True, text=True, timeout=2)
            
            lines = result.stdout.split('\n')
            for line in lines:
                if 'Stack:' in line:
                    addr = line.split()[1]
                    addresses['stack'].append(addr)
                elif 'Heap:' in line:
                    addr = line.split()[1]
                    addresses['heap'].append(addr)
                elif 'Main:' in line:
                    addr = line.split()[1]
                    addresses['main'].append(addr)
                elif 'Libc:' in line:
                    addr = line.split()[1]
                    addresses['libc'].append(addr)
        except:
            continue
    
    # Analyze randomization
    for category, addrs in addresses.items():
        unique_addrs = len(set(addrs))
        print(f"{category}: {unique_addrs}/{len(addrs)} unique addresses")

def calculate_aslr_entropy():
    """Calculate ASLR entropy"""
    
    entropy_info = {
        'stack': 23,      # bits of randomization
        'heap': 12,       # typical heap randomization
        'libraries': 28,  # library load addresses
        'pie': 28,        # PIE randomization
    }
    
    print("Typical ASLR entropy (bits):")
    for component, bits in entropy_info.items():
        possibilities = 2 ** bits
        print(f"{component}: {bits} bits ({possibilities:,} possibilities)")

test_aslr_randomization()
```

## Data Execution Prevention (DEP/NX)

### Non-Executable Memory

DEP/NX prevents execution of code in data segments.

```
Memory Permissions:
┌─────────────────────┬─────┬─────┬─────┐
│ Segment             │  R  │  W  │  X  │
├─────────────────────┼─────┼─────┼─────┤
│ Code (.text)        │  ✓  │  ✗  │  ✓  │
│ Data (.data)        │  ✓  │  ✓  │  ✗  │
│ BSS                 │  ✓  │  ✓  │  ✗  │
│ Stack               │  ✓  │  ✓  │  ✗  │ ← NX prevents shellcode
│ Heap                │  ✓  │  ✓  │  ✗  │ ← NX prevents shellcode
└─────────────────────┴─────┴─────┴─────┘
```

### Hardware Support

```python
#!/usr/bin/env python3

def check_nx_support():
    """Check NX/DEP hardware support"""
    
    # Check CPU features
    import subprocess
    
    try:
        # Check for NX bit support
        result = subprocess.run(['cat', '/proc/cpuinfo'], 
                              capture_output=True, text=True)
        
        if 'nx' in result.stdout:
            print("✓ NX bit supported by CPU")
        else:
            print("✗ NX bit not supported")
        
        # Check current process memory mappings
        with open('/proc/self/maps', 'r') as f:
            maps = f.read()
        
        print("\nMemory mappings for current process:")
        for line in maps.split('\n')[:10]:  # First 10 lines
            if line:
                parts = line.split()
                if len(parts) >= 2:
                    address = parts[0]
                    perms = parts[1]
                    print(f"{address}: {perms}")
    
    except:
        print("Could not check NX support")

def test_executable_stack():
    """Test if stack is executable"""
    
    test_c = '''
#include <stdio.h>
#include <sys/mman.h>
#include <unistd.h>
#include <string.h>

// Shellcode: just returns
unsigned char shellcode[] = "\\xc3";  // ret instruction

int main() {
    printf("Testing stack execution...\\n");
    
    // Try to execute code on stack
    char stack_code[16];
    memcpy(stack_code, shellcode, sizeof(shellcode));
    
    printf("Attempting to execute stack code...\\n");
    
    // This should fail with NX enabled
    ((void(*)())stack_code)();
    
    printf("Stack execution succeeded (NX disabled)\\n");
    return 0;
}
'''
    
    print("Stack execution test:")
    print("Compile with: gcc -z execstack (allows stack execution)")
    print("Compile with: gcc -z noexecstack (prevents stack execution)")

check_nx_support()
```

## Position Independent Executable (PIE)

### PIE Concepts

PIE extends ASLR to randomize the program binary's load address.

```python
#!/usr/bin/env python3
from pwn import *

def analyze_pie_protection():
    """Analyze PIE protection"""
    
    # Non-PIE binary
    non_pie_c = '''
#include <stdio.h>

int main() {
    printf("main() at: %p\\n", main);
    return 0;
}
'''
    
    # PIE binary  
    pie_c = '''
#include <stdio.h>

int main() {
    printf("main() at: %p\\n", main);
    return 0;
}
'''
    
    print("PIE analysis:")
    print("Non-PIE: gcc -no-pie -o non_pie program.c")
    print("  - main() always at same address (e.g., 0x401234)")
    print("PIE: gcc -fPIE -pie -o pie_binary program.c")
    print("  - main() at random address each run")

def detect_pie_binary():
    """Detect if binary is compiled with PIE"""
    
    import subprocess
    
    def check_pie(binary_path):
        try:
            # Use readelf to check for PIE
            result = subprocess.run(['readelf', '-h', binary_path],
                                  capture_output=True, text=True)
            
            if 'DYN' in result.stdout:
                print(f"{binary_path}: PIE enabled (Dynamic)")
            elif 'EXEC' in result.stdout:
                print(f"{binary_path}: PIE disabled (Executable)")
            else:
                print(f"{binary_path}: Unknown type")
                
        except:
            print(f"Could not analyze {binary_path}")
    
    # Example usage
    print("PIE detection using readelf:")
    print("Type: EXEC = No PIE, DYN = PIE enabled")

analyze_pie_protection()
```

## Control Flow Integrity (CFI)

### CFI Concepts

CFI prevents attackers from hijacking program control flow.

```c
// CFI Example
void legitimate_function() {
    printf("Legitimate function\n");
}

void attacker_function() {
    printf("Attacker function\n");
    system("/bin/sh");
}

int main() {
    void (*func_ptr)() = legitimate_function;
    
    // Without CFI: attacker can change func_ptr to attacker_function
    // With CFI: call will be validated against allowed targets
    
    func_ptr();  // CFI checks if this is a valid call target
    
    return 0;
}
```

### Hardware CFI Features

```python
#!/usr/bin/env python3

def check_cfi_support():
    """Check for CFI hardware support"""
    
    cfi_features = {
        'Intel CET': {
            'description': 'Control-flow Enforcement Technology',
            'features': ['IBT (Indirect Branch Tracking)', 'Shadow Stack'],
            'status': 'Available on newer Intel CPUs'
        },
        'ARM Pointer Authentication': {
            'description': 'Cryptographic signatures for return addresses',
            'features': ['PAC (Pointer Authentication)', 'BTI (Branch Target Identification)'],
            'status': 'Available on ARMv8.3+ CPUs'
        },
        'Compiler CFI': {
            'description': 'Software-based control flow integrity',
            'features': ['Clang CFI', 'GCC -fcf-protection'],
            'status': 'Available in modern compilers'
        }
    }
    
    print("Control Flow Integrity Support:")
    for name, info in cfi_features.items():
        print(f"\n{name}:")
        print(f"  Description: {info['description']}")
        print(f"  Features: {', '.join(info['features'])}")
        print(f"  Status: {info['status']}")

check_cfi_support()
```

## RELRO (Relocation Read-Only)

### RELRO Protection

RELRO makes certain sections read-only after initialization.

```
RELRO Protection Levels:
┌─────────────────────┬─────────────────────┬─────────────────────┐
│ Protection Level    │ .got Protection     │ .got.plt Protection │
├─────────────────────┼─────────────────────┼─────────────────────┤
│ No RELRO           │ Read/Write          │ Read/Write          │
│ Partial RELRO      │ Read-Only           │ Read/Write          │
│ Full RELRO         │ Read-Only           │ Read-Only           │
└─────────────────────┴─────────────────────┴─────────────────────┘
```

### Testing RELRO

```python
#!/usr/bin/env python3
import subprocess

def check_relro_protection(binary_path):
    """Check RELRO protection level"""
    
    try:
        # Use checksec or readelf
        result = subprocess.run(['readelf', '-l', binary_path],
                              capture_output=True, text=True)
        
        if 'GNU_RELRO' in result.stdout:
            # Check for BIND_NOW
            bind_result = subprocess.run(['readelf', '-d', binary_path],
                                       capture_output=True, text=True)
            
            if 'BIND_NOW' in bind_result.stdout:
                print(f"{binary_path}: Full RELRO")
            else:
                print(f"{binary_path}: Partial RELRO")
        else:
            print(f"{binary_path}: No RELRO")
            
    except:
        print(f"Could not analyze {binary_path}")

def relro_compilation_options():
    """Show RELRO compilation options"""
    
    options = {
        'No RELRO': 'gcc -Wl,-z,norelro',
        'Partial RELRO': 'gcc (default)',
        'Full RELRO': 'gcc -Wl,-z,relro,-z,now'
    }
    
    print("RELRO Compilation Options:")
    for level, command in options.items():
        print(f"{level}: {command}")

relro_compilation_options()
```

## Fortify Source

### FORTIFY_SOURCE Protection

FORTIFY_SOURCE adds bounds checking to dangerous functions.

```c
// Example of FORTIFY_SOURCE protection
#include <stdio.h>
#include <string.h>

void unsafe_operations() {
    char buffer[10];
    char large_input[100];
    
    // FORTIFY_SOURCE can detect these:
    strcpy(buffer, large_input);        // Buffer too small
    memcpy(buffer, large_input, 50);    // Size exceeds buffer
    sprintf(buffer, "%s", large_input); // Format string overflow
}

// How FORTIFY_SOURCE works (simplified)
#ifdef __FORTIFY_SOURCE
#define strcpy(dest, src) \
    (__builtin_object_size(dest, 0) != -1 ? \
     __strcpy_chk(dest, src, __builtin_object_size(dest, 0)) : \
     strcpy(dest, src))
#endif
```

### Testing FORTIFY_SOURCE

```python
#!/usr/bin/env python3

def test_fortify_source():
    """Test FORTIFY_SOURCE protection"""
    
    test_c = '''
#include <stdio.h>
#include <string.h>

int main() {
    char small_buffer[10];
    char large_data[100];
    
    memset(large_data, 'A', sizeof(large_data));
    large_data[99] = '\\0';
    
    printf("Attempting dangerous copy...\\n");
    
    // This should be caught by FORTIFY_SOURCE
    strcpy(small_buffer, large_data);
    
    printf("Copy succeeded\\n");
    return 0;
}
'''
    
    print("FORTIFY_SOURCE test:")
    print("Compile with: gcc -D_FORTIFY_SOURCE=2 -O2")
    print("Should abort with: *** buffer overflow detected ***")

test_fortify_source()
```

## Comprehensive Protection Analysis

### Binary Protection Analysis Tool

```python
#!/usr/bin/env python3
import subprocess
import re

class BinaryProtectionAnalyzer:
    def __init__(self, binary_path):
        self.binary_path = binary_path
        self.protections = {}
    
    def check_all_protections(self):
        """Check all common protections"""
        
        self.check_nx_dep()
        self.check_stack_canary()
        self.check_pie()
        self.check_relro()
        self.check_fortify()
        
        return self.protections
    
    def check_nx_dep(self):
        """Check NX/DEP protection"""
        try:
            result = subprocess.run(['readelf', '-l', self.binary_path],
                                  capture_output=True, text=True)
            
            if 'GNU_STACK' in result.stdout:
                # Check if stack is executable
                if re.search(r'GNU_STACK.*RWE', result.stdout):
                    self.protections['NX'] = 'Disabled (Executable Stack)'
                else:
                    self.protections['NX'] = 'Enabled'
            else:
                self.protections['NX'] = 'Unknown'
        except:
            self.protections['NX'] = 'Check Failed'
    
    def check_stack_canary(self):
        """Check stack canary protection"""
        try:
            result = subprocess.run(['objdump', '-d', self.binary_path],
                                  capture_output=True, text=True)
            
            if '__stack_chk_fail' in result.stdout:
                self.protections['Stack Canary'] = 'Enabled'
            else:
                self.protections['Stack Canary'] = 'Disabled'
        except:
            self.protections['Stack Canary'] = 'Check Failed'
    
    def check_pie(self):
        """Check PIE protection"""
        try:
            result = subprocess.run(['readelf', '-h', self.binary_path],
                                  capture_output=True, text=True)
            
            if 'Type:' in result.stdout:
                if 'DYN' in result.stdout:
                    self.protections['PIE'] = 'Enabled'
                elif 'EXEC' in result.stdout:
                    self.protections['PIE'] = 'Disabled'
                else:
                    self.protections['PIE'] = 'Unknown'
        except:
            self.protections['PIE'] = 'Check Failed'
    
    def check_relro(self):
        """Check RELRO protection"""
        try:
            result = subprocess.run(['readelf', '-l', self.binary_path],
                                  capture_output=True, text=True)
            
            if 'GNU_RELRO' in result.stdout:
                # Check for BIND_NOW
                bind_result = subprocess.run(['readelf', '-d', self.binary_path],
                                           capture_output=True, text=True)
                
                if 'BIND_NOW' in bind_result.stdout:
                    self.protections['RELRO'] = 'Full'
                else:
                    self.protections['RELRO'] = 'Partial'
            else:
                self.protections['RELRO'] = 'Disabled'
        except:
            self.protections['RELRO'] = 'Check Failed'
    
    def check_fortify(self):
        """Check FORTIFY_SOURCE"""
        try:
            result = subprocess.run(['objdump', '-t', self.binary_path],
                                  capture_output=True, text=True)
            
            fortify_functions = ['__memcpy_chk', '__strcpy_chk', '__sprintf_chk']
            
            if any(func in result.stdout for func in fortify_functions):
                self.protections['FORTIFY_SOURCE'] = 'Enabled'
            else:
                self.protections['FORTIFY_SOURCE'] = 'Disabled'
        except:
            self.protections['FORTIFY_SOURCE'] = 'Check Failed'
    
    def print_report(self):
        """Print protection analysis report"""
        
        print(f"\nBinary Protection Analysis: {self.binary_path}")
        print("=" * 50)
        
        for protection, status in self.protections.items():
            if 'Enabled' in status or 'Full' in status:
                indicator = "✓"
            elif 'Disabled' in status:
                indicator = "✗"
            else:
                indicator = "?"
            
            print(f"{indicator} {protection:15} : {status}")

# Usage example
def analyze_binary_protections(binary_path):
    analyzer = BinaryProtectionAnalyzer(binary_path)
    analyzer.check_all_protections()
    analyzer.print_report()
    
    return analyzer.protections

# Example usage
# protections = analyze_binary_protections('./vulnerable_program')
```

## System-Level Protections

### Kernel Protections

```python
#!/usr/bin/env python3

def check_kernel_protections():
    """Check kernel-level protections"""
    
    kernel_protections = {
        'KASLR': '/proc/sys/kernel/randomize_va_space',
        'KPTI': '/sys/devices/system/cpu/vulnerabilities/meltdown',
        'SMEP': 'dmesg | grep SMEP',
        'SMAP': 'dmesg | grep SMAP',
    }
    
    print("Kernel Protection Status:")
    
    try:
        # Check ASLR
        with open('/proc/sys/kernel/randomize_va_space', 'r') as f:
            aslr_level = f.read().strip()
            levels = {
                '0': 'Disabled',
                '1': 'Conservative',
                '2': 'Full'
            }
            print(f"ASLR: {levels.get(aslr_level, 'Unknown')} ({aslr_level})")
    except:
        print("ASLR: Check Failed")
    
    # Check CPU vulnerabilities
    vuln_files = [
        'meltdown', 'spectre_v1', 'spectre_v2', 
        'spec_store_bypass', 'l1tf', 'mds'
    ]
    
    print("\nCPU Vulnerability Mitigations:")
    for vuln in vuln_files:
        try:
            with open(f'/sys/devices/system/cpu/vulnerabilities/{vuln}', 'r') as f:
                status = f.read().strip()
                print(f"{vuln}: {status}")
        except:
            continue

def check_address_space_layout():
    """Check current process address space layout"""
    
    try:
        with open('/proc/self/maps', 'r') as f:
            maps = f.read()
        
        print("\nCurrent Process Memory Layout:")
        print("Address Range          Perms  Mapping")
        print("-" * 50)
        
        for line in maps.split('\n')[:15]:  # First 15 mappings
            if line:
                parts = line.split()
                if len(parts) >= 2:
                    addr_range = parts[0]
                    perms = parts[1]
                    mapping = parts[-1] if len(parts) > 5 else "[anonymous]"
                    print(f"{addr_range:18} {perms:5} {mapping}")
    
    except:
        print("Could not read memory maps")

check_kernel_protections()
```

## Key Takeaways

!!! important "Security Mitigation Fundamentals"
    - **Defense in depth** - Multiple layers of protection work together
    - **Each mitigation addresses specific attack vectors** - No single protection is sufficient
    - **Hardware and software cooperation** - Modern protections leverage both
    - **Performance trade-offs** - Security comes with computational cost
    - **Bypass techniques exist** - Attackers continuously develop new methods

!!! warning "Common Misconceptions"
    - One protection is enough to prevent all attacks
    - Mitigations make exploitation impossible
    - All binaries have the same protection levels
    - Protections are either fully on or off
    - Modern systems are completely secure

!!! tip "Practical Applications"
    - Always enable available protections during compilation
    - Understand what each protection defends against
    - Test protection effectiveness in your environment
    - Keep systems updated for latest mitigation features
    - Combine mitigations with secure coding practices

---

*Next: [Stack Canary Bypass](02-canary-bypass.md)*
